<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ics文件解析</title>
    <url>/2020/07/23/ics/</url>
    <content><![CDATA[<blockquote>
<p>本文，翻译并节选至 <a href="https://tools.ietf.org/html/rfc2445" target="_blank" rel="noopener">rfc2445 规范文档</a></p>
</blockquote>
<p>首先一下是一个ICS文件的内容</p>
<pre class=" language-ics"><code class="language-ics">BEGIN:VCALENDAR
    PRODID:-//Chen Wei//2016 China Public Holiday Calendar//EN
    VERSION:2.0
    CALSCALE:GREGORIAN
    METHOD:PUBLISH
    X-WR-CALNAME:2016 China Public Holiday
    X-WR-TIMEZONE:Asia/Shanghai
    X-WR-CALDESC:上证公告[2015]36号
    BEGIN:VEVENT
        DTSTAMP:20160101T043225Z
        UID:20161007-holiday@infinet.github.io
        DTSTART;VALUE=DATE:20161007
        DTEND;VALUE=DATE:20161008
        STATUS:CONFIRMED
        SUMMARY:国庆节
    END:VEVENT
END:VCALENDAR</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>filetype</category>
      </categories>
      <tags>
        <tag>ics</tag>
        <tag>filetype</tag>
      </tags>
  </entry>
  <entry>
    <title>在Docker环境中备份MySQL并发送邮件</title>
    <url>/2020/11/12/%E6%9D%82%E8%AE%B0/docker_bakup_mysql/</url>
    <content><![CDATA[<h1 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h1><ul>
<li>备份数据库</li>
<li>发送备份文件至邮件</li>
<li>清理30天前的备份</li>
</ul>
<h1 id="前置处理-邮件服务准备"><a href="#前置处理-邮件服务准备" class="headerlink" title="前置处理(邮件服务准备)"></a>前置处理(邮件服务准备)</h1><blockquote>
<p><code>mailx</code> 在CentOS中一般是安装好的， <code>~/.certs</code> 针对SSL协议的邮件服务需要下载对应的邮件服务的证书</p>
</blockquote>
<ol>
<li><p>检测并安装邮件服务</p>
<pre class="line-numbers language-shell"><code class="language-shell"> # 检测是否安装了邮件服务
 mail
 # 或
 mailx

 # 安装mail
 yum install -y mailx
 yum install -y nss-tools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>下载邮件证书</p>
<pre class="line-numbers language-shell"><code class="language-shell"> mkdir -p ~/.certs
 echo -n | openssl s_client -connect smtp.qq.com:465 | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' > ~/.certs/qq.crt
 certutil -A -n "GeoTrust SSL CA" -t "C,," -d ~/.certs -i ~/.certs/qq.crt
 certutil -A -n "GeoTrust Global CA" -t "C,," -d ~/.certs -i ~/.certs/qq.crt
 certutil -A -n "GeoTrust SSL CA - G3" -t "Pu,Pu,Pu" -d ~/.certs/./ -i qq.crt
 certutil -L -d ~/.certs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>编辑配置文件</p>
<ol>
<li><p>编辑邮件配置文件</p>
<pre class="line-numbers language-shell"><code class="language-shell"> vim /etc/mail.rc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>追加以下内容，根据实际情况变动</p>
<pre class="line-numbers language-rc"><code class="language-rc"> set from=example@qq.com
 set smtp=smtps://smtp.qq.com:465                                              
 set smtp-auth-user=example@qq.com
 set smtp-auth-password=**************
 set smtp-auth=login
 set ssl-verify=ignore
 set nss-config-dir=/root/.certs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<table>
<thead>
<tr>
<th align="center">示例</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">set from=example@qq.com</td>
<td align="center">发送邮箱</td>
</tr>
<tr>
<td align="center">set smtp=smtps://smtp.qq.com:465</td>
<td align="center">发件服务器</td>
</tr>
<tr>
<td align="center">set smtp-auth-user=example@qq.com</td>
<td align="center">发件用户名</td>
</tr>
<tr>
<td align="center">set smtp-auth-password=<strong><strong><strong>**</strong></strong></strong></td>
<td align="center">邮箱密码或授权码</td>
</tr>
<tr>
<td align="center">set smtp-auth=login</td>
<td align="center">连接方式,用login即可</td>
</tr>
<tr>
<td align="center">set ssl-verify=ignore</td>
<td align="center">启用ssl</td>
</tr>
<tr>
<td align="center">set nss-config-dir=/root/.certs</td>
<td align="center">证书位置</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<ol start="4">
<li><p>测试发送邮件</p>
<pre class="line-numbers language-shell"><code class="language-shell"> echo "邮件正文" | mail -s "邮件主题" example@qq.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<h1 id="在Docker中备份MySQL"><a href="#在Docker中备份MySQL" class="headerlink" title="在Docker中备份MySQL"></a>在Docker中备份MySQL</h1><ol>
<li><p>备份脚本</p>
<ol>
<li><p>创建脚本</p>
<blockquote>
<p>copy以下内容，创建备份脚本<code>backup,sh</code></p>
</blockquote>
<pre class="line-numbers language-shell"><code class="language-shell"> #!/bin/bash
 # 变量
 env_name="xxxx环境"
 docker_name="dockerId_forMySQL"
 base_data_dir="/home/backup/mysql/"

 date_str="`date +%Y%m%d`"
 base_name="data_`date +%Y%m%d`"
 data_dir="$base_data_dir/$base_name"
 file_path="$data_dir/data_`date +%Y%m%d`.sql"

 mkdir $data_dir

 # 备份操作
 docker exec -it ${docker_name} mysqldump -uroot -proot --all-databases > $file_path
 if [ $? -ne 0 ];then
     # 任务失败，发送邮件
     echo -e $env_name$date_str"备份失败" | mailx -s $env_name$date_str'备份失败' example@qq.com
     exit -1
 fi

 echo "备份完成"

 cd $data_dir
 zip $base_name.zip -r $data_dir
 zip -s 45m $base_name.zip --out s_$base_name.zip
 echo "分卷完成"
 find $base_data_dir -name 's_data_[1-9]*'

 # 获取分卷的压缩包集合
 for file in $data_dir/s_*
 do
     echo $file
     # 任务成功，发送邮件
     echo -e $env_name$date_str"备份成功\n"$file | mailx -s $env_name$date_str'备份成功' -a $file example@qq.com
     echo "发件完成"
 done

 # 清理30天前的备份
 find $base_data_dir -mtime +30 -name 'data_[1-9]' -exec rm -rf {} \;
 echo "清理完成"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>测试脚本</p>
<pre class="line-numbers language-shell"><code class="language-shell"> sh backup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
</li>
<li><p>编辑定时任务</p>
<ol>
<li>进入编辑页面<pre class="line-numbers language-shell"><code class="language-shell"> crontab -e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>追加定时执行<pre class="line-numbers language-shell"><code class="language-shell"> # 不带日志
  0 4 * * * sh /path/backup.sh
 # 带日志
 0 4 * * * sh /path/backup.sh > /path/backup.log 2>&1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>亲，做好被邮件轰炸的准备吧,因为到这里，你已经配置完成，每天接受你管理的环境数的邮件，(#^.^#)</p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Centos 7 Mq-- 小米规整</title>
    <url>/2018/02/13/Linux/Centos%207%20Mq/</url>
    <content><![CDATA[<h1 id="安装erlang"><a href="#安装erlang" class="headerlink" title="安装erlang"></a>安装erlang</h1><ol>
<li><p>安装仓库</p>
<blockquote>
<p>直接rpm文件出错</p>
</blockquote>
</li>
<li><p>导入KEY</p>
<pre class=" language-bash"><code class="language-bash">rpm --import https://packages.erlang-solutions.com/rpm/erlang_solutions.asc</code></pre>
</li>
<li><p>手动添加仓库</p>
<pre class=" language-ini"><code class="language-ini"># In /etc/yum.repos.d/rabbitmq-erlang.repo
<span class="token selector">[rabbitmq-erlang]</span>
<span class="token constant">name</span><span class="token attr-value"><span class="token punctuation">=</span>rabbitmq-erlang</span>
<span class="token constant">baseurl</span><span class="token attr-value"><span class="token punctuation">=</span>https://dl.bintray.com/rabbitmq/rpm/erlang/20/el/7</span>
<span class="token constant">gpgcheck</span><span class="token attr-value"><span class="token punctuation">=</span>1</span>
<span class="token constant">gpgkey</span><span class="token attr-value"><span class="token punctuation">=</span>https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc</span>
<span class="token constant">repo_gpgcheck</span><span class="token attr-value"><span class="token punctuation">=</span>0</span>
<span class="token constant">enabled</span><span class="token attr-value"><span class="token punctuation">=</span>1</span></code></pre>
</li>
<li><p>安装erlang</p>
<pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> erlang</code></pre>
</li>
</ol>
<h1 id="Install-RabbitMQ-Server"><a href="#Install-RabbitMQ-Server" class="headerlink" title="Install RabbitMQ Server"></a>Install RabbitMQ Server</h1><pre class=" language-bash"><code class="language-bash">rpm --import https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc
<span class="token function">wget</span> https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.5/rabbitmq-server-3.7.5-1.el7.noarch.rpm
yum <span class="token function">install</span> rabbitmq-server-3.7.5-1.el7.noarch.rpm</code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用的Shell命令</title>
    <url>/2018/03/21/Linux/Linux%E5%B8%B8%E7%94%A8%E7%9A%84Shell%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍Linux系统下常用的系统级命令，包括软硬件查看、修改命令，有CPU、内存、硬盘、网络、系统管理等命令。说明，所有命令是在Centos 6.4 64位的虚拟机系统进行测试的。本文介绍的命令都会在此Centos下运行验证（也有部分命令会在suse/ubuntu系统里测试的，会做特明说明），但运行结果就不再列出了。</p>
</blockquote>
<a id="more"></a>
<h2 id="硬件篇"><a href="#硬件篇" class="headerlink" title="硬件篇"></a>硬件篇</h2><h3 id="CPU相关"><a href="#CPU相关" class="headerlink" title="CPU相关"></a>CPU相关</h3><pre class=" language-shell"><code class="language-shell">lscpu                   #查看的是cpu的统计信息.
cat /proc/cpuinfo       #查看CPU信息详细信息，如每个CPU的型号，主频等</code></pre>
<h3 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h3><pre><code>free -m                 #概要查看内存情况  这里的单位是MB
cat /proc/meminfo       #查看内存详细信息</code></pre><h3 id="磁盘相关"><a href="#磁盘相关" class="headerlink" title="磁盘相关"></a>磁盘相关</h3><pre class=" language-bash"><code class="language-bash">lsblk                   <span class="token comment" spellcheck="true">#查看硬盘和分区分布，显示很直观</span>
<span class="token function">df</span> -h                   <span class="token comment" spellcheck="true">#查看各分区使用情况</span>
<span class="token function">cat</span> /proc/partitions    <span class="token comment" spellcheck="true">#查看硬盘和分区</span>
<span class="token function">mount</span> <span class="token operator">|</span> column -t       <span class="token comment" spellcheck="true">#查看挂接的分区状态</span></code></pre>
<h3 id="网卡相关"><a href="#网卡相关" class="headerlink" title="网卡相关"></a>网卡相关</h3><pre><code>lspci | grep -i 'eth'   #查看网卡硬件信息
ifconfig -a             #查看系统的所有网络接口
ethtool eth0            #如果要查看某个网络接口的详细信息，例如eth0的详细参数和指标</code></pre><h2 id="软件篇"><a href="#软件篇" class="headerlink" title="软件篇"></a>软件篇</h2><h3 id="内核相关"><a href="#内核相关" class="headerlink" title="内核相关"></a>内核相关</h3><pre><code>uname -a                #查看版本当前操作系统内核信息）
cat /proc/version       #查看当前操作系统版本信息
cat /etc/issue          #查看版本当前操作系统发行版信息
cat /etc/redhat-release #同上
cat /etc/SuSE-release   #suse系统下才可使用
lsb_release -a          #用来查看linux兼容性的发行版信息
lsmod                   #列出加载的内核模块</code></pre><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><pre><code>ifconfig                #查看所有网络接口的属性
iptables -L             #查看防火墙设置
service iptables status #查看防火墙状态
service iptables stop   #关闭防火墙
route -n                #查看路由表
netstat -lntp           #查看所有监听端口
netstat -antp           #查看所有已经建立的连接
netstat -s              #查看网络统计信息进程
netstat -at             #列出所有tcp端口
netstat -au             #列出所有udp端口
netstat -lt             #只列出所有监听tcp端口</code></pre><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><pre><code>top                     #查看系统所有进程的详细信息，比如CPU、内存等,信息很多！
df -lh                  #查看硬盘大小及使用率
mount                   #挂接远程目录、NFS、本地共享目录到linux下
hostname                #查看/修改计算机名
w                       #查看活动用户
id                      #查看指定用户信息
last                    #查看用户登录日志
cut -d:-f1 /etc/passwd  #查看系统所有用户
cut -d:-f1 /etc/group   #查看系统所有组
crontab -l              #查看当前用户的计划任务服务
chkconfig –list        #列出所有系统服务
chkconfig –list | grep on #列出所有启动的系统服务程序
rpm -qa                 #查看所有安装的软件包
uptime                  #查看系统运行时间、用户数、负载    
/sbin/chkconfig --list  #查看系统自动启动列表
/sbin/chkconfig –addmysql #把MySQL添加到系统的启动服务组里面</code></pre><h3 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h3><pre><code>ls -lht                 #列出一个文件夹下所有文件及大小、访问权限
du -sh                  #查看指定目录的大小 
du -lh                  #查看指定目录及各文件的大小 
ln -s                   #建立软链接
rsync -av /source/ /target/ #复制且合并 source 到 target 中</code></pre><h3 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h3><pre><code>pstree -p pid           #查看一个进程下的所有线程
pstree  -a              #显示所有进程的所有详细信息，遇到相同的进程名可以压缩显示
ps -ef                  #查看所有进程
kill -9 pid             #杀死进程
kill all test           #杀死进程
kill -9`pgrep test`     #杀死进程
./test.sh &amp;             #使程序在后台运行
nohup ./test.sh &amp;       #使程序在后台运行</code></pre><h3 id="压缩解压缩"><a href="#压缩解压缩" class="headerlink" title="压缩解压缩"></a>压缩解压缩</h3><pre><code>zip -r dir.zip dir file         #将目录dir、文件file等压缩到zip包,
zip -re dir.zip dir file        #创建zip包，且加密
unzip dir.zip                   #解压
tar -zcvf dir.tar.gz dir file   #将目录dir、文件file等压缩到tar包
tar -xf dir.tar.gz              #解压</code></pre><h3 id="screen命令"><a href="#screen命令" class="headerlink" title="screen命令"></a>screen命令</h3><blockquote>
<p>screen命令组最大的好处就是当你的shell退出或关闭后，你运行的服务不会关系，也就是说，我们可以在screen里开启一组服务，且不受终端断开的影响。</p>
</blockquote>
<pre><code>screen -S test          #创建一个名字为test的screen
screen -r test          #打开名字为test的screen
screen -r pid           #打开进程号为pid的screen
screen -ls              #列出所有的screen
ctrl + a,d              #当在一个screen时，退出screen
ctrl + a,n              #当在一个screen时，切换到下一个窗口
ctrl + a,c              #当在一个screen时，创建一个新的窗口</code></pre><h3 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h3><pre><code>scp local_file remote_username@remote_ip:remote_dir    #拷贝本地文件到远程机器上
scp -r local_dir remote_username@remote_ip:remote_dir  #拷贝本地整个目录到远程机器上</code></pre><h3 id="软件包安装管理命令"><a href="#软件包安装管理命令" class="headerlink" title="软件包安装管理命令"></a>软件包安装管理命令</h3><p>假设你想要安装的软件包叫做app，注意，这里的命令通常需要sudo或者root权限。</p>
<pre><code>//centos系统、redhat系统
rpm -qa | grep app      #查找本机是否安装了app；
rpm -ivh app.rpm        #假设你有app的rpm包，这样直接安装
sudo yum install app    #否则就在线安装
yum update app          #更新app
rpm -e app              #删除已安装的app包
//suse、opensuse系统
zypper search app       #查找本机是否安装了app；
zypper install app      #安装
zypper update app       #更新
zypper remove app       #删除
zypper lr               #列出所有已定义的安装源。
zypper    ar            #添加新安装源。
zypper    rr            #删除指定的安装源
zypper    mr            #修改指定的安装源
//ubuntu系统
apt-get install app     #安装
apt-get update app      #更新
apt-get remove app      #删除    
apt-cache search app    #搜索软件包
dpkg -i app.deb         #假设你有app的deb包，这样直接安装</code></pre><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7.5 安装 thefuck -- 小米实战</title>
    <url>/2018/11/12/Linux/centos7.5%20%E5%AE%89%E8%A3%85thefuck/</url>
    <content><![CDATA[<ol>
<li><p>安装前置依赖</p>
<pre><code> yum -y groupinstall "Development tools"
 yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel</code></pre></li>
<li><p>确保原系统命令可以用</p>
<pre><code> vi /usr/bin/yum
 把#! /usr/bin/python修改为#! /usr/bin/python2
 同理 vi /usr/libexec/urlgrabber-ext-down 文件里面的#! /usr/bin/python 也要修改为#! /usr/bin/python2</code></pre></li>
<li><p>下载和安装</p>
<pre><code> wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz  //下载地址可以在官网找到
 tar -xvf  Python-3.6.2.tar.xz  //解压
 ./configure prefix=/usr/local/python3 // 配置安装路径
 make &amp;&amp; make install // 编译和安装</code></pre></li>
<li><p>建立软链方便使用</p>
<pre class=" language-bash"><code class="language-bash"> <span class="token function">ln</span> -s /usr/local/python3/bin/thefuck /usr/bin/thefuck
 <span class="token function">ln</span> -s /usr/local/python3/bin/fuck /usr/bin/fuck
 <span class="token function">ln</span> -s /usr/local/python3/bin/pip pip3
 <span class="token function">ln</span> -s /usr/local/python3/bin/python3.7 /usr/bin/python3.7
 <span class="token function">ln</span> -s /usr/bin/python3.6 /usr/bin/python3</code></pre>
</li>
<li><p>添加到系统的软件版本控制器</p>
<pre class=" language-bash"><code class="language-bash"> update-alternatives --install /usr/bin/pip pip /usr/bin/pip2 1  //添加PIP2
 update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 2  //添加PIP3
 update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1   //添加python2
 update-alternatives --install /usr/bin/python python /usr/bin/python3.7 2   //添加python3

 update-alternatives --list  //查看清单
 update-alternatives --config python  //手动配置python pip同理
 update-alternatives --auto python  //自动配置python pip同理</code></pre>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>centos</tag>
        <tag>thefuck</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux好用的命令 -- 小米个人偏好</title>
    <url>/2018/03/21/Linux/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<ul>
<li><p>Httpie</p>
<blockquote>
<p>http 接口测试工具 </p>
</blockquote>
</li>
<li><p>fuck</p>
<blockquote>
<p>神器级别的命令</p>
</blockquote>
</li>
<li><p>ag</p>
<blockquote>
<p>全文搜索命令行</p>
</blockquote>
</li>
<li><p>mycli</p>
<blockquote>
<p>MYSQL命令，带智能提示</p>
</blockquote>
</li>
<li><p>htop</p>
<blockquote>
<p>更强大的top</p>
</blockquote>
</li>
<li><p>axel</p>
<blockquote>
<p>多线程下载器</p>
</blockquote>
</li>
<li><p>you-get</p>
<blockquote>
<p>视频下载工具</p>
</blockquote>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件权限管理剖析</title>
    <url>/2018/03/21/Linux/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>在 Linux 系统中，为了保证文件的安全，对文件所有者、同组用户、其他用户的访问权限进行了分别管理。其中，文件所有者，即建立文件或目录的用户。同组用户，是所属组群中的所有用户。其他用户，指的是既不是文件所有者，也不是同组用户的其他用户。<br><img src="http://7xivgs.com1.z0.glb.clouddn.com/Linux%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""><br>此外，每个文件和目录都具有读取权限、写入权限和执行权限，这三个权限之间相互独立。<br>！<a href="http://7xivgs.com1.z0.glb.clouddn.com/Linux%20%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%8F%82%E7%85%A7%E8%A1%A8.PNG" target="_blank" rel="noopener"></a></p>
<h1 id="功能模式"><a href="#功能模式" class="headerlink" title="功能模式"></a>功能模式</h1><p>在Linux 系统中，每个文件的访问权限可以用 9 个字母表示，每 3 个字母表示一类用户权限，分别代表文件创建者、同组用户、其他用户。其中，r 表示读取权限，w 表示写入权限，x 表示执行权限。<br><img src="http://7xivgs.com1.z0.glb.clouddn.com/Linux%E7%94%A8%E6%88%B7%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p>
<p>通过功能模式修改文件权限，有三个部分组成，包括对象、操作和权限。</p>
<p><img src="http://7xivgs.com1.z0.glb.clouddn.com/%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%BC%8F%E5%8F%82%E7%85%A7%E8%A1%A8.PNG" alt=""></p>
<p>假设需要增加同组用户写入权限，下面来看一个例子。</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">chmod</span> g+w /root/install.log </code></pre>
<h1 id="数字模式"><a href="#数字模式" class="headerlink" title="数字模式"></a>数字模式</h1><p>每一类用户的访问也可以通过数字的方式进行表示。</p>
<p><img src="http://7xivgs.com1.z0.glb.clouddn.com/%E6%95%B0%E5%AD%97%E6%A8%A1%E5%BC%8F%E5%8F%82%E7%85%A7%E8%A1%A8.PNG" alt=""></p>
<p>那么，通过数字模式就可以对常见的 Linux 文件权限操作进行归纳。</p>
<p><img src="http://7xivgs.com1.z0.glb.clouddn.com/%E5%B8%B8%E7%94%A8%E7%9A%84Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.PNG" alt=""></p>
<p>假设需要设置创建者可读可写可执行、同组用户可读、其他用户可读，下面来看一个例子。</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">chmod</span> 755 /root/install.log </code></pre>
<p>注意的是，只有文件创建者和超级用户才可以修改文件权限。s</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>npm私有仓库搭建</title>
    <url>/2018/07/13/npm/%E5%88%9B%E5%BB%BAnpm%E7%A7%81%E4%BB%93/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Node.js开发本地项目，有时不同项目之间存在依赖，如果不想把项目发布到npm社区的仓库，则需要有自己本地的仓库。<br>有些公司采用的是内网开发，很多npm资源无法从内网去下载。<br>sinopia（主流）<br>使用文件系统作为存储，仅保存用户需要的包，如果本地仓库没有对应的包，则从指定的registry下载，默认为npmjs.org，可以改成淘宝的镜像。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Sinopia的安装比较简单，只需使用npm一条安装命令即可：</p>
<p><code>npm install -g sinopia</code> 或者 <code>yarn global add sinopia</code> </p>
<p>安装环境<br>1.python2.7<br>2.不支持fs-ext和crypt3</p>
<p>使用<br>启动： sinopia</p>
<p>你也可以打开 地址看一下<a href="http://localhost:4873/" target="_blank" rel="noopener">http://localhost:4873/</a></p>
<p>就说明成功了</p>
<p>换npm 源</p>
<pre><code>npm config set registry http://xxx.xx.xx.xx:4873/   </code></pre><p>//xxx.xx.xx.xx 为自己的ip<br>建议使用用 nrm</p>
<pre><code>npm install -g nrm # 安装nrm
nrm add name http://XXXXXX:4873 # 添加本地的npm镜像地址
nrm use name # 使用本址的镜像地址     name为你要增加的地址</code></pre><p>新建用户</p>
<pre><code>npm adduser
Username: test
Password: test
Email: (this IS public) xxx@xxxx</code></pre><p>然后就可以发布包了</p>
<pre><code>npm publish     // 在自己要发布的包 路径打这个命令</code></pre><p>这边发布的包可以 是自己写的一些资源 或者是其他的 但是要根据npm 包的规范</p>
<p>本人配置文件</p>
<pre><code>#
# This is the default config file. It allows all users to do anything,
# so don't use it on production systems.
#
# Look here for more config file examples:
# https://github.com/rlidwka/sinopia/tree/master/conf
#

# path to a directory with all packages
storage: ./storage    # npm包存放的路径

auth:
  htpasswd:
    file: ./htpasswd
    # Maximum amount of users allowed to register, defaults to "+inf".
    # You can set this to -1 to disable registration.
    # max_users: 1000
    max_users: 1000     # 默认为1000，改为-1，禁止注册

# a list of other known repositories we can talk to
uplinks:
  npmjs:
    url: http://registry.npm.taobao.org/  # 默认为npm的官网，由于国情，修改 url 让sinopia使用 淘宝的npm镜像地址

packages:
  '@*/*':
    # scoped packages
    access: $all
    publish: $authenticated

  '*':
    # allow all users (including non-authenticated users) to read and
    # publish all packages
    #
    # you can specify usernames/groupnames (depending on your auth plugin)
    # and three keywords: "$all", "$anonymous", "$authenticated"
    access: $all

    # allow all known users to publish packages
    # (anyone can register by default, remember?)
    publish: $authenticated

    # if package is not available locally, proxy requests to 'npmjs' registry
    # proxy: npmjs   #这个去掉的话,sinopia 将不去下载依赖包   如果只是要放自己资源仓库的话就去掉      
    # 

# log settings
logs:
  - {type: stdout, format: pretty, level: http}
  #- {type: file, path: sinopia.log, level: info}

# you can specify listen address (or simply a port) 
listen: 0.0.0.0:4873  # 默认没有，只能在本机访问，添加后可以通过外网访问。</code></pre><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 上手指南</title>
    <url>/2018/02/02/soft/hexo/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<ul>
<li><p>超快速度</p>
<blockquote>
<p>Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</p>
</blockquote>
</li>
<li><p>支持 Markdown</p>
<blockquote>
<p>Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p>
</blockquote>
</li>
<li><p>一键部署</p>
<blockquote>
<p>只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。</p>
</blockquote>
</li>
<li><p>丰富的插件</p>
<blockquote>
<p>Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</p>
</blockquote>
<h1 id="安装-amp-运行"><a href="#安装-amp-运行" class="headerlink" title="安装&amp;运行"></a>安装&amp;运行</h1></li>
</ul>
<h2 id="安装-amp-运行-1"><a href="#安装-amp-运行-1" class="headerlink" title="安装&amp;运行"></a>安装&amp;运行</h2><p>依次运行以下代码，其中 <code>&lt;folder&gt;</code> 为项目文件夹名称</p>
<pre><code>npm install hexo-cli -g         # 安装命令行
hexo init &lt;folder&gt;              # 初始化目录结构
cd &lt;folder&gt;                     # 进入项目
npm i                           # 安装依赖
hexo server                     # 启动服务</code></pre><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>新建完成后，指定文件夹的目录如下：</p>
<pre><code>.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes</code></pre><h2 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h2><p>网站的 配置 信息，您可以在此配置大部分的参数。</p>
<h2 id="source"><a href="#source" class="headerlink" title="source"></a>source</h2><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p>
<h2 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h2><p>主题 文件夹。Hexo 会根据主题来生成静态页面。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>网站标题</td>
<td></td>
</tr>
<tr>
<td>subtitle</td>
<td>网站副标题</td>
<td></td>
</tr>
<tr>
<td>description</td>
<td>网站描述</td>
<td></td>
</tr>
<tr>
<td>author</td>
<td>您的名字</td>
<td></td>
</tr>
<tr>
<td>language</td>
<td>网站使用的语言</td>
<td></td>
</tr>
<tr>
<td>timezone</td>
<td>网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</td>
<td></td>
</tr>
<tr>
<td>url</td>
<td>网址</td>
<td></td>
</tr>
<tr>
<td>root</td>
<td>网站根目录</td>
<td></td>
</tr>
<tr>
<td>permalink</td>
<td>文章的 永久链接 格式</td>
<td>:year/:month/:day/:title/</td>
</tr>
<tr>
<td>permalink_defaults</td>
<td>永久链接中各部分的默认值</td>
<td></td>
</tr>
<tr>
<td>source_dir</td>
<td>资源文件夹，这个文件夹用来存放内容。</td>
<td>source</td>
</tr>
<tr>
<td>public_dir</td>
<td>公共文件夹，这个文件夹用于存放生成的站点文件。</td>
<td>public</td>
</tr>
<tr>
<td>tag_dir</td>
<td>标签文件夹</td>
<td>tags</td>
</tr>
<tr>
<td>archive_dir</td>
<td>归档文件夹</td>
<td>archives</td>
</tr>
<tr>
<td>category_dir</td>
<td>分类文件夹</td>
<td>categories</td>
</tr>
<tr>
<td>code_dir</td>
<td>Include code 文件夹</td>
<td>downloads/code</td>
</tr>
<tr>
<td>i18n_dir</td>
<td>国际化（i18n）文件夹</td>
<td>:lang</td>
</tr>
<tr>
<td>skip_render</td>
<td>跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</td>
<td></td>
</tr>
<tr>
<td>new_post_name</td>
<td>新文章的文件名称</td>
<td>:title.md</td>
</tr>
<tr>
<td>default_layout</td>
<td>预设布局</td>
<td>post</td>
</tr>
<tr>
<td>auto_spacing</td>
<td>在中文和英文之间加入空格</td>
<td>false</td>
</tr>
<tr>
<td>titlecase</td>
<td>把标题转换为 title case</td>
<td>false</td>
</tr>
<tr>
<td>external_link</td>
<td>在新标签中打开链接</td>
<td>true</td>
</tr>
<tr>
<td>filename_case</td>
<td>把文件名称转换为 (1) 小写或 (2) 大写</td>
<td>0</td>
</tr>
<tr>
<td>render_drafts</td>
<td>显示草稿</td>
<td>false</td>
</tr>
<tr>
<td>post_asset_folder</td>
<td>启动 Asset 文件夹</td>
<td>false</td>
</tr>
<tr>
<td>relative_link</td>
<td>把链接改为与根目录的相对位址</td>
<td>false</td>
</tr>
<tr>
<td>future</td>
<td>显示未来的文章</td>
<td>true</td>
</tr>
<tr>
<td>highlight</td>
<td>代码块的设置</td>
<td></td>
</tr>
<tr>
<td>default_category</td>
<td>默认分类</td>
<td>uncategorized</td>
</tr>
<tr>
<td>category_map</td>
<td>分类别名</td>
<td></td>
</tr>
<tr>
<td>tag_map</td>
<td>标签别名</td>
<td></td>
</tr>
<tr>
<td>date_format</td>
<td>日期格式</td>
<td>YYYY-MM-DD</td>
</tr>
<tr>
<td>time_format</td>
<td>时间格式</td>
<td>H:mm:ss</td>
</tr>
<tr>
<td>per_page</td>
<td>每页显示的文章量 (0 = 关闭分页功能)</td>
<td>10</td>
</tr>
<tr>
<td>pagination_dir</td>
<td>分页目录</td>
<td>page</td>
</tr>
<tr>
<td>theme</td>
<td>当前主题名称。值为false时禁用主题</td>
<td></td>
</tr>
<tr>
<td>deploy</td>
<td>部署部分的设置</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">时区列表</a> 。</li>
<li>如果您的网站存放在子目录中，例如 <a href="http://yoursite.com/blog，则请将您的" target="_blank" rel="noopener">http://yoursite.com/blog，则请将您的</a> url 设为 <a href="http://yoursite.com/blog" target="_blank" rel="noopener">http://yoursite.com/blog</a> 并把 root 设为 /blog/。</li>
<li>Hexo 使用 <a href="http://momentjs.com/" target="_blank" rel="noopener">Moment.js</a> 来解析和显示时间。</li>
</ul>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p>
<pre><code>hexo deploy</code></pre><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>soft</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome 插件推荐 -- 小米推荐</title>
    <url>/2018/09/20/%E6%94%B6%E9%9B%86/Chrome%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90--%E5%B0%8F%E7%B1%B3%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>闲话不多说，直接上推荐的插件，可以翻墙的直接点击标题跳转谷歌商店下载，不信的我下面也给出离线安装文件</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180405120713.png" alt="我的插件"></p>
<h1 id="通用类插件"><a href="#通用类插件" class="headerlink" title="通用类插件"></a>通用类插件</h1><ol>
<li><p>历史记录管理 – Better History</p>
<p> 官方介绍：更好地查看您的历史记录。为查看您的历史记录带来最好的搜索体验，最清晰的界面和最有帮助的筛选。</p>
<p> 小米点评：个人觉得Chrome自带的历史管理工具很难用，界面虽然好看但是很不好管理，所以推荐这个大家使用。</p>
<p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405121159.png" alt=""></p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/better-history/obciceimmggglbmelaidpjlmodcebijb" target="_blank" rel="noopener">官方地址</a></li>
</ul>
</li>
<li><p>下载管理器 – Chrono下载管理器</p>
<p> 官方介绍：做Chrome浏览器中最好的下载管理器</p>
<p> 小米点评：我用了很久的一个插件，可以分类显示下载的内容，还可以嗅探出当前页面的资源，并可以批量下载网页的内容（图片和视频）</p>
<p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405121856.png" alt="弹出框"></p>
<p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405121957.png" alt="全屏页面"></p>
<p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405122043.png" alt="当前页面的资源"></p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/mciiogijehkdemklbdcbfkefimifhecn" target="_blank" rel="noopener">官方地址</a></li>
</ul>
</li>
<li><p>新标签页 – oscnews</p>
<p> 官方介绍：查看开源中国软件更新资讯，内置文档导航，GitHub 趋势榜，linux命令索引，浏览历史记录和时钟页面。</p>
<p> 小米点评：我目前在用的新标签页插件。可能不适用大家，不关注开发的可以尝试另一个Infinity。</p>
<p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405124044.png" alt=""></p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/mciiogijehkdemklbdcbfkefimifhecn" target="_blank" rel="noopener">官方地址</a></li>
</ul>
</li>
<li><p>新标签页 – Infinity</p>
<p> 官方介绍：Infinity新标签页，基于Chrome的云应用服务，让你更优雅、轻松地使用Chrome。</p>
<p> 小米点评：功能很丰富，具有导航，天前，TODO，壁纸，界面还不错。</p>
<p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405123724.png" alt=""></p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg" target="_blank" rel="noopener">官方地址</a></li>
<li></li>
</ul>
</li>
<li><p>目录 – Smart TOC</p>
<p> 官方介绍：Add a table of contents for web article or documentation</p>
<p> 小米点评：不是所有的网站都有一个悬浮的目录，这个插件可以生成一个悬浮的目录在页面上，比如Spring的官方文档的目录，长篇大幅的文章，目前在最顶上，阅读很不方便，这个插件的作用就尤为突出。</p>
<p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405124622.png" alt=""></p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/lifgeihcfpkmmlfjbailfpfhbahhibba" target="_blank" rel="noopener">官方地址</a></li>
</ul>
</li>
<li><p>油猴子 – Tampermonkey</p>
<p> 官方介绍：The world’s most popular userscript manager</p>
<p> 小米点评：插件中的神器，可以安装各种脚本，比如百度云Ex等，谁用谁知道。</p>
<p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405124828.png" alt=""></p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">官方地址</a></li>
</ul>
</li>
<li><p>广告过滤 – uBlock Origin</p>
<p> 官方介绍：一款高效的网络请求过滤工具，占用极低的内存和 CPU。</p>
<p> 小米点评：广告过滤妥妥的。</p>
<p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405124944.png" alt=""></p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm" target="_blank" rel="noopener">官方地址</a></li>
</ul>
</li>
<li><p>阅读 – 简悦 - SimpRead</p>
<p> 官方介绍：让你瞬间进入沉浸式阅读的 Chrome 扩展，类似 Safari 的阅读模式。</p>
<p> 小米点评：给你高效的阅读体验。</p>
<p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405125638.png" alt="开启前"></p>
<p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405125617.png" alt="开启后"></p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/simpread-reader-view/ijllcpnolfcooahcekpamkbidhejabll" target="_blank" rel="noopener">官方地址</a></li>
</ul>
</li>
</ol>
<h1 id="开发类插件"><a href="#开发类插件" class="headerlink" title="开发类插件"></a>开发类插件</h1><ol>
<li><p>CSS调试器 – Code Cola</p>
<p> 官方介绍：Code Cola 是一个可视化编辑在线页面 css 样式的 chrome 插件。</p>
<p> 小米点评：很直观调试样式，先选择页面元素后，可以在弹出框中修改样式 ，之后便可以导出 CSS 。</p>
<p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405122647.png" alt="样式修改死的截图"></p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/code-cola/lomkpheldlbkkfiifcbfifipaofnmnkn" target="_blank" rel="noopener">官方地址</a></li>
</ul>
</li>
<li><p>JSON查看器 – JSON-handle</p>
<p>官方介绍：It’s a browser and editor for JSON document.You can get a beautiful view</p>
<p>小米点评：打开页面后可以很方便的查看JSON的层次结构和数据类型和值。在值为Base64图片和图片Url的时候悬停可以直接预览图片。</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180405123112.png" alt=""></p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj" target="_blank" rel="noopener">官方地址</a></li>
</ul>
</li>
<li><p>DIV查看 – Outliner</p>
<p> 官方介绍：This extension outlines all the DOM elements on a page</p>
<p> 小米点评：给每一个Div加上边框，可以很方便的查看Div的位置</p>
<p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405124247.png" alt=""></p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/outliner/hmdacajmldpieoadpgloddgkeamdhoka" target="_blank" rel="noopener">官方地址</a></li>
</ul>
</li>
</ol>
<h1 id="网站加强"><a href="#网站加强" class="headerlink" title="网站加强"></a>网站加强</h1><ol>
<li><p>GitHub – Insight.io for Github</p>
<p> 官方介绍：IDE like code intelligence and code search for GitHub by Insight.io.</p>
<p> 小米点评：可以在GitHub的左侧查看当前项目的目录结构，也可以单文件下载，还可以全局搜索。GitHub党必备。</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/insightio-for-github/pmhfgjjhhomfplgmbalncpcohgeijonh" target="_blank" rel="noopener">官方地址</a></li>
</ul>
</li>
<li><p>百度云 – 云盘万能钥匙</p>
<p> 官方介绍：你的云盘智能助手</p>
<p> 小米点评：在你打开网盘分享的链接的时候，可以自动充填提取密码。基于和WiFi万能钥匙一样的原理，属于记录各个分享链接的密码在充填密码，在装有该插件的人中你若是第一个打开，还是得要自己来填写。</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/anlllmnpjodopgbkbpnghnjlelnogfjc" target="_blank" rel="noopener">官方地址</a></li>
</ul>
</li>
<li><p>新浪微博 – 眼不见心不烦（新浪微博）</p>
<p> 官方介绍：新浪微博（weibo.com）非官方功能增强插件，可以无限制地屏蔽关键词、用户、来源，去除页面广告和推广微博，反刷屏，还您一个清爽干净的微博！</p>
<p> 小米点评：还你干净的微博浏览体验。</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/aognaapdfnnldnjglanfbbklaakbpejm" target="_blank" rel="noopener">官方地址</a></li>
</ul>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>soft</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql 参数说明-- 小米规整</title>
    <url>/2018/03/03/%E6%94%B6%E9%9B%86/MySQL/</url>
    <content><![CDATA[<h1 id="my-ini"><a href="#my-ini" class="headerlink" title="my.ini"></a>my.ini</h1><blockquote>
<p>my.ini是MySQL数据库中使用的配置文件，修改这个文件可以达到更新配置的目的。</p>
</blockquote>
<blockquote>
<p>注意：每次修改参数后，必须重新启动MySQL服务才会有效。</p>
</blockquote>
<h2 id="客户端参数"><a href="#客户端参数" class="headerlink" title="客户端参数"></a>客户端参数</h2><pre class=" language-ini"><code class="language-ini">
<span class="token selector">[client]</span>

# MySQL数据库的端口，默认的端口是3306
<span class="token constant">port</span><span class="token attr-value"><span class="token punctuation">=</span>3306</span>

<span class="token selector">[mysql]</span>

# 客户端默认的字符集，如果你希望它支持中文，可以设置成gbk或者utf8。
<span class="token constant">default-character-set</span><span class="token attr-value"><span class="token punctuation">=</span>gb2312</span></code></pre>
<h2 id="服务端参数"><a href="#服务端参数" class="headerlink" title="服务端参数"></a>服务端参数</h2><pre class=" language-ini"><code class="language-ini"><span class="token selector">[mysqld]</span>

# MySQL数据库的端口，默认的端口是3306
<span class="token constant">port</span><span class="token attr-value"><span class="token punctuation">=</span>3306</span>


#MySQL的安装路径
<span class="token constant">basedir</span><span class="token attr-value"><span class="token punctuation">=</span>"E:/Java/Mysql/"</span>

#MySQL数据文件的存储位置，也是数据库表的存放位置。
<span class="token constant">datadir</span><span class="token attr-value"><span class="token punctuation">=</span>"C:/ProgramData/MySQL/MySQL Server 5.5/Data/"</span>

# 默认的字符集，这个字符集是服务器端的。
<span class="token constant">character-set-server</span><span class="token attr-value"><span class="token punctuation">=</span>gb2312</span>

# 默认的存储引擎。
<span class="token constant">default-storage-engine</span><span class="token attr-value"><span class="token punctuation">=</span>INNODB</span>

# SQL模式的参数，通过这个参数可以设置检验SQL语句的严格程度。
<span class="token constant">sql-mode</span><span class="token attr-value"><span class="token punctuation">=</span>"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION"</span>

# 允许同时访问MySQL服务器的最大连接数，其中一个连接是保留的，留给管理员专用的。
<span class="token constant">max_connections</span><span class="token attr-value"><span class="token punctuation">=</span>100</span>

# 查询时的缓存大小，缓存中可以存储以前通过select语句查询过的信息，再次查询时就可以直接从缓存中拿出信息。
<span class="token constant">query_cache_size</span><span class="token attr-value"><span class="token punctuation">=</span>0</span>

# 所有进程打开表的总数。
<span class="token constant">table_cache</span><span class="token attr-value"><span class="token punctuation">=</span>256</span>

# 表示内存中临时表的总数。
<span class="token constant">tmp_table_size</span><span class="token attr-value"><span class="token punctuation">=</span>35M</span>


# 表示保留客户端线程的缓存。
<span class="token constant">thread_cache_size</span><span class="token attr-value"><span class="token punctuation">=</span>8</span>


# MySQL重建索引时所允许的最大临时文件的大小。
<span class="token constant">myisam_max_sort_file_size</span><span class="token attr-value"><span class="token punctuation">=</span>100G</span>

# 重建索引时的缓存大小。
<span class="token constant">myisam_sort_buffer_size</span><span class="token attr-value"><span class="token punctuation">=</span>69M</span>

# 关键词的缓存大小。
<span class="token constant">key_buffer_size</span><span class="token attr-value"><span class="token punctuation">=</span>55M</span>

# MyISAM表全表扫描的缓存大小。
<span class="token constant">read_buffer_size</span><span class="token attr-value"><span class="token punctuation">=</span>64K</span>

# 将排序好的数据存入该缓存中。
<span class="token constant">read_rnd_buffer_size</span><span class="token attr-value"><span class="token punctuation">=</span>256K</span>

# 用于排序的缓存大小
<span class="token constant">sort_buffer_size</span><span class="token attr-value"><span class="token punctuation">=</span>256K</span></code></pre>
<h2 id="InnoDB存储引擎使用的参数"><a href="#InnoDB存储引擎使用的参数" class="headerlink" title="InnoDB存储引擎使用的参数"></a>InnoDB存储引擎使用的参数</h2><pre class=" language-ini"><code class="language-ini">
# 附加的内存池，用来存储InnoDB表的内容。
<span class="token constant">innodb_additional_mem_pool_size</span><span class="token attr-value"><span class="token punctuation">=</span>3M</span>

# 设置提交日志的时机，若设置为1，InnoDB会在每次提交后将事务日志写到磁盘上。
<span class="token constant">innodb_flush_log_at_trx_commit</span><span class="token attr-value"><span class="token punctuation">=</span>1</span>

# 用来存储日志数据的缓存区的大小。
<span class="token constant">innodb_log_buffer_size</span><span class="token attr-value"><span class="token punctuation">=</span>2M</span>

# 缓存的大小，InnoDB使用一个缓冲池类保存索引和原始数据。
<span class="token constant">innodb_buffer_pool_size</span><span class="token attr-value"><span class="token punctuation">=</span>107M</span>

# 日志文件的大小。
<span class="token constant">innodb_log_file_size</span><span class="token attr-value"><span class="token punctuation">=</span>54M</span>

# InnoDB存储引擎允许的线程最大数。
<span class="token constant">innodb_thread_concurrency</span><span class="token attr-value"><span class="token punctuation">=</span>18</span></code></pre>
<h1 id="jdbc-Url"><a href="#jdbc-Url" class="headerlink" title="jdbc Url"></a>jdbc Url</h1><p>mysql JDBC URL格式如下： </p>
<p>jdbc:mysql://[host:port],[host:port]…/[database][?参数名1][=参数值1][&amp;参数名2][=参数值2]… </p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数说明</th>
<th>缺省值</th>
<th>最低版本要求</th>
</tr>
</thead>
<tbody><tr>
<td>user</td>
<td>数据库用户名（用于连接数据库）</td>
<td></td>
<td>所有版本</td>
</tr>
<tr>
<td>passWord</td>
<td>用户密码（用于连接数据库）</td>
<td></td>
<td>所有版本</td>
</tr>
<tr>
<td>useUnicode</td>
<td>是否使用Unicode字符集，如果参数characterEncoding设置为gb2312或gbk，本参数值必须设置为true</td>
<td>false</td>
<td>1.1g</td>
</tr>
<tr>
<td>characterEncoding</td>
<td>当useUnicode设置为true时，指定字符编码。比如可设置为gb2312或gbk</td>
<td>false</td>
<td>1.1g</td>
</tr>
<tr>
<td>autoReconnect</td>
<td>当数据库连接异常中断时，是否自动重新连接？</td>
<td>false</td>
<td>1.1</td>
</tr>
<tr>
<td>autoReconnectForPools</td>
<td>是否使用针对数据库连接池的重连策略</td>
<td>false</td>
<td>3.1.3</td>
</tr>
<tr>
<td>failOverReadOnly</td>
<td>自动重连成功后，连接是否设置为只读？</td>
<td>true</td>
<td>3.0.12</td>
</tr>
<tr>
<td>maxReconnects</td>
<td>autoReconnect设置为true时，重试连接的次数</td>
<td>3</td>
<td>1.1</td>
</tr>
<tr>
<td>initialTimeout</td>
<td>autoReconnect设置为true时，两次重连之间的时间间隔，单位：秒</td>
<td>2</td>
<td>1.1</td>
</tr>
<tr>
<td>connectTimeout</td>
<td>和数据库服务器建立socket连接时的超时，单位：毫秒。 0表示永不超时，适用于JDK 1.4及更高版本</td>
<td>0</td>
<td>3.0.1</td>
</tr>
<tr>
<td>socketTimeout</td>
<td>socket操作（读写）超时，单位：毫秒。 0表示永不超时</td>
<td>0</td>
<td>3.0.1</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 软件推荐 -- 小米推荐</title>
    <url>/2018/06/05/%E6%94%B6%E9%9B%86/Windows%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90--%E5%B0%8F%E7%B1%B3%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>闲话不多说，直接上推荐的软件</p>
<h1 id="通用类插件"><a href="#通用类插件" class="headerlink" title="通用类插件"></a>通用类插件</h1><ol>
<li><p>历史记录管理 – Better History</p>
<p> 官方介绍：更好地查看您的历史记录。为查看您的历史记录带来最好的搜索体验，最清晰的界面和最有帮助的筛选。</p>
<p> 小米点评：个人觉得Chrome自带的历史管理工具很难用，界面虽然好看但是很不好管理，所以推荐这个大家使用。</p>
<p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405121159.png" alt=""></p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/better-history/obciceimmggglbmelaidpjlmodcebijb" target="_blank" rel="noopener">官方地址</a></li>
</ul>
</li>
</ol>
<h1 id="开发推荐软件"><a href="#开发推荐软件" class="headerlink" title="开发推荐软件"></a>开发推荐软件</h1><h2 id="VScode"><a href="#VScode" class="headerlink" title="VScode"></a>VScode</h2><ul>
<li><p>官方介绍：免费。 开源。到处运行。</p>
</li>
<li><p>小米点评：好用，方便，速度快。</p>
</li>
<li><p><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">官方地址</a></p>
</li>
</ul>
<h2 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h2><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h2 id="choco"><a href="#choco" class="headerlink" title="choco"></a>choco</h2><h1 id="日常推荐软件"><a href="#日常推荐软件" class="headerlink" title="日常推荐软件"></a>日常推荐软件</h1><h2 id="下载软件-–-猎鹰"><a href="#下载软件-–-猎鹰" class="headerlink" title="下载软件 – 猎鹰"></a>下载软件 – 猎鹰</h2><ul>
<li><p>官方介绍：Easy your downloads,Get everthing done!</p>
</li>
<li><p>小米点评：好用，不限速，界面不丑。</p>
</li>
<li><p><a href="http://www.eagleget.com/" target="_blank" rel="noopener">官方地址</a></p>
</li>
</ul>
<h2 id="Opera浏览器"><a href="#Opera浏览器" class="headerlink" title="Opera浏览器"></a>Opera浏览器</h2><ul>
<li><p>官方介绍：Easy your downloads,Get everthing done!</p>
</li>
<li><p>小米点评：我推荐这货，只因为一个原因，这货自带**。</p>
</li>
<li><p><a href="http://www.eagleget.com/" target="_blank" rel="noopener">官方地址</a></p>
</li>
</ul>
<h2 id="listary"><a href="#listary" class="headerlink" title="listary"></a>listary</h2><ul>
<li><p>官方介绍：Easy your downloads,Get everthing done!</p>
</li>
<li><p>小米点评：强大的搜索和集成功能，提供类似Mac的快捷条的功能十分好用。</p>
</li>
<li><p><a href="http://www.eagleget.com/" target="_blank" rel="noopener">官方地址</a></p>
</li>
<li><h2 id="everything"><a href="#everything" class="headerlink" title="everything"></a>everything</h2></li>
</ul>
<h2 id="yomail"><a href="#yomail" class="headerlink" title="yomail"></a>yomail</h2><h2 id="有道云笔记"><a href="#有道云笔记" class="headerlink" title="有道云笔记"></a>有道云笔记</h2><h2 id="下载软件-–-猎鹰-1"><a href="#下载软件-–-猎鹰-1" class="headerlink" title="下载软件 – 猎鹰"></a>下载软件 – 猎鹰</h2><h1 id="暂未归类软件"><a href="#暂未归类软件" class="headerlink" title="暂未归类软件"></a>暂未归类软件</h1><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><h2 id="justmd"><a href="#justmd" class="headerlink" title="justmd"></a>justmd</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>soft</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常见问题处理锦囊 -- 小米推荐</title>
    <url>/2018/09/25/%E6%94%B6%E9%9B%86/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86--%E5%B0%8F%E7%B1%B3/</url>
    <content><![CDATA[<h1 id="git如何忽略已经提交的文件-gitignore文件无效"><a href="#git如何忽略已经提交的文件-gitignore文件无效" class="headerlink" title="git如何忽略已经提交的文件 (.gitignore文件无效)"></a>git如何忽略已经提交的文件 (.gitignore文件无效)</h1><p>一. 问题</p>
<p>在初始化git仓库的时候没有创建.gitignore文件来过滤不必要提交的文件, 后来却发现某些文件不需要提交, 但是这些文件已经被提交了, 这时候创建.gitignore文件忽略这些文件时, 发现ignore的规则对那些已经被track的文件无效.</p>
<p>其实.gitignore文件只会忽略那些没有被添加的文件, 也就是说ignore规则只对那些在规则建立之后被新创建的新文件生效. </p>
<p>二、处理</p>
<ol>
<li>删除已添加且不需要添加到版本控制器的文件</li>
<li><code>git rm -r --cached .</code>删除控制</li>
<li>添加<code>.gitignore</code>文件</li>
<li><code>git add .</code>添加文件</li>
<li><code>git commit -m " commet for commit ....."</code>提交记录</li>
<li><code>git push</code></li>
</ol>
<p>三、总结</p>
<p>创建git仓库的同时创建.gitignore文件, 并且把忽略规则写好(尽量考虑到所有应该略的文件, 这样就可以避免出现上面的文件啦)</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>soft</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>图文并茂，深入浅出 Nginx</title>
    <url>/2018/05/10/%E6%94%B6%E9%9B%86/%E5%9B%BE%E6%96%87%E5%B9%B6%E8%8C%82%EF%BC%8C%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANginx/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Nginx 是一款轻量级的 Web 服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180405001432.png" alt="架构图"></p>
<p>上图基本上说明了当下流行的技术架构，其中 Nginx 有点入口网关的味道。</p>
<a id="more"></a>
<h1 id="反向代理服务器？"><a href="#反向代理服务器？" class="headerlink" title="反向代理服务器？"></a>反向代理服务器？</h1><p>经常听人说到一些术语，如反向代理，那么什么是反向代理，什么又是正向代理呢？</p>
<p>正向代理：</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180405001549.png" alt="正向代理"></p>
<p>反向代理：</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180405001608.png" alt="反向代理"></p>
<p>由于防火墙的原因，我们并不能直接访问谷歌，那么我们可以借助 VPN 来实现，这就是一个简单的正向代理的例子。这里你能够发现，正向代理 “代理” 的是客户端，而且客户端是知道目标的，而目标是不知道客户端是通过 VPN 访问的。</p>
<p>当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即反向代理 “代理” 的是服务器端，而且这一个过程对于客户端而言是透明的。</p>
<h1 id="Nginx-的-Master-Worker-模式"><a href="#Nginx-的-Master-Worker-模式" class="headerlink" title="Nginx 的 Master-Worker 模式"></a>Nginx 的 Master-Worker 模式</h1><p><img src="http://ot0en8caw.bkt.clouddn.com/20180405001635.png" alt="nginx 进程"></p>
<p>启动 Nginx 后，其实就是在 80 端口启动了 Socket 服务进行监听，如图所示，Nginx 涉及 Master 进程和 Worker 进程。</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180405001659.png" alt="Master-Worker 模式"></p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180405001721.png" alt="nginx.conf"></p>
<h2 id="Master-进程的作用是？"><a href="#Master-进程的作用是？" class="headerlink" title="Master 进程的作用是？"></a>Master 进程的作用是？</h2><p>读取并验证配置文件 nginx.conf；管理 worker 进程；</p>
<h2 id="Worker-进程的作用是？"><a href="#Worker-进程的作用是？" class="headerlink" title="Worker 进程的作用是？"></a>Worker 进程的作用是？</h2><p>每一个 Worker 进程都维护一个线程（避免线程切换），处理连接和请求；注意 Worker 进程的个数由配置文件决定，一般和 CPU 个数相关（有利于进程切换），配置几个就有几个 Worker 进程。</p>
<h1 id="思考：Nginx-如何做到热部署？"><a href="#思考：Nginx-如何做到热部署？" class="headerlink" title="思考：Nginx 如何做到热部署？"></a>思考：Nginx 如何做到热部署？</h1><p>所谓热部署，就是配置文件 nginx.conf 修改后，不需要 stop Nginx，不需要中断请求，就能让配置文件生效！（nginx -s reload 重新加载 / nginx -t 检查配置 / nginx -s stop）</p>
<p>通过上文我们已经知道 worker 进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象：</p>
<p>方案一：</p>
<p>修改配置文件 nginx.conf 后，主进程 master 负责推送给 woker 进程更新配置信息，woker 进程收到信息后，更新进程内部的线程信息。（有点 valatile 的味道）</p>
<p>方案二：</p>
<p>修改配置文件 nginx.conf 后，重新生成新的 worker 进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的 worker 进程，至于老的 worker 进程，等把那些以前的请求处理完毕后，kill 掉即可。</p>
<p>Nginx 采用的就是方案二来达到热部署的！</p>
<h1 id="思考：Nginx-如何做到高并发下的高效处理？"><a href="#思考：Nginx-如何做到高并发下的高效处理？" class="headerlink" title="思考：Nginx 如何做到高并发下的高效处理？"></a>思考：Nginx 如何做到高并发下的高效处理？</h1><p>上文已经提及 Nginx 的 worker 进程个数与 CPU 绑定、worker 进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。</p>
<p>作为专业的程序员，我们可以开一下脑洞：BIO/NIO/AIO、异步 / 同步、阻塞 / 非阻塞…</p>
<p>要同时处理那么多的请求，要知道，有的请求需要发生 IO，可能需要很长时间，如果等着它，就会拖慢 worker 的处理速度。</p>
<p>Nginx 采用了 Linux 的 epoll 模型，epoll 模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果 OK，那么放入 epoll 队列中，这个过程是异步的。worker 只需要从 epoll 队列循环处理即可。</p>
<h1 id="思考：Nginx-挂了怎么办？"><a href="#思考：Nginx-挂了怎么办？" class="headerlink" title="思考：Nginx 挂了怎么办？"></a>思考：Nginx 挂了怎么办？</h1><p>Nginx 既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。</p>
<p>答案是：Keepalived+Nginx 实现高可用。</p>
<p>Keepalived 是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和 Nginx 配合来实现 Web 服务的高可用。</p>
<p>（其实，Keepalived 不仅仅可以和 Nginx 配合，还可以和很多其他服务配合）</p>
<h1 id="Keepalived-Nginx-实现高可用的思路："><a href="#Keepalived-Nginx-实现高可用的思路：" class="headerlink" title="Keepalived+Nginx 实现高可用的思路："></a>Keepalived+Nginx 实现高可用的思路：</h1><p>第一：请求不要直接打到 Nginx 上，应该先通过 Keepalived（这就是所谓虚拟 IP，VIP）</p>
<p>第二：Keepalived 应该能监控 Nginx 的生命状态（提供一个用户自定义的脚本，定期检查 Nginx 进程状态，进行权重变化,，从而实现 Nginx 故障切换）</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180405002123.png" alt="Keepalived+Nginx"></p>
<h1 id="我们的主战场：nginx-conf"><a href="#我们的主战场：nginx-conf" class="headerlink" title="我们的主战场：nginx.conf"></a>我们的主战场：nginx.conf</h1><p>很多时候，在开发、测试环境下，我们都得自己去配置 Nginx，就是去配置 nginx.conf。</p>
<p>nginx.conf 是典型的分段配置文件，下面我们来分析下。</p>
<h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p><img src="http://ot0en8caw.bkt.clouddn.com/20180405003223.png" alt="http 的 server 段"></p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180405003235.png" alt="访问结果"></p>
<p>其实这是把 Nginx 作为 web server 来处理静态资源。</p>
<p>第一：location 可以进行正则匹配，应该注意正则的几种形式以及优先级。（这里不展开）</p>
<p>第二：Nginx 能够提高速度的其中一个特性就是：动静分离，就是把静态资源放到 Nginx 上，由 Nginx 管理，动态请求转发给后端。</p>
<p>第三：我们可以在 Nginx 下把静态资源、日志文件归属到不同域名下（也即是目录），这样方便管理维护。</p>
<p>第四：Nginx 可以进行 IP 访问控制，有些电商平台，就可以在 Nginx 这一层，做一下处理，内置一个黑名单模块，那么就不必等请求通过 Nginx 达到后端在进行拦截，而是直接在 Nginx 这一层就处理掉。</p>
<h1 id="反向代理【proxy-pass】"><a href="#反向代理【proxy-pass】" class="headerlink" title="反向代理【proxy_pass】"></a>反向代理【proxy_pass】</h1><p>所谓反向代理，很简单，其实就是在 location 这一段配置中的 root 替换成 proxy_pass 即可。root 说明是静态资源，可以由 Nginx 进行返回；而 proxy_pass 说明是动态请求，需要进行转发，比如代理到 Tomcat 上。</p>
<p>反向代理，上面已经说了，过程是透明的，比如说 request -&gt; Nginx -&gt; Tomcat，那么对于 Tomcat 而言，请求的 IP 地址就是 Nginx 的地址，而非真实的 request 地址，这一点需要注意。不过好在 Nginx 不仅仅可以反向代理请求，还可以由用户自定义设置 HTTP HEADER。</p>
<h1 id="负载均衡【upstream】"><a href="#负载均衡【upstream】" class="headerlink" title="负载均衡【upstream】"></a>负载均衡【upstream】</h1><p>上面的反向代理中，我们通过 proxy_pass 来指定 Tomcat 的地址，很显然我们只能指定一台 Tomcat 地址，那么我们如果想指定多台来达到负载均衡呢？</p>
<p>第一，通过 upstream 来定义一组 Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx 可以监控这一组 Tomcat 的状态）等。</p>
<p>第二，将 proxy_pass 替换成 upstream 指定的值即可。</p>
<h1 id="负载均衡可能带来的问题？"><a href="#负载均衡可能带来的问题？" class="headerlink" title="负载均衡可能带来的问题？"></a>负载均衡可能带来的问题？</h1><p>负载均衡所带来的明显的问题是，一个请求，可以到 A server，也可以到 B server，这完全不受我们的控制，当然这也不是什么问题，只是我们得注意的是：用户状态的保存问题，如 Session 会话信息，不能在保存到服务器上。</p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>缓存，是 Nginx 提供的，可以加快访问速度的机制，说白了，在配置上就是一个开启，同时指定目录，让缓存可以存储到磁盘上。具体配置，大家可以参考 Nginx 官方文档，这里就不在展开了。</p>
<p>好了，到这里，Nginx 的介绍就到这里了。欢迎转发。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>在线视频下载站点推荐</title>
    <url>/2018/11/11/%E6%94%B6%E9%9B%86/%E5%9C%A8%E7%BA%BF%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E7%AB%99%E7%82%B9%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>下面介绍一些 Web 端在线视频下载站点，使用方法都一样，即你只要复制你要下载的视频地址，然后将 url 复制到这些在线站点文本框里面，即可进行下载。当然，这些在线站点只是支持大部分主流视频网站。</p>
<p>推荐一：Free Video Finder<br>站点地址：<a href="https://www.amoyshare.com/free-video-downloader/" target="_blank" rel="noopener">https://www.amoyshare.com/free-video-downloader/</a></p>
<p>官网上是说支持 1,000 + 站点视频的下载，包括主流常见的 YouTube、Facebook、Insgram 等，具体支持的站点列表感兴趣的可以看这个：<a href="https://www.amoyshare.com/sites/" target="_blank" rel="noopener">https://www.amoyshare.com/sites/</a></p>
<p>Free Video Finder支持1000多个主流网站</p>
<p>以下载 b 站上面的视频为例，随便复制一个 b 站视频地址，然后贴到文本框里面，如下：</p>
<p>复制要下载的b站视频地址到文本框</p>
<p>直接点击 Download 即可生成下载地址：</p>
<p>点击下载按钮进行下载</p>
<p>推荐二：Youtueb 视频下载器<br>站点地址：<a href="https://www.online-downloader.com/index-Chinese" target="_blank" rel="noopener">https://www.online-downloader.com/index-Chinese</a></p>
<p>官网上是说支持 200+ 站点视频下载，常见的比如 YouTube、脸书、雅虎、土豆、优酷、新浪、Dropbox 等等，具体支持的站点列表可以查看：<a href="https://www.online-downloader.com/Supported-Sites-Chinese" target="_blank" rel="noopener">https://www.online-downloader.com/Supported-Sites-Chinese</a></p>
<p>该站点有中文版面，体验还行，不过，有时候下载速度比较慢。</p>
<p>推荐三：videofk<br>站点地址：<a href="https://www.videofk.com/" target="_blank" rel="noopener">https://www.videofk.com/</a></p>
<p>这是网友开发维护的一个站点，之前在博客上留言推荐，试了下感觉还不错，支持的站点列表：</p>
<p>支持的站点列表</p>
<p>推荐四：Video Grabber<br>站点地址：<a href="https://www.videograbber.net/zh/" target="_blank" rel="noopener">https://www.videograbber.net/zh/</a></p>
<p>Video Grabber官网地址</p>
<p>支持下载优酷、爱奇艺、哔哩哔哩、搜狐等等网站的视频。</p>
<p>支持的网站列表</p>
<p>上面推荐的这些站点，并不是万能。有很多流行的视频网站，它们采用的是特殊的视频代码，只能用一些功能更加强大的视频嗅探软件探测到这类视频文件然后才可以进行下载，比如功能强大的 You-Get 。不过呢，You-Get 安装略麻烦，非技术人员安装估计很蛋疼。</p>
<p>如果你有用过其他好用的在线视频下载站点，或者功能更强大的视频嗅探软件,欢迎留言分享。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次工控系统的心得 -- 小米</title>
    <url>/2018/06/04/%E6%94%B6%E9%9B%86/%E8%AE%B0%E4%B8%80%E4%B8%AA%E5%B7%A5%E6%8E%A7%E7%9A%84%E5%BF%83%E5%BE%97--%E5%B0%8F%E7%B1%B3/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>本次过程中，出现过协议不一致的情况</p>
<h2 id="物理连线"><a href="#物理连线" class="headerlink" title="物理连线"></a>物理连线</h2><ol>
<li><p>需要确定物理线路情况，不是所有都是标准连线，如本次的称重机就是需要跳线的，需要根据厂商文档制作跳线的连接线。</p>
<h2 id="取数"><a href="#取数" class="headerlink" title="取数"></a>取数</h2><p>模拟调试数据稳定，实际情况会有以下情况</p>
</li>
<li><p>每次数据的长短不固定，所以需要暂存数据</p>
</li>
<li><p>数据不是一次发完的</p>
</li>
<li><p>有空数据的情况，所以直接以数据长度做判断有问题，需要去空后，再判断和解析</p>
</li>
<li><p>数据需要等待，数据有粘滞情况，成功解析后，需要一个冷却时间</p>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome flags -- 小米收纳整理</title>
    <url>/2019/03/12/%E6%9D%82%E8%AE%B0/chrome%20flag/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Chrome 的一些实验性功能。<br>有些功能是很不错的，比如多线程下载的，HTTP/3支持等，小米在此进行统一书写和为大家归纳。</p>
<h2 id="进入方法"><a href="#进入方法" class="headerlink" title="进入方法"></a>进入方法</h2><ol>
<li><a href="chrome://flags/">点击连接</a></li>
<li>地址栏输入 <a href="chrome://flags/">chrome://flags/</a></li>
</ol>
<h1 id="未归类的"><a href="#未归类的" class="headerlink" title="未归类的"></a>未归类的</h1><h1 id="并行下载"><a href="#并行下载" class="headerlink" title="并行下载"></a>并行下载</h1><blockquote>
<p>启用并行下载以加快下载速度。 </p>
</blockquote>
<ul>
<li>Mac，Windows，Linux，Chrome OS，Android</li>
</ul>
<p><a href="chrome://flags/#enable-quic">进入配置</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>JetBrains Plugins -- 小米收纳和整理</title>
    <url>/2020/10/21/%E6%9D%82%E8%AE%B0/JetBrains/</url>
    <content><![CDATA[<ul>
<li><code>codota</code> AI 编码辅助插件</li>
<li><code>GsonFromat4DataBinding</code> 使用JSON直接生成Java Bean</li>
<li><code>Lombok</code> 话不多说</li>
<li><code>Maven Helper</code> 快速排出Maven冲突</li>
<li><code>MyBatisCodeHelperPro</code> MyBatis个人目前感觉最好用的</li>
<li><code>Rainbow Brackets</code> 彩色括号，针对各种括号彩色标记，一眼就辨识出对应的另一个括号</li>
<li><code>String Manipulation</code> 字符串转换，大小驼峰、常量命名等转换</li>
<li><code>Translation</code> 翻译插件</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>JetBrains</category>
      </categories>
      <tags>
        <tag>JetBrains</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构详解</title>
    <url>/2018/07/07/%E6%94%B6%E9%9B%86/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Redis 数据类型分为：字符串类型、散列类型、列表类型、集合类型、有序集合类型。</p>
<p>Redis 这么火，它运行有多块？一台普通的笔记本电脑，可以在1秒钟内完成十万次的读写操作。</p>
<p>原子操作：最小的操作单位，不能继续拆分。即最小的执行单位，不会被其他命令插入。高并发下不存在竞态条件。</p>
<p>KEY 的命名：一个良好的建议是 article:1:title 来存储 ID 为 1 的文章的标题。</p>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><ol>
<li>获取key的列表：KEYS pattern 通配符有 ？*[] 和转义 \。</li>
<li>key 是否存在： EXISTS key 存在返回 1，不存在返回 0。</li>
<li>建立 key 和删除 key：SET key 和 DEL key。</li>
<li>根据 key 获取该键所存储的 redis 数据类型：TYPE key。返回是 string、list、hash、set、zset。下面会对这5种返回的 redis 数据类型逐一讲解。</li>
<li>rename oldkey newkey：对 key 重命名，如果 newkey 存在则覆盖。</li>
<li>renamenx oldkey newkey：对 key 重命名，如果 newkey 存在则不覆盖。</li>
<li>randomkey：随即返回一个 key</li>
<li>move key db-index：将 key 移动到指定的数据库中，如果 key 不存在或者已经在该数据库中，则返回 0。成功则返回 1。</li>
</ol>
<h1 id="二、Redis数据类型-Redis数据命令"><a href="#二、Redis数据类型-Redis数据命令" class="headerlink" title="二、Redis数据类型 Redis数据命令"></a>二、Redis数据类型 Redis数据命令</h1><h2 id="1、Redis数据类型一字符串类型："><a href="#1、Redis数据类型一字符串类型：" class="headerlink" title="1、Redis数据类型一字符串类型："></a>1、Redis数据类型一字符串类型：</h2><p>  这个很好理解，一个key存储一个字符串。如果你要存数据呢？转换成Json或者其他的字符串序列化。</p>
<h2 id="2、Redis数据命令一字符串类型："><a href="#2、Redis数据命令一字符串类型：" class="headerlink" title="2、Redis数据命令一字符串类型："></a>2、Redis数据命令一字符串类型：</h2><ol>
<li>赋值：SET key value。如 set hello world</li>
<li>取值：GET key。如 get hello。返回是 world</li>
<li>自增：INCR key。就是 Mysql的AUTO_INCREMENT。每次执行 INCR key时，该key的值都会+1.若key不存在，则先建立一个0，然后+1，返回 1。如果值不是整数则报错。该操作是原子操作。</li>
<li>自减：DECR key。将指定 key 的值减少 1。 如 DECR num，就是 num-1</li>
<li>自增 N：INCRBY key increment 用来给指定 key 的值加 increment。如 INCRBY num 5 就是 num+5</li>
<li>自减 N：DECRBY key increment 用来给指定 key 的值减 increment。如 DECRBY num 5 就是 num-5</li>
<li>增加浮点数：INCRBYFLOAT key increment。</li>
<li>向尾部追加：APPEND key value。如set test:key 123、append test:key 456、get test:key 就是 123456</li>
<li>获取长度：STRLEN key。</li>
<li>同时给多个 key 赋值：MSET title 这是标题 description 这是描述 content 这是内容。</li>
<li>同时获取多个 key 的值：MGET title description content</li>
<li>位操作之获取：GETBIT key offset。如字符 a 在 redis 中的存储为 01100001（ASCII为98），那么 GETBIT key 2 就是 1，GET key 0 就是 0。</li>
<li>位操作之设置：SETBIT key offset value。如字符 a 在 redis 中的存储为 01100001（ASCII为98），那么 SETBIT key 6 0，SETBIT key 5 1 那么 get key 得到的是 b。因为取出的二进制为 01100010。</li>
<li>位操作之统计：BITCOUNT key [start] [end]：BITCOUNT key 用来获取 key 的值中二进制是 1 的个数。而 BITCOUNT key start end 则是用来统计key的值中在第 start 和 end 之间的子字符串的二进制是 1 的个数（好绕啊）。</li>
<li>位操作之位运算：BITOP operation resultKey key1 key2。operation 是位运算的操作，有 AND，OR，XOR，NOT。resultKey 是把运算结构存储在这个 key 中，key1 和 key2 是参与运算的 key，参与运算的 key 可以指定多个。</li>
</ol>
<h2 id="3、Redis数据类型二散列类型："><a href="#3、Redis数据类型二散列类型：" class="headerlink" title="3、Redis数据类型二散列类型："></a>3、Redis数据类型二散列类型：</h2><p>Redis 是以字典（关联数组）的形式存储的，一个 key 对应一个 value。在字符串类型中，value 只能是一个字符串。那么在散列类型，也叫哈希类型中，value 对应的也是一个字典（关联数组）。那么就可以理解，Redis 的哈希类型/散列类型中，key 对应的 value 是一个二维数组。但是字段的值只可以是字符串。也就是说只能是二维数组，不能有更多的维度。</p>
<h2 id="4、Redis-数据命令二散列类型："><a href="#4、Redis-数据命令二散列类型：" class="headerlink" title="4、Redis 数据命令二散列类型："></a>4、Redis 数据命令二散列类型：</h2><ol>
<li>赋值：HSET key field value。如 hset user name lane。hset user age 23</li>
<li>取值：HGET key field。如 hget user name，得到的是 lane。</li>
<li>同一个key多个字段赋值：HMSET key field1 value1 field2 value2…</li>
<li>同一个KEY多个字段取值：HMGET key field1 fields2…</li>
<li>获取KEY的所有字段和所有值：HGETALL key。如 HGETALL user 得到的是 name lane age 23。每个返回都是独立的一行。</li>
<li>字段是否存在：HEXISTS key field。存在返回 1，不存在返回 0</li>
<li>当字段不存在时赋值：HSETNX key field value。如果 key 下面的字段 field 不存在，则建立 field 字段，且值为 value。如果 field 字段存在，则不执行任何操作。它的效果等于 HEXISTS + HSET。但是这个命令的优点是原子操作。再高的并发也不会怕怕。</li>
<li>自增 N：HINCREBY key field increment。同字符串的自增类型，不再阐述。</li>
<li>删除字段：DEL key field1 field2… 删除指定KEY的一个或多个字段。</li>
<li>只获取字段名：HKEYS key。与 HGETALL 类似，但是只获取字段名，不获取字段值。</li>
<li>只获取字段值：HVALS key。与 HGETALL 类似，但是只获取字段值，不获取字段名。</li>
<li>获取字段数量：HLEN key。</li>
</ol>
<h2 id="5、Redis-数据类型三列表类型"><a href="#5、Redis-数据类型三列表类型" class="headerlink" title="5、Redis 数据类型三列表类型"></a>5、Redis 数据类型三列表类型</h2><p>列表类型存储了一个有序的字符串列表。常用的操作是向两端插入新的元素。时间复杂度为 O（1）。结构为一个链表。记录头和尾的地址。看到这里，Redis 数据类型的列表类型一个重大的作用呼之欲出，那就是队列。新来的请求插入到尾部，新处理过的从头部删除。另外，比如微博的新鲜事。比如日志。列表类型就是一个下标从 0 开始的数组。由于是链表存储，那么越靠近头和尾的元素操作越快，越靠近中间则越慢。</p>
<h2 id="6、Redis-数据命令三列表类型："><a href="#6、Redis-数据命令三列表类型：" class="headerlink" title="6、Redis 数据命令三列表类型："></a>6、Redis 数据命令三列表类型：</h2><ol>
<li>向头部插入：LPUSH key value1 value2…。返回增加后的列表长度。</li>
<li>向尾部插入：RPUSH key value1 value2…。返回增加后的列表长度。</li>
<li>从头部弹出：LPOP key。返回被弹出的元素值。该操作先删除key列表的第一个元素，再将它返回。</li>
<li>从尾部弹出：RPOP key。返回被弹出的元素值。</li>
<li>列表元素个数：LLEN key。key 不存在返回 0。</li>
<li>获取列表的子列表：LRANGE start end。返回第 start 个到第 end 个元素的列表。包含 start 和 end。支持负数索引。-1 表示最后一个元素，-2 表示倒数第二个元素。</li>
<li>删除列表中指定值：LREM key count value。删除 key 这个列表中，所有值为 value 的元素，只删除 count。如果有 count+1 个，那么就保留最后一个。count 不存在或者为 0，则删除所有的。如果 count 大于 0，则删除从头到尾的 count 个，如果 count 小于 0，则删除从尾到头的 count 个。</li>
<li>获取指定索引值：LINDEX key index。如LINDEX key 0就是列表的第一个元素。index可以是负数。</li>
<li>设置索引和值：LSET key index value。这个操作只是修改指定 key 且指定 index 的值。如果 index 不存在，则报错。</li>
<li>保留片段，删除其它：LTRIM key start end。保留 start 到 end 之间的所有元素，含 start 和 end。其他全部删除。</li>
<li>向列表插入元素：LINSERT key BEFORE/AFTER value1 value2。从列表头开始遍历，发现值为 value1 时停止，将 value2 插入，根据 BEFORE 或者 AFTER 插入到 value1 的前面还是后面。</li>
<li>把一个列表的一个元素转到另一个列表：RPOPLPUSH list1 list2。将列表 list1 的右边元素删除，并把该与元素插入到列表 list2 的左边。原子操作。</li>
</ol>
<h2 id="7、Redis-数据类型四集合类型："><a href="#7、Redis-数据类型四集合类型：" class="headerlink" title="7、Redis 数据类型四集合类型："></a>7、Redis 数据类型四集合类型：</h2><p>集合类型是为了方便对多个集合进行操作和运算。集合中每个元素不同且没有顺序的概念，每个元素都是且只能是一个字符串。常用操作是对集合插入、删除、判断等操作。时间复杂度尾 O(1)。可以进行交集、并集、差集运算。例如文章 1 的有 3 个标签，是一个 Redis 数据类型集合类型存储。文章 2 有 3 个标签，有一个 Redis 数据类型集合类型存储。文章是 1 是 mysql，文章 2 是讲 redis。那么交集是不是就交出了一个数据库？（假设数据库这个tag在两篇文字都有）。集合类型在 redis 中的存储是一个值为空的散列表。</p>
<h2 id="8、Redis-数据命令四集合类型："><a href="#8、Redis-数据命令四集合类型：" class="headerlink" title="8、Redis 数据命令四集合类型："></a>8、Redis 数据命令四集合类型：</h2><ol>
<li>增加：SADD key value。</li>
<li>删除：SREM key value。</li>
<li>获取指定集合的所有元素：SMEMBERS key。</li>
<li>判断某个元素是否存在：SISMEMBER key value。</li>
<li>差集运算：SDIFF key1 key2…。对多个集合进行差集运算。</li>
<li>交集运算：SINNER key1 key2…。对多个集合进行交集运算。</li>
<li>并集运算：SUNION key1 key2…。对多个集合进行并集运算。</li>
<li>获取集合中元素个数：SCARD key。返回集合中元素的总个数。</li>
<li>对差集、交集、并集运算的结果存放在一个指定的 key 中：SDIFFSTORE storekey key1 key2。对 key1 和 key2 求差集，结果存放在 key 为 storekey 的集合中。SINNERSTORE 和 SUNIONSTORE 类似。</li>
<li>获取集合中的随即元素：SRANDMEMBER key [count]。参数 count 可选，如果 count 不存在，则随即一个。count 大于 0，则是不重复的 count 个元素。count 小于 0，则是一共 |count|个 元素，可以重复。</li>
<li>随即弹出一个元素：SPOP key。随即从集合中弹出一个元素并删除，将该元素的值返回。</li>
</ol>
<h2 id="9、Redis-数据类型五有序集合类型："><a href="#9、Redis-数据类型五有序集合类型：" class="headerlink" title="9、Redis 数据类型五有序集合类型："></a>9、Redis 数据类型五有序集合类型：</h2><p>集合类型是无序的，每个元素是唯一的。那么有序集合就是有序的，每个元素是唯一的。有序集合类型和集合类型的差别是，有序集合为每个元素配备了一个属性：分数。有序集合就是根据分数来排序的。有序集合是使用散列表和跳跃表实现的。所以和列表相比，操作中间元素的速度也很快。时间复杂度尾 O(log(N))。Redis 数据类型中的有序集合类型比 Redis 数据类型中的列表类型更加耗费资源。</p>
<h2 id="10、Redis数据命令五有序集合类型"><a href="#10、Redis数据命令五有序集合类型" class="headerlink" title="10、Redis数据命令五有序集合类型"></a>10、Redis数据命令五有序集合类型</h2><ol>
<li>增加：ZADD key sorce1 value1 sorce2 value2…。</li>
<li>获取分数：ZSCORE key value。获取key的有序集合中值为 value 的元素的分数。</li>
<li>获取排名在某个范围内的元素列表：ZRANFGE key start stop [WITHSCORE]。获取排名在 start 和 end 之间的元素列表，包含 start 和 end2 个元素。每个元素一行。如果有WITHSCORE参数，则一行元素值，一行分数。时间复杂度为O(LOGn+m)。如果分数相同，则 0&lt;0</li>
<li>获取指定分数范围的元素：ZRANGEBYSCORE key min max [WITHSCORE] [LIMIT offset count]。获取分数在 min 和 max 之间的元素列表。含两头。每个元素一行。如果有 WITHSCORE 参数，则一行元素值，一行分数。如果 min 大于 max 则顺序反转。</li>
<li>为某个元素增加分数：ZINCRBY key increment value。指定的有序集合的值为 value 的元素的分数 +increment。返回值后更改后的分数。</li>
<li>获取集合中元素的数量：ZCARD key。</li>
<li>获取指定分数范围内的元素个数：ZCOUNT key min max。</li>
<li>删除一个或多个元素：ZREM key value1 value2…</li>
<li>根据排名范围删除元素：ZREMRANGEBYRANK key start end。删除排名在 start 和 end 中的元素。</li>
<li>按照分数范围删除元素：ZREMRANGEBYSCORE key min max。</li>
<li>获得元素排名（正序）：ZRANK key value。获取 value 在该集合中的从小到大的排名。</li>
<li>获得元素排名（倒序）：ZREVRANK key value。获取 value 在该集合中从大到小的排名。</li>
<li>有序集合的交集：ZINTERSTORE storekey key1 key2…[WEIGHTS weight [weight..]] [AGGREGATE SUM|MIN|MAX]。用来计算多个集合的交集，结果存储在 storekey中。返回值是 storekey 的元素个数。AGGREGATE 为 SUM 则 storekey 集合的每个元素的分数是参与计算的集合分数和。MIN 是参与计算的分数最小值。MAX 是参与计算分数最大值。WEIGHTS 设置每个集合的权重，如 WEIGHTS 1 0.1。那么集合A的每个元素分数 * 1，集合B的每个元素分数 * 0.1</li>
<li>有序集合的并集：ZUNIONSTORE storekey key1 kye2…[WEIGHTS weight [weight..]] [AGGREGATE SUM|MIN|MAX]</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>编程技术</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>史上最污技术解读，60 个 IT 术语我竟然秒懂了......</title>
    <url>/2018/06/10/%E6%94%B6%E9%9B%86/%E5%8F%B2%E4%B8%8A%E6%9C%80%E6%B1%A1%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%EF%BC%8C60%20%E4%B8%AA%20IT%20%E6%9C%AF%E8%AF%AD%E6%88%91%E7%AB%9F%E7%84%B6%E7%A7%92%E6%87%82%E4%BA%86/</url>
    <content><![CDATA[<p>假设你是个妹子，你有一位男朋友，于此同时你和另外一位男生暧昧不清，比朋友好，又不是恋人。你随时可以甩了现任男友，另外一位马上就能补上。这是<strong>冷备份</strong>。</p>
<p>假设你是个妹子，同时和两位男性在交往，两位都是你男朋友。并且他们还互不干涉，独立运行。这就是<strong>双机热备份</strong>。</p>
<p>假设你是个妹子，不安于男朋友给你的安全感。在遥远的男友未知的地方，和一位男生保持着联系，你告诉他你没有男朋友，你现在处于纠结期，一旦你和你男朋友分开了，你马上可以把自己感情转移到异地男人那里去。这是<strong>异地容灾备份</strong>。</p>
<p>假设你是个妹子，有一位男朋友，你又付了钱给一家婚姻介绍所，让他帮你留意好的资源，一旦你和你这位男朋友分开，婚姻介绍所马上给你安排资源，你感情不间断运行，这是<strong>云备份</strong>。。。。</p>
<p>假设你是个妹子，你怀疑男朋友对你的忠诚，在某宝购买了一个测试忠诚度的服务。这是<strong>灾难演练</strong>。友情提醒，在没有备份的情况下，切忌进行灾难演练，说不好会让你数据血本无归。</p>
<p>假设你是个妹子，你和男友异地恋，你每天晚上都打电话查岗，问他还爱不爱你了，这叫<strong>ping</strong>。</p>
<p>假设你是个妹子，你的男友经常玩失踪，所以你希望时刻掌握他的行踪，你先打电话给他的好基友A，A说好基友B知道，B说好基友C知道，C说好基友D知道，D说你男朋友正在网吧打游戏，你终于知道了男友在哪儿，这叫<strong>TraceRoute</strong>。</p>
<p>假设你是个妹子，你的男友沉迷游戏经常不接电话无故宕机，所以当你们约好下午逛街以后你要时不时的打个电话询问，看看他是不是还能正常提供服务，这叫<strong>心跳监测</strong>。</p>
<p>假设你是个妹子，你想去逛街而你的男友A在打游戏不接电话，于是乎你把逛街的请求发给了替补男友B，从而保障服务不间断运行，这叫<strong>故障切换</strong>。</p>
<p>假设你是个妹子，你有很多需要男朋友完成的事情，于是乎你跟A逛街旅游吃饭不可描述，而B只能陪你逛街，不能拥有全部男朋友的权利，这叫<strong>主从配置 master-slave</strong>。</p>
<p>假设你是个妹子，你败家太厉害，以至于你的男友根本吃不消，于是呼你找了两个男朋友，一三五单号，二四六双号限行，从而减少一个男朋友所面临的压力，这叫<strong>负载均衡</strong>。</p>
<p>假设你是个妹子并且有多个男朋友，配合心跳检测与故障切换和负载均衡将会达到极致的体验，这叫<strong>集群LVS</strong>，注意，当需求单机可以处理的情况下不建议启用集群，会造成大量资源闲置，提高维护成本。</p>
<p>假设你是个妹子，你的需求越来越高导致一个男朋友集群已经处理不了了，于是乎你又新增了另外几个，这叫<strong>多集群横向扩容</strong>，简称<strong>multi-cluster grid</strong>。</p>
<p>假设你是个妹子，你的男朋友身体瘦弱从而无法满足需求，于是乎你买了很多大补产品帮你男朋友升级，从而提高单机容量，这叫<strong>纵向扩容</strong>，<strong>Scale up</strong>。切记，纵向扩容的成本会越来越高而效果越来越不明显。</p>
<p>假设你是个妹子，你跟男友经常出去游玩，情到深处想做点什么的时候却苦于没有tt，要去超市购买，于是乎你在你们经常去的地方都放置了tt，从而大幅度降低等待时间，这叫<strong>CDN</strong>。</p>
<p>假设你是个妹子,你的男朋友英俊潇洒风流倜傥财大气粗对你唯一,于是乎你遭到了女性B的敌视，B会以朋友名义在周末请求你男朋友修电脑,修冰箱,占用男朋友大量时间,造成男朋友无法为你服务,这叫<strong>拒绝服务攻击</strong>,简称<strong>DOS</strong>。</p>
<p>假设你是个妹子,你因男朋友被一位女性敌视,但是你男朋友的处理能力十分强大,处理速度已经高于她的请求速度,于是她雇佣了一票女性来轮流麻烦你的男朋友,这叫<strong>分布式拒绝服务攻击</strong>,简称<strong>DDOS</strong>。</p>
<p>假设你是个妹子，你发现男朋友总是在处理一些无关紧要的其它请求，于是乎你给男朋友了一个白名单,要求他只处理白名单内的请求，而拒绝其它身份不明的人的要求,这叫<strong>访问控制</strong>。</p>
<p>假设你是个妹子，你男朋友风流倜傥，你总担心他出轨，于是你在他身上安装了一个窃听器，里面内置了一些可疑女生勾搭行为的特征库，只要出现疑似被勾搭的情况，就会立刻向你报警，这叫<strong>入侵检测系统（IDS）</strong>。</p>
<p>假设你是个妹子，你改良了上面的窃听器，当可疑女性对你男朋友做出勾搭行为的时候，立刻释放1万伏电压，把可疑人击昏，终止这次勾搭。这叫<strong>入侵防御系统（IPS）</strong>。</p>
<p>假设你是个妹子，虽然你装了各种窃听器、报警器，可是你蓝朋友处处留情，报警器响个不停，让你应接不暇，疲于奔命，于是你搞了个装置集中收集这些出轨告警，进行综合分析，生成你男朋友的出轨报告。这叫<strong>SIEM</strong>或者<strong>SOC</strong>。</p>
<p>假设你是个妹子，你把男朋友的出轨报告提交给他父母，得到了他们的大力支持，男友父母开始对他严加管教、限期整改，为你们的爱情保驾护航，做到合情合理、合法合规，这叫<strong>等级保护</strong>。</p>
<p>假设你是个妹子，你离男朋友家有点远，你开车去，这叫自建专线，你打车过去，这叫租用专线，你骑摩拜单车过去，这叫<strong>SDWAN</strong>。</p>
<p>假设你是个妹子，你和男朋友的恋爱遭到了双方家长的反对，不准双方往来，你们偷偷挖了一条隧道，便于进行幽会，这叫<strong>VPN</strong>。</p>
<p>假设你是个妹子，你的男朋友太优秀而造人窥视，于是乎它们研究了一下你的男朋友，稍微修改了一点点生产出一个男朋友B，与你的男朋友百分制99相似，这不叫剽窃，这叫<strong>逆向工程</strong>,比如男朋友外挂。</p>
<p>假设你是个妹子，你要求你的男朋友坚持十分钟，然后十五分钟继而二十分钟，以测试你男朋友的极限在哪里，这叫<strong>压力测试</strong>。</p>
<p>假设你是个妹子，为了保证你男朋友的正常运行，于是乎你每天查看他的微信微博等社交资料来寻找可能产生问题的线索，这叫<strong>数据分析</strong>。</p>
<p>假设你是个妹子，你的男朋友属于社交活跃选手，每天的微博知乎微信生产了大量信息，你发现自己的分析速度远远低于他生的速度，于是乎你找来你的闺蜜一起分析，这叫<strong>并行计算</strong>。</p>
<p>假设你是个妹子，你的男朋友太能折腾处处留情产生了天量的待处理信息，你和你的闺蜜们已经累趴也没赶上他创造的速度，于是你付费在知乎上找了20个小伙伴帮你一起分析，这叫<strong>云计算</strong>。</p>
<p>假设你是个妹子，你在得到男朋友经常出没的地点后，根据酒店，敏感时间段等信息确定男朋友因该是出轨了，这叫<strong>数据挖掘</strong>。</p>
<p>假设你是个妹子，在分析男友的数据后，得知他下午又要出去开房，于是乎你在他准备出门前给他发了个短信，问他有没有带tt，没有的话可以在我这里买，这叫<strong>精准推送</strong>，需要配合数据挖掘。</p>
<p>假如你是个妹子，你的男朋友总该出去浪而各种出问题，于是乎你租了间屋子并准备好了所有需要的东西并告诉他，以后不用找酒店了，直接来我这屋子吧，什么都准备好了，这叫<strong>容器</strong>。</p>
<p>假如你是个妹子，你每天都要和男朋友打通一次接口，<strong>采集数据</strong>。你一天24小时不停地采，这叫<strong>实时数据采集</strong>。你决定开发新的接口来和男朋友交流，这叫<strong>虚拟化</strong>。你决定从不同的男友身上采集数据，你就是<strong>大数据中心</strong>。有一天你决定生一个宝宝，这叫<strong>大数据应用</strong>。宝宝生下来不知道是谁的，这叫<strong>大数据脱敏</strong>。但是从宝宝外观来看，黑色皮肤金色头发，这叫<strong>数据融合跨域建模</strong>。你决定把这个宝宝拿来展览收点门票，这叫<strong>大数据变现</strong>。</p>
<p>假如妹纸男友多多多，看都看不过来、用不到也记不住，索性把最典型、必不可少、有潜力的那些优质男友挑出来，这叫<strong>数据简化</strong>。至于如何挑，用到<strong>数据简化技术</strong>。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>win10 快捷键-- 小米亲写</title>
    <url>/2018/12/28/%E6%9D%82%E8%AE%B0/win10/</url>
    <content><![CDATA[<blockquote>
<p>我就先罗列大家可能不知道但好用的快捷键，再罗列全部的</p>
</blockquote>
<h1 id="win-系列-–-小米推荐"><a href="#win-系列-–-小米推荐" class="headerlink" title="win+ 系列 – 小米推荐"></a>win+ 系列 – 小米推荐</h1><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">win+x</td>
<td align="center">系统菜单</td>
</tr>
<tr>
<td align="center">win+q</td>
<td align="center">搜索</td>
</tr>
<tr>
<td align="center">win+shift+s</td>
<td align="center">截图</td>
</tr>
<tr>
<td align="center">win+v</td>
<td align="center">剪贴板</td>
</tr>
</tbody></table>
<blockquote>
<p>Windows 10</p>
</blockquote>
<p>键盘快捷方式就是按键或按键组合，可提供一种替代方式来执行通常使用鼠标执行的操作。</p>
<h1 id="复制、粘贴及其他常规的键盘快捷方式"><a href="#复制、粘贴及其他常规的键盘快捷方式" class="headerlink" title="复制、粘贴及其他常规的键盘快捷方式"></a>复制、粘贴及其他常规的键盘快捷方式</h1><table>
<thead>
<tr>
<th>按键</th>
<th>执行以下操作：</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + X</td>
<td>剪切选定项</td>
</tr>
<tr>
<td>Ctrl + C（或 Ctrl + Insert）</td>
<td>复制选定项</td>
</tr>
<tr>
<td>Ctrl + V（或 Shift + Insert）</td>
<td>粘贴选定项</td>
</tr>
<tr>
<td>Ctrl + Z</td>
<td>撤消操作</td>
</tr>
<tr>
<td>Alt + Tab</td>
<td>在打开的应用之间切换</td>
</tr>
<tr>
<td>Alt + F4</td>
<td>关闭活动项，或者退出活动应用</td>
</tr>
<tr>
<td>Windows 徽标键  + L</td>
<td>锁定你的电脑</td>
</tr>
<tr>
<td>Windows 徽标键  + D</td>
<td>显示和隐藏桌面</td>
</tr>
<tr>
<td>F2</td>
<td>重命名所选项目</td>
</tr>
<tr>
<td>F3</td>
<td>在文件资源管理器中搜索文件或文件夹</td>
</tr>
<tr>
<td>F4</td>
<td>在文件资源管理器中显示地址栏列表</td>
</tr>
<tr>
<td>F5</td>
<td>刷新活动窗口</td>
</tr>
<tr>
<td>F6</td>
<td>循环浏览窗口中或桌面上的屏幕元素</td>
</tr>
<tr>
<td>F10</td>
<td>激活活动应用中的菜单栏</td>
</tr>
<tr>
<td>Alt + F8</td>
<td>在登录屏幕上显示你的密码</td>
</tr>
<tr>
<td>Alt + Esc</td>
<td>按项目打开顺序循环浏览</td>
</tr>
<tr>
<td>Alt + 带下划线的字母</td>
<td>执行该字母相关的命令</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>显示所选项目的属性</td>
</tr>
<tr>
<td>Alt + 空格键</td>
<td>打开活动窗口的快捷方式菜单</td>
</tr>
<tr>
<td>Alt + 向左键</td>
<td>返回</td>
</tr>
<tr>
<td>Alt + 向右键</td>
<td>前进</td>
</tr>
<tr>
<td>Alt + 上一页</td>
<td>向上移动一个屏幕</td>
</tr>
<tr>
<td>Alt + 下一页</td>
<td>向下移动一个屏幕</td>
</tr>
<tr>
<td>Ctrl + F4</td>
<td>关闭活动文档（在可全屏显示并允许你同时打开多个文档的应用中）</td>
</tr>
<tr>
<td>Ctrl + A</td>
<td>选择文档或窗口中的所有项目</td>
</tr>
<tr>
<td>Ctrl + D（或删除键）</td>
<td>删除所选的项目，将其移至回收站</td>
</tr>
<tr>
<td>Ctrl + R（或 F5）</td>
<td>刷新活动窗口</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>恢复操作</td>
</tr>
<tr>
<td>Ctrl + 向右键</td>
<td>将光标移动到下一个字词的起始处</td>
</tr>
<tr>
<td>Ctrl + 向左键</td>
<td>将光标移动到上一个字词的起始处</td>
</tr>
<tr>
<td>Ctrl + 向下键</td>
<td>将光标移动到下一段落的起始处</td>
</tr>
<tr>
<td>Ctrl + 向上键</td>
<td>将光标移动到上一段落的起始处</td>
</tr>
<tr>
<td>Ctrl + Alt + Tab</td>
<td>使用箭头键在所有打开的应用之间进行切换</td>
</tr>
<tr>
<td>Alt + Shift + 箭头键</td>
<td>当组或磁贴的焦点放在“开始”菜单上时，可将其朝指定方向移动</td>
</tr>
<tr>
<td>Ctrl + Shift + 箭头键</td>
<td>当磁贴的焦点放在“开始”菜单上时，将其移到另一个磁贴即可创建一个文件夹</td>
</tr>
<tr>
<td>Ctrl + 箭头键</td>
<td>打开“开始”菜单后调整其大小</td>
</tr>
<tr>
<td>Ctrl + 箭头键（移至某个项目）+ 空格键</td>
<td>选择窗口中或桌面上的多个单独项目</td>
</tr>
<tr>
<td>Ctrl + Shift（及箭头键）</td>
<td>选择文本块</td>
</tr>
<tr>
<td>Ctrl + Esc</td>
<td>打开“开始”屏幕</td>
</tr>
<tr>
<td>Ctrl + Shift + Esc</td>
<td>打开任务管理器</td>
</tr>
<tr>
<td>Ctrl + Shift</td>
<td>如果多种键盘布局可用，则可切换键盘布局</td>
</tr>
<tr>
<td>Ctrl + 空格键</td>
<td>打开或关闭中文输入法编辑器 (IME)</td>
</tr>
<tr>
<td>Shift + F10</td>
<td>显示所选项目的快捷方式菜单</td>
</tr>
<tr>
<td>按 Shift 与任何箭头键</td>
<td>在窗口中或桌面上选择多个项目，或在文档中选择文本</td>
</tr>
<tr>
<td>Shift + Delete</td>
<td>删除选定项，无需先移动到回收站</td>
</tr>
<tr>
<td>向右键</td>
<td>打开右侧的下一个菜单，或打开子菜单</td>
</tr>
<tr>
<td>向左键</td>
<td>打开左侧的下一个菜单，或关闭子菜单</td>
</tr>
<tr>
<td>Esc</td>
<td>停止或离开当前任务</td>
</tr>
</tbody></table>
<h1 id="Windows-徽标键键盘快捷方式"><a href="#Windows-徽标键键盘快捷方式" class="headerlink" title="Windows 徽标键键盘快捷方式"></a>Windows 徽标键键盘快捷方式</h1><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>Windows 徽标键</td>
<td>打开或关闭“开始”屏幕</td>
</tr>
<tr>
<td>Windows 徽标键  + A</td>
<td>打开操作中心</td>
</tr>
<tr>
<td>Windows 徽标键  + B</td>
<td>将焦点设置到通知区域</td>
</tr>
<tr>
<td>Windows 徽标键  + C</td>
<td>在侦听模式下打开 Cortana,Cortana 仅在某些国家/地区可用，并且某些 Cortana 功能可能无法随时随地使用</td>
</tr>
<tr>
<td>Windows 徽标键  + Shift + C</td>
<td>打开超级按钮菜单</td>
</tr>
<tr>
<td>Windows 徽标键  + D</td>
<td>显示和隐藏桌面</td>
</tr>
<tr>
<td>Windows 徽标键  + Alt + D</td>
<td>显示和隐藏桌面上的日期和时间</td>
</tr>
<tr>
<td>Windows 徽标键  + E</td>
<td>打开文件资源管理器</td>
</tr>
<tr>
<td>Windows 徽标键  + F</td>
<td>打开反馈中心并获取屏幕截图</td>
</tr>
<tr>
<td>Windows 徽标键  + G</td>
<td>打开游戏栏（当游戏处于打开状态时）</td>
</tr>
<tr>
<td>Windows 徽标键 ‌ + H</td>
<td>开始听写</td>
</tr>
<tr>
<td>Windows 徽标键  + I</td>
<td>打开“设置”</td>
</tr>
<tr>
<td>Windows 徽标键‌  +J</td>
<td>请将焦点设置到可用的 Windows 提示。</td>
</tr>
<tr>
<td>Windows 徽标键  + K</td>
<td>打开“连接”快速操作</td>
</tr>
<tr>
<td>Windows 徽标键  + L</td>
<td>锁定你的电脑或切换帐户</td>
</tr>
<tr>
<td>Windows 徽标键  + M</td>
<td>最小化所有窗口</td>
</tr>
<tr>
<td>Windows 徽标键  + O</td>
<td>锁定设备方向</td>
</tr>
<tr>
<td>Windows 徽标键  + P</td>
<td>选择演示显示模式</td>
</tr>
<tr>
<td>Windows 徽标键  + R</td>
<td>打开“运行”对话框</td>
</tr>
<tr>
<td>Windows 徽标键  + S</td>
<td>打开搜素</td>
</tr>
<tr>
<td>Windows 徽标键  + T</td>
<td>循环浏览任务栏上的应用</td>
</tr>
<tr>
<td>Windows 徽标键  + U</td>
<td>打开轻松使用设置中心</td>
</tr>
<tr>
<td>Windows 徽标键  + V</td>
<td>打开剪贴板。</td>
</tr>
<tr>
<td>Windows 徽标键  + Shift + V</td>
<td>循环浏览通知。</td>
</tr>
<tr>
<td>Windows 徽标键  + X</td>
<td>打开“快速链接”菜单</td>
</tr>
<tr>
<td>Windows 徽标键  + Y</td>
<td>在 Windows Mixed Reality 与桌面之间切换输入</td>
</tr>
<tr>
<td>Windows 徽标键  + Z</td>
<td>以全屏模式显示应用中可用的命令</td>
</tr>
<tr>
<td>Windows 徽标键  + 句点 (.) 或分号 (;)</td>
<td>打开表情符号面板</td>
</tr>
<tr>
<td>Windows 徽标键  + 逗号 (,)</td>
<td>临时速览桌面</td>
</tr>
<tr>
<td>Windows 徽标键  + Pause 键    显示“系统属性”对话框</td>
<td></td>
</tr>
<tr>
<td>Windows 徽标键  + Ctrl + F</td>
<td>搜索电脑（如果已连接到网络）</td>
</tr>
<tr>
<td>Windows 徽标键  + Shift + M</td>
<td>还原桌面上的最小化窗口</td>
</tr>
<tr>
<td>Windows 徽标键  + 数字</td>
<td>打开桌面，然后启动固定到任务栏的应用（位于数字所指明的位置）。如果应用已处于运行状态，则切换至该应用。</td>
</tr>
<tr>
<td>Windows 徽标键  + Shift + 数字</td>
<td>打开桌面，然后启动固定到任务栏的应用新实例（位于数字所指明的位置）</td>
</tr>
<tr>
<td>Windows 徽标键  + Ctrl + 数字</td>
<td>打开桌面，然后切换至固定到任务栏的应用的最后活动窗口（位于数字所指明的位置）</td>
</tr>
<tr>
<td>Windows 徽标键  + Alt + 数字</td>
<td>打开桌面，然后打开固定到任务栏的应用的“跳转列表”（位于数字所指明的位置）</td>
</tr>
<tr>
<td>Windows 徽标键  + Ctrl + Shift + 数字</td>
<td>打开桌面，然后以管理员身份打开位于任务栏上指定位置的应用新实例</td>
</tr>
<tr>
<td>Windows 徽标键  + Tab</td>
<td>打开任务视图</td>
</tr>
<tr>
<td>Windows 徽标键  + 向上键</td>
<td>最大化窗口</td>
</tr>
<tr>
<td>Windows 徽标键  + 向下键</td>
<td>删除屏幕上的当前应用并最小化桌面窗口</td>
</tr>
<tr>
<td>Windows 徽标键  + 向左键</td>
<td>最大化屏幕左侧的应用或桌面窗口</td>
</tr>
<tr>
<td>Windows 徽标键  + 向右键</td>
<td>最大化屏幕右侧的应用或桌面窗口</td>
</tr>
<tr>
<td>Windows 徽标键  + Home</td>
<td>最小化活动桌面窗口之外的所有窗口（在第二个笔划时还原所有窗口）</td>
</tr>
<tr>
<td>Windows 徽标键  + Shift + 向上键</td>
<td>将桌面窗口拉伸至屏幕顶部和底部</td>
</tr>
<tr>
<td>Windows 徽标键  + Shift + 向下键</td>
<td>在垂直方向上还原/最小化活动桌面窗口，而宽度保持不变</td>
</tr>
<tr>
<td>Windows 徽标键  + Shift + 向左键或向右键</td>
<td>将桌面上的应用或窗口从一台显示器移动至另一台显示器</td>
</tr>
<tr>
<td>Windows 徽标键  + 空格键</td>
<td>切换输入语言和键盘布局</td>
</tr>
<tr>
<td>Windows 徽标键  + Ctrl + 空格键</td>
<td>对之前选择的输入所做的更改</td>
</tr>
<tr>
<td>Windows 徽标键  + Ctrl + Enter</td>
<td>打开“讲述人”</td>
</tr>
<tr>
<td>Windows 徽标键 + Plus (+)</td>
<td>打开“放大镜”</td>
</tr>
<tr>
<td>Windows 徽标键  + 正斜杠 (/)</td>
<td>开始输入法复原流程</td>
</tr>
<tr>
<td>Windows 徽标键  + Ctrl + V</td>
<td>打开肩式分接设备</td>
</tr>
</tbody></table>
<h1 id="命令提示符键盘快捷方式"><a href="#命令提示符键盘快捷方式" class="headerlink" title="命令提示符键盘快捷方式"></a>命令提示符键盘快捷方式</h1><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + C（或 Ctrl + Insert）</td>
<td>复制选定文本</td>
</tr>
<tr>
<td>Ctrl + V（或 Shift + Insert）</td>
<td>粘贴选定文本</td>
</tr>
<tr>
<td>Ctrl + M</td>
<td>输入标记模式</td>
</tr>
<tr>
<td>Alt + 所选择的键</td>
<td>开始在块模式下选择</td>
</tr>
<tr>
<td>箭头键</td>
<td>按指定方向移动光标</td>
</tr>
<tr>
<td>上一页</td>
<td>将光标向上移动一个页面</td>
</tr>
<tr>
<td>下一页</td>
<td>将光标向下移动一个页面</td>
</tr>
<tr>
<td>Ctrl + Home（标记模式）</td>
<td>将光标移动到缓冲区起始处</td>
</tr>
<tr>
<td>Ctrl + End（标记模式）</td>
<td>将光标移动到缓冲区结尾处</td>
</tr>
<tr>
<td>Ctrl + 向上键</td>
<td>在输出历史记录中上移一行</td>
</tr>
<tr>
<td>Ctrl + 向下键</td>
<td>在输出历史记录中下移一行</td>
</tr>
<tr>
<td>Ctrl + Home（历史记录导航）</td>
<td>如果命令行为空，则将视区移动到缓冲区顶部。否则，请删除命令行中光标左侧的所有字符。</td>
</tr>
<tr>
<td>Ctrl + End（历史记录导航）</td>
<td>如果命令行为空，则将视区移动到命令行。否则，请删除命令行中光标右侧的所有字符。</td>
</tr>
</tbody></table>
<h1 id="对话框键盘快捷方式"><a href="#对话框键盘快捷方式" class="headerlink" title="对话框键盘快捷方式"></a>对话框键盘快捷方式</h1><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>F4</td>
<td>显示活动列表中的项目</td>
</tr>
<tr>
<td>Ctrl + Tab</td>
<td>在选项卡中向前移动</td>
</tr>
<tr>
<td>Ctrl + Shift + Tab</td>
<td>在选项卡中向后移动</td>
</tr>
<tr>
<td>Ctrl + 数字（数字 1–9）</td>
<td>移动到第 n 个选项卡</td>
</tr>
<tr>
<td>Tab</td>
<td>在选项中向前移动</td>
</tr>
<tr>
<td>Shift + Tab</td>
<td>在选项中向后移动</td>
</tr>
<tr>
<td>Alt + 带下划线的字母</td>
<td>执行可与该字母结合使用的命令（或选择该选项）</td>
</tr>
<tr>
<td>空格键</td>
<td>如果活动选项为复选框，则选择或清除复选框</td>
</tr>
<tr>
<td>Backspace</td>
<td>如果在“另存为”或“打开”对话框中选择文件夹，则打开上一级别的文件夹</td>
</tr>
<tr>
<td>箭头键</td>
<td>如果活动选项是一组选项按钮，请选择一个按钮</td>
</tr>
</tbody></table>
<h1 id="文件资源管理器键盘快捷方式"><a href="#文件资源管理器键盘快捷方式" class="headerlink" title="文件资源管理器键盘快捷方式"></a>文件资源管理器键盘快捷方式</h1><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>Alt + D</td>
<td>选中地址栏</td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>选择搜索框</td>
</tr>
<tr>
<td>Ctrl + F</td>
<td>选择搜索框</td>
</tr>
<tr>
<td>Ctrl + N</td>
<td>打开新窗口</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>关闭活动窗口</td>
</tr>
<tr>
<td>Ctrl + 鼠标滚轮</td>
<td>更改文件和文件夹图标的大小和外观</td>
</tr>
<tr>
<td>Ctrl + Shift + E</td>
<td>显示选定文件夹上所有的文件夹</td>
</tr>
<tr>
<td>Ctrl + Shift + N</td>
<td>创建新文件夹</td>
</tr>
<tr>
<td>Num Lock + 星号 (*)</td>
<td>显示选定文件夹下所有子文件夹</td>
</tr>
<tr>
<td>Num Lock + 加号 (+)</td>
<td>显示选定文件夹中的内容</td>
</tr>
<tr>
<td>Num Lock + 减号 (-)</td>
<td>折叠选定文件夹</td>
</tr>
<tr>
<td>Alt + P</td>
<td>显示预览面板</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>打开选定项目的“属性”对话框</td>
</tr>
<tr>
<td>Alt + 向右键</td>
<td>查看下一个文件夹</td>
</tr>
<tr>
<td>Alt + 向上键</td>
<td>查看该文件夹所在的文件夹</td>
</tr>
<tr>
<td>Alt + 向左键</td>
<td>查看上一个文件夹</td>
</tr>
<tr>
<td>Backspace</td>
<td>查看上一个文件夹</td>
</tr>
<tr>
<td>向右键</td>
<td>显示当前选择内容（如果已折叠），或选择第一个子文件夹</td>
</tr>
<tr>
<td>向左键</td>
<td>折叠当前所选内容（如果已展开），或选择该文件夹所在的文件夹</td>
</tr>
<tr>
<td>End</td>
<td>显示活动窗口底部</td>
</tr>
<tr>
<td>Home</td>
<td>显示活动窗口顶部</td>
</tr>
<tr>
<td>F11</td>
<td>最大化或最小化活动窗口</td>
</tr>
</tbody></table>
<h1 id="虚拟桌面的键盘快捷方式"><a href="#虚拟桌面的键盘快捷方式" class="headerlink" title="虚拟桌面的键盘快捷方式"></a>虚拟桌面的键盘快捷方式</h1><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>Windows 徽标键  + Tab</td>
<td>打开任务视图</td>
</tr>
<tr>
<td>Windows 徽标键  + Ctrl + D</td>
<td>添加虚拟桌面</td>
</tr>
<tr>
<td>Windows 徽标键  + Ctrl + 向右键</td>
<td>在你于右侧创建的虚拟桌面之间切换</td>
</tr>
<tr>
<td>Windows 徽标键  + Ctrl + 向左键</td>
<td>在你于左侧创建的虚拟桌面之间切换</td>
</tr>
<tr>
<td>Windows 徽标键  + Ctrl + F4</td>
<td>关闭你正在使用的虚拟桌面</td>
</tr>
</tbody></table>
<h1 id="任务栏键盘快捷方式"><a href="#任务栏键盘快捷方式" class="headerlink" title="任务栏键盘快捷方式"></a>任务栏键盘快捷方式</h1><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>Shift + 单击任务栏按钮</td>
<td>打开应用或快速打开另一个应用实例</td>
</tr>
<tr>
<td>Ctrl + Shift + 单击任务栏按钮</td>
<td>以管理员身份打开应用</td>
</tr>
<tr>
<td>Shift + 右键单击任务栏按钮</td>
<td>显示应用的窗口菜单</td>
</tr>
<tr>
<td>Shift + 右键单击分组任务栏按钮</td>
<td>显示组窗口菜单</td>
</tr>
<tr>
<td>Ctrl + 单击分组任务栏按钮</td>
<td>循环浏览组窗口</td>
</tr>
</tbody></table>
<h1 id="设置键盘快捷方式"><a href="#设置键盘快捷方式" class="headerlink" title="设置键盘快捷方式"></a>设置键盘快捷方式</h1><table>
<thead>
<tr>
<th>按该键</th>
<th>执行以下操作</th>
</tr>
</thead>
<tbody><tr>
<td>Windows 徽标键  + I</td>
<td>打开设置</td>
</tr>
<tr>
<td>Backspace</td>
<td>返回至设置主页</td>
</tr>
<tr>
<td>使用搜索框在任何页面上键入</td>
<td>搜索设置</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题--Hibernate--小米归纳</title>
    <url>/2019/03/23/%E9%9D%A2%E8%AF%95%E9%A2%98/Hibernate/</url>
    <content><![CDATA[<p>大纲<br><img src="https://i.loli.net/2019/03/22/5c94a8d581abb.png" alt=""></p>
<h1 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a>未归类</h1><h2 id="Hibernate是如何延迟加载-懒加载"><a href="#Hibernate是如何延迟加载-懒加载" class="headerlink" title="Hibernate是如何延迟加载(懒加载)?"></a>Hibernate是如何延迟加载(懒加载)?</h2><p>通过设置属性 <code>lazy</code> 进行设置是否需要懒加载</p>
<p>当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。</p>
<h2 id="Hibernate中怎样实现类之间的关系-如：一对多、多对多的关系"><a href="#Hibernate中怎样实现类之间的关系-如：一对多、多对多的关系" class="headerlink" title="Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)"></a>Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系)</h2><p>它们通过配置文件中的 <code>many-to-one</code> 、<code>one-to-many</code> 、<code>many-to-many</code> 来实现类之间的关联关系的。</p>
<h2 id="hibernate的三种状态之间如何转换"><a href="#hibernate的三种状态之间如何转换" class="headerlink" title="hibernate的三种状态之间如何转换"></a>hibernate的三种状态之间如何转换</h2><p>Hibernate中对象的状态：</p>
<ul>
<li><p>临时/瞬时状态</p>
</li>
<li><p>持久化状态</p>
</li>
<li><p>游离状态</p>
</li>
<li><p><strong>临时/瞬时状态</strong></p>
<p>  当我们直接new出来的对象就是临时/瞬时状态的..</p>
<ul>
<li>该对象还没有被持久化【没有保存在数据库中】</li>
<li>不受Session的管理</li>
</ul>
</li>
<li><p><strong>持久化状态</strong></p>
<p>  当保存在数据库中的对象就是持久化状态了</p>
<ul>
<li>当调用session的save/saveOrUpdate/get/load/list等方法的- 时候，对象就是持久化状态</li>
<li>在数据库有对应的数据</li>
<li>受Session的管理</li>
<li>当对对象属性进行更改的时候，会反映到数据库中!</li>
</ul>
</li>
<li><p><strong>游离状态</strong></p>
<p>  当Session关闭了以后，持久化的对象就变成了游离状态了…</p>
<ul>
<li>不处于session的管理</li>
<li>数据库中有对应的记录</li>
</ul>
</li>
</ul>
<blockquote>
<p>new出来的对象是瞬时状态 -&gt; 保存到数据库中(受Session管理)就是持久化状态 -&gt; 将session close掉就是游离状态</p>
</blockquote>
<h2 id="比较hibernate的三种检索策略优缺点"><a href="#比较hibernate的三种检索策略优缺点" class="headerlink" title="比较hibernate的三种检索策略优缺点"></a>比较hibernate的三种检索策略优缺点</h2><table>
<thead>
<tr>
<th>策略</th>
<th>优点</th>
<th>缺点</th>
<th>配置方法</th>
</tr>
</thead>
<tbody><tr>
<td>立即检索</td>
<td>对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象；</td>
<td><ol><li>select语句太多</li><li>可能会加载应用程序不需要访问的对象白白浪费许多内存空间</li></ol></td>
<td><code>lazy=false；</code></td>
</tr>
<tr>
<td>延迟检索</td>
<td>由应用程序决定需要加载哪些对象，可以避免可执行多余的select语句，以及避免加载应用程序不需要访问的对象。因此能提高检索性能，并且能节省内存空间；</td>
<td>应用程序如果希望访问游离状态代理类实例，必须保证他在持久化状态时已经被初始化；</td>
<td><code>lazy=true；</code></td>
</tr>
<tr>
<td>迫切左外连接检索</td>
<td><ol><li>对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便地冲一个对象导航到与它关联的对象。</li><li>使用了外连接，select语句数目少</li></ol></td>
<td><ol><li>可能会加载应用程序不需要访问的对象，白白浪费许多内存空间</li><li>复杂的数据库表连接也会影响检索性能</li></ol></td>
<td><code>fetch=“join”</code></td>
</tr>
</tbody></table>
<h2 id="hibernate都支持哪些缓存策略"><a href="#hibernate都支持哪些缓存策略" class="headerlink" title="hibernate都支持哪些缓存策略"></a>hibernate都支持哪些缓存策略</h2><p>usage的属性有4种：</p>
<ul>
<li>放入二级缓存的对象，只读(Read-only);</li>
<li>非严格的读写(Nonstrict read/write)</li>
<li>读写； 放入二级缓存的对象可以读、写(Read/write)；</li>
<li>基于事务的策略(Transactional)</li>
</ul>
<h2 id="hibernate里面的sorted-collection-和ordered-collection有什么区别"><a href="#hibernate里面的sorted-collection-和ordered-collection有什么区别" class="headerlink" title="hibernate里面的sorted collection 和ordered collection有什么区别"></a>hibernate里面的<code>sorted collection</code> 和<code>ordered collection</code>有什么区别</h2><ul>
<li><p>sorted collection</p>
<p>  是在内存中通过Java比较器进行排序的</p>
</li>
<li><p>ordered collection</p>
<p>  是在数据库中通过order by进行排序的</p>
</li>
</ul>
<p>对于比较大的数据集，为了避免在内存中对它们进行排序而出现 Java中的<code>OutOfMemoryError</code>，最好使用<code>ordered collection</code>。</p>
<h2 id="说下Hibernate的缓存机制"><a href="#说下Hibernate的缓存机制" class="headerlink" title="说下Hibernate的缓存机制"></a>说下Hibernate的缓存机制</h2><ul>
<li><p>一级缓存：</p>
<ul>
<li>Hibenate中一级缓存，也叫做session的缓存，它可以在session范围内减少数据库的访问次数！ 只在session范围有效！ Session关闭，一级缓存失效！</li>
<li>只要是持久化对象状态的，都受Session管理，也就是说，都会在Session缓存中！</li>
<li>Session的缓存由hibernate维护，用户不能操作缓存内容； 如果想操作缓存内容，必须通过hibernate提供的evit/clear方法操作。</li>
</ul>
</li>
<li><p>二级缓存：</p>
<ul>
<li>二级缓存是基于应用程序的缓存，所有的Session都可以使用</li>
<li>Hibernate提供的二级缓存有默认的实现，且是一种可插配的缓存框架！如果用户想用二级缓存，只需要在hibernate.cfg.xml中配置即可； 不想用，直接移除，不影响代码。</li>
<li>如果用户觉得hibernate提供的框架框架不好用，自己可以换其他的缓存框架或自己实现缓存框架都可以。</li>
<li>Hibernate二级缓存：存储的是常用的类</li>
</ul>
</li>
</ul>
<h2 id="Hibernate的查询方式有几种"><a href="#Hibernate的查询方式有几种" class="headerlink" title="Hibernate的查询方式有几种"></a>Hibernate的查询方式有几种</h2><ol>
<li>对象导航查询(objectcomposition)</li>
<li>HQL查询<ol>
<li>属性查询</li>
<li>参数查询、命名参数查询</li>
<li>关联查询</li>
<li>分页查询</li>
<li>统计函数</li>
</ol>
</li>
<li>Criteria 查询</li>
<li>SQLQuery本地SQL查询</li>
</ol>
<h2 id="如何优化Hibernate？"><a href="#如何优化Hibernate？" class="headerlink" title="如何优化Hibernate？"></a>如何优化Hibernate？</h2><ul>
<li>数据库设计调整</li>
<li>HQL优化</li>
<li>API的正确使用(如根据不同的业务类型选用不同的集合及查询API)</li>
<li>主配置参数(日志，查询缓存，fetch_size, batch_size等)</li>
<li>映射文件优化(ID生成策略，二级缓存，延迟加载，关联优化)</li>
<li>一级缓存的管理</li>
<li>针对二级缓存，还有许多特有的策略</li>
</ul>
<p>详情可参考资料：</p>
<p><a href="https://www.cnblogs.com/xhj123/p/6106088.html" target="_blank" rel="noopener">https://www.cnblogs.com/xhj123/p/6106088.html</a></p>
<h2 id="谈谈Hibernate中inverse的作用"><a href="#谈谈Hibernate中inverse的作用" class="headerlink" title="谈谈Hibernate中inverse的作用"></a>谈谈Hibernate中inverse的作用</h2><p>inverse属性默认是false,就是说关系的两端都来维护关系。</p>
<ul>
<li>比如Student和Teacher是多对多关系，用一个中间表TeacherStudent维护。Gp)</li>
<li>如果Student这边inverse=”true”, 那么关系由另一端Teacher维护，就是说当插入Student时，不会操作TeacherStudent表（中间表）。只有Teacher插入或删除时才会触发对中间表的操作。所以两边都inverse=”true”是不对的，会导致任何操作都不触发对中间表的影响；当两边都inverse=”false”或默认时，会导致在中间表中插入两次关系。</li>
</ul>
<p>如果表之间的关联关系是“一对多”的话，那么inverse只能在“一”的一方来配置！</p>
<p>详情可参考：</p>
<p><a href="https://zhongfucheng.bitcron.com/post/hibernate/hibernate-inversehe-cascadeshu-xing-zhi-shi-yao-dian" target="_blank" rel="noopener">https://zhongfucheng.bitcron.com/post/hibernate/hibernate-inversehe-cascadeshu-xing-zhi-shi-yao-dian</a></p>
<h2 id="JDBC-hibernate-和-ibatis-的区别"><a href="#JDBC-hibernate-和-ibatis-的区别" class="headerlink" title="JDBC hibernate 和 ibatis 的区别"></a>JDBC hibernate 和 ibatis 的区别</h2><ul>
<li>jdbc:手动<ul>
<li>手动写sql</li>
<li>delete、insert、update要将对象的值一个一个取出传到sql中,不能直接传入一个对象。</li>
<li>select:返回的是一个resultset，要从ResultSet中一行一行、一个字段一个字段的取出，然后封装到一个对象中，不直接返回一个对象。</li>
</ul>
</li>
<li>ibatis的特点:半自动化<ul>
<li>sql要手动写</li>
<li>delete、insert、update:直接传入一个对象</li>
<li>select:直接返回一个对象</li>
</ul>
</li>
<li>hibernate:全自动<ul>
<li>不写sql,自动封装</li>
<li>delete、insert、update:直接传入一个对象</li>
<li>select:直接返回一个对象</li>
</ul>
</li>
</ul>
<h2 id="在数据库中条件查询速度很慢的时候-如何优化"><a href="#在数据库中条件查询速度很慢的时候-如何优化" class="headerlink" title="在数据库中条件查询速度很慢的时候,如何优化?"></a>在数据库中条件查询速度很慢的时候,如何优化?</h2><ul>
<li>建索引</li>
<li>减少表之间的关联</li>
<li>优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据量大的表排在前面</li>
<li>简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据</li>
</ul>
<h2 id="什么是SessionFactory-她是线程安全么"><a href="#什么是SessionFactory-她是线程安全么" class="headerlink" title="什么是SessionFactory,她是线程安全么"></a>什么是SessionFactory,她是线程安全么</h2><p>SessionFactory 是Hibrenate单例数据存储和线程安全的，以至于可以多线程同时访问。一个SessionFactory 在启动的时候只能建立一次。SessionFactory应该包装各种单例以至于它能很简单的在一个应用代码中储存.</p>
<h2 id="get和load区别"><a href="#get和load区别" class="headerlink" title="get和load区别"></a>get和load区别</h2><ol>
<li>get如果没有找到会返回null， load如果没有找到会抛出异常。</li>
<li>get会先查一级缓存， 再查二级缓存，然后查数据库；load会先查一级缓存，如果没有找到，就创建代理对象， 等需要的时候去查询二级缓存和数据库。</li>
</ol>
<h2 id="主键生成-策略有哪些"><a href="#主键生成-策略有哪些" class="headerlink" title="主键生成 策略有哪些"></a>主键生成 策略有哪些</h2><p>主键的自动生成策略</p>
<ul>
<li>identity 自增长(mysql,db2)</li>
<li>sequence 自增长(序列)， oracle中自增长是以序列方法实现**</li>
<li>native 自增长【会根据底层数据库自增长的方式选择identity或sequence】<ul>
<li>如果是mysql数据库, 采用的自增长方式是identity</li>
<li>如果是oracle数据库， 使用sequence序列的方式实现自增长</li>
</ul>
</li>
<li>increment 自增长(会有并发访问的问题，一般在服务器集群环境使用会存在问题。)</li>
<li>assigned 指定主键生成策略为手动指定主键的值</li>
<li>uuid 指定主键生成策略为UUID生成的值</li>
<li>foreign(外键的方式)</li>
</ul>
<h2 id="Hibernate的五个核心接口"><a href="#Hibernate的五个核心接口" class="headerlink" title="Hibernate的五个核心接口"></a>Hibernate的五个核心接口</h2><ul>
<li>Configuration 接口：配置Hibernate，根据其启动hibernate，创建  SessionFactory 对象； </li>
<li>SessionFactory 接口：初始化Hibernate，充当数据存储源的代理，创建 session 对象，sessionFactory 是线程安全的，意味着它的同一个实例可以被应 用的多个线程共享，是重量级、二级缓存； </li>
<li>Session 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的， 避免多个线程共享同一个session，是轻量级、一级缓存； </li>
<li>Transaction 接口：管理事务； </li>
<li>Query 和Criteria 接口：执行数据库的查询。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么分布式一定要有消息队列？</title>
    <url>/2018/08/10/%E6%9E%B6%E6%9E%84/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E5%AE%9A%E8%A6%81%E6%9C%89%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<blockquote><p>分布式之消息队列复习精讲</p>
<footer><strong>孤独烟</strong><cite><a href="http://www.cnblogs.com/rjzheng/p/8994962.html" target="_blank" rel="noopener">cnblogs.com/rjzheng/p/8994962.html</a></cite></footer></blockquote>

<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="为什么写这篇文章"><a href="#为什么写这篇文章" class="headerlink" title="为什么写这篇文章?"></a>为什么写这篇文章?</h2><p>博主有两位朋友分别是小A和小B:</p>
<ol>
<li>小A，工作于传统软件行业(某社保局的软件外包公司)，每天工作内容就是和产品聊聊需求，改改业务逻辑。再不然就是和运营聊聊天，写几个SQL，生成下报表。又或者接到客服的通知，某某功能故障了，改改数据，然后下班部署上线。每天过的都是这种生活，技术零成长。</li>
<li>小B，工作于某国企，虽然能接触到一些中间件技术。然而，他只会订阅/发布消息。通俗点说，就是调调API。对为什么使用这些中间件啊？如何保证高可用啊？没有充分的认识。</li>
</ol>
<p>庆幸的是两位朋友都很有上进心，于是博主写这篇文章，帮助他们复习一下关于消息队列中间件这块的要点</p>
<h2 id="复习要点"><a href="#复习要点" class="headerlink" title="复习要点"></a>复习要点</h2><p>本文大概围绕如下几点进行阐述:</p>
<ul>
<li>为什么使用消息队列？</li>
<li>使用消息队列有什么缺点?</li>
<li>消息队列如何选型?</li>
<li>如何保证消息队列是高可用的？</li>
<li>如何保证消息不被重复消费?</li>
<li>如何保证消费的可靠性传输?</li>
<li>如何保证消息的顺序性？</li>
</ul>
<p>我们围绕以上七点进行阐述。需要说明一下，本文不是《消息队列从入门到精通》这种课程，因此只是提供一个复习思路，而不是去教你们怎么调用消息队列的API。建议对消息队列不了解的人，去找点消息队列的博客看看，再看本文，收获更大</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1、为什么要使用消息队列"><a href="#1、为什么要使用消息队列" class="headerlink" title="1、为什么要使用消息队列?"></a>1、为什么要使用消息队列?</h2><p><strong>分析</strong>:一个用消息队列的人，不知道为啥用，这就有点尴尬。没有复习这点，很容易被问蒙，然后就开始胡扯了。</p>
<p><strong>回答</strong>:这个问题,咱只答三个最主要的应用场景(不可否认还有其他的，但是只答三个主要的),即以下六个字:解耦、异步、削峰</p>
<h3 id="1-解耦"><a href="#1-解耦" class="headerlink" title="(1)解耦"></a>(1)解耦</h3><p><strong>传统模式</strong>:</p>
<p><img src="https://raw.githubusercontent.com/Air6211332/Air6211332.github.io/img/20180603133039.png" alt=""></p>
<p>传统模式的<strong>缺点</strong>：</p>
<ul>
<li>系统间耦合性太强，如上图所示，系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！</li>
</ul>
<p><strong>中间件模式</strong>:</p>
<p><img src="https://raw.githubusercontent.com/Air6211332/Air6211332.github.io/img/20180603133056.png" alt=""></p>
<p>中间件模式的的<strong>优点</strong>：</p>
<ul>
<li>将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改。</li>
</ul>
<h3 id="2-异步s"><a href="#2-异步s" class="headerlink" title="(2)异步s"></a>(2)异步s</h3><p><strong>传统模式</strong>:</p>
<p><img src="https://raw.githubusercontent.com/Air6211332/Air6211332.github.io/img/20180603133116.png" alt=""></p>
<p>传统模式的<strong>缺点</strong>：</p>
<ul>
<li>一些非必要的业务逻辑以同步的方式运行，太耗费时间。</li>
</ul>
<p><strong>中间件模式</strong>:</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180603000130.png" alt=""></p>
<p>中间件模式的的<strong>优点</strong>：</p>
<ul>
<li>将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度</li>
</ul>
<h3 id="3-削峰"><a href="#3-削峰" class="headerlink" title="(3)削峰"></a>(3)削峰</h3><p><strong>传统模式</strong></p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180603000117.png" alt=""></p>
<p>传统模式的<strong>缺点</strong>：</p>
<p>并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常</p>
<p><strong>中间件模式</strong>:</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180603000059.png" alt=""></p>
<p>中间件模式的的<strong>优点</strong>：</p>
<p>系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。</p>
<h2 id="2、使用了消息队列会有什么缺点"><a href="#2、使用了消息队列会有什么缺点" class="headerlink" title="2、使用了消息队列会有什么缺点?"></a>2、使用了消息队列会有什么缺点?</h2><p><strong>分析</strong>:一个使用了MQ的项目，如果连这个问题都没有考虑过，就把MQ引进去了，那就给自己的项目带来了风险。我们引入一个技术，要对这个技术的弊端有充分的认识，才能做好预防。要记住，不要给公司挖坑！</p>
<p><strong>回答</strong>:回答也很容易，从以下两个个角度来答</p>
<ul>
<li><strong>系统可用性降低</strong>:你想啊，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低</li>
<li><strong>系统复杂性增加</strong>:要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。</li>
</ul>
<p>但是，我们该用还是要用的。</p>
<h2 id="3、消息队列如何选型"><a href="#3、消息队列如何选型" class="headerlink" title="3、消息队列如何选型?"></a>3、消息队列如何选型?</h2><p>先说一下，博主只会ActiveMQ,RabbitMQ,RocketMQ,Kafka，对什么ZeroMQ等其他MQ没啥理解，因此只能基于这四种MQ给出回答。</p>
<p><strong>分析</strong>:既然在项目中用了MQ，肯定事先要对业界流行的MQ进行调研，如果连每种MQ的优缺点都没了解清楚，就拍脑袋依据喜好，用了某种MQ，还是给项目挖坑。如果面试官问:”你为什么用这种MQ？。”你直接回答”领导决定的。”这种回答就很LOW了。<strong>还是那句话，不要给公司挖坑。</strong></p>
<p><strong>回答</strong>:首先，咱先上<a href="http://activemq.apache.org/" target="_blank" rel="noopener">ActiveMQ的社区</a>，看看该MQ的更新频率:</p>
<pre><code>Apache ActiveMQ 5.15.3 Release
Christopher L. Shannon posted on Feb 12, 2018
Apache ActiveMQ 5.15.2 Released
Christopher L. Shannon posted on Oct 23, 2017
Apache ActiveMQ 5.15.0 Released
Christopher L. Shannon posted on Jul 06, 2017
省略以下记录
...</code></pre><p>我们可以看出，ActiveMq几个月才发一次版本，据说研究重心在他们的下一代产品Apollo。</p>
<p>接下来，我们再去<a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ的社区</a>去看一下,RabbitMQ的更新频率</p>
<pre><code>RabbitMQ 3.7.3 release  30 January 2018
RabbitMQ 3.6.15 release  17 January 2018
RabbitMQ 3.7.2 release23 December 2017
RabbitMQ 3.7.1 release21 December 2017
省略以下记录
...</code></pre><p>我们可以看出，RabbitMQ版本发布比ActiveMq频繁很多。至于RocketMQ和kafka就不带大家看了，总之也比ActiveMQ活跃的多。详情，可自行查阅。<br>再来一个性能对比表</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">ActiveMQ</th>
<th align="center">RabbitMQ</th>
<th align="center">RocketMQ</th>
<th align="center">kafka</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开发语言</td>
<td align="center">java</td>
<td align="center">erlang</td>
<td align="center">java</td>
<td align="center">scala</td>
</tr>
<tr>
<td align="center">单机吞吐量</td>
<td align="center">万级</td>
<td align="center">万级</td>
<td align="center">10万级</td>
<td align="center">10万级</td>
</tr>
<tr>
<td align="center">时效性</td>
<td align="center">ms级</td>
<td align="center">us级</td>
<td align="center">ms级</td>
<td align="center">ms级以内</td>
</tr>
<tr>
<td align="center">可用性</td>
<td align="center">高(主从架构)</td>
<td align="center">高(主从架构)</td>
<td align="center">非常高(分布式架构)</td>
<td align="center">非常高(分布式架构)</td>
</tr>
<tr>
<td align="center">功能特性</td>
<td align="center">成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好</td>
<td align="center">基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富</td>
<td align="center">MQ功能比较完备，扩展性佳</td>
<td align="center">只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。</td>
</tr>
</tbody></table>
<p>综合上面的材料得出以下两点:</p>
<p>(1)<strong>中小型软件公司</strong>，建议选RabbitMQ.一方面，erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。正所谓，成也萧何，败也萧何！他的弊端也在这里，虽然RabbitMQ是开源的，然而国内有几个能定制化开发erlang的程序员呢？所幸，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。</p>
<p>不考虑rocketmq和kafka的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以kafka排除。</p>
<p>不考虑rocketmq的原因是，rocketmq是阿里出品，如果阿里放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐。</p>
<p>(2)<strong>大型软件公司</strong>，根据具体使用在rocketMq和kafka之间二选一。一方面，大型软件公司，具备足够的资金搭建分布式环境，也具备足够大的数据量。</p>
<p>针对rocketMQ,大型软件公司也可以抽出人手对rocketMQ进行定制化开发，毕竟国内有能力改JAVA源码的人，还是相当多的。至于kafka，根据业务场景选择，如果有日志采集功能，肯定是首选kafka了。具体该选哪个，看使用场景。</p>
<h2 id="4、如何保证消息队列是高可用的？"><a href="#4、如何保证消息队列是高可用的？" class="headerlink" title="4、如何保证消息队列是高可用的？"></a>4、如何保证消息队列是高可用的？</h2><p><strong>分析</strong>:在第二点说过了，引入消息队列后，系统的可用性下降。在生产中，没人使用单机模式的消息队列。因此，作为一个合格的程序员，应该对消息队列的高可用有很深刻的了解。如果面试的时候，面试官问，你们的消息中间件如何保证高可用的？你的回答只是表明自己只会订阅和发布消息，面试官就会怀疑你是不是只是自己搭着玩，压根没在生产用过。<strong>请做一个爱思考，会思考，懂思考的程序员。</strong></p>
<p><strong>回答</strong>:这问题，其实要对消息队列的集群模式要有深刻了解，才好回答。</p>
<p><strong>以rcoketMQ为例</strong>，他的集群就有多master 模式、多master多slave异步复制模式、多 master多slave同步双写模式。多master多slave模式部署架构图(网上找的,偷个懒，懒得画):</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180603000037.png" alt=""></p>
<p>其实博主第一眼看到这个图，就觉得和kafka好像，只是NameServer集群，在kafka中是用zookeeper代替，都是用来保存和发现master和slave用的。通信过程如下:</p>
<p>Producer 与 NameServer集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Broker Master 建立长连接，且定时向 Broker 发送心跳。Producer 只能将消息发送到 Broker master，但是 Consumer 则不一样，它同时和提供 Topic 服务的 Master 和 Slave建立长连接，既可以从 Broker Master 订阅消息，也可以从 Broker Slave 订阅消息。</p>
<p><strong>那么kafka呢</strong>,为了对比说明直接上kafka的拓补架构图(也是找的，懒得画)</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180603000014.png" alt=""></p>
<p>如上图所示，一个典型的Kafka集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p>
<p><strong>至于rabbitMQ</strong>,也有普通集群和镜像集群模式，自行去了解，比较简单，两小时即懂。</p>
<p>要求，在回答高可用的问题时，应该能逻辑清晰的画出自己的MQ集群架构或清晰的叙述出来。</p>
<h2 id="5、如何保证消息不被重复消费？"><a href="#5、如何保证消息不被重复消费？" class="headerlink" title="5、如何保证消息不被重复消费？"></a>5、如何保证消息不被重复消费？</h2><p><strong>分析</strong>:这个问题其实换一种问法就是，如何保证消息队列的幂等性?这个问题可以认为是消息队列领域的基本问题。换句话来说，是在考察你的设计能力，这个问题的回答可以根据具体的业务场景来答，没有固定的答案。</p>
<p><strong>回答</strong>:先来说一下为什么会造成重复消费?</p>
<p>其实无论是那种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同,例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念，简单说一下(如果还不懂，出门找一个kafka入门到精通教程),就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。<strong>那造成重复消费的原因?</strong>，就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。</p>
<p>  <strong>如何解决?</strong>这个问题针对业务场景来答分以下几点</p>
<ol>
<li>比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。</li>
<li>再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。</li>
<li>如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将<code>&lt;id,message&gt;</code>以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。</li>
</ol>
<h2 id="6、如何保证消费的可靠性传输"><a href="#6、如何保证消费的可靠性传输" class="headerlink" title="6、如何保证消费的可靠性传输?"></a>6、如何保证消费的可靠性传输?</h2><p><strong>分析</strong>:我们在使用消息队列的过程中，应该做到消息不能多消费，也不能少消费。如果无法做到可靠性传输，可能给公司带来千万级别的财产损失。同样的，如果可靠性传输在使用过程中，没有考虑到，这不是给公司挖坑么，你可以拍拍屁股走了，公司损失的钱，谁承担。还是那句话，<strong>认真对待每一个项目，不要给公司挖坑。</strong></p>
<p><strong>回答</strong>:其实这个可靠性传输，每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据</p>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p><strong>(1)生产者丢数据</strong></p>
<p>从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。</p>
<p>transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。</p>
<p>然而缺点就是吞吐量下降了。因此，按照博主的经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。处理Ack和Nack的代码如下所示（说好不上代码的，偷偷上了）:</p>
<pre class=" language-java"><code class="language-java">channel<span class="token punctuation">.</span><span class="token function">addConfirmListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConfirmListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token annotation punctuation">@Override</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleNack</span><span class="token punctuation">(</span><span class="token keyword">long</span> deliveryTag<span class="token punctuation">,</span> <span class="token keyword">boolean</span> multiple<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"nack: deliveryTag = "</span><span class="token operator">+</span>deliveryTag<span class="token operator">+</span><span class="token string">" multiple: "</span><span class="token operator">+</span>multiple<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token annotation punctuation">@Override</span>  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleAck</span><span class="token punctuation">(</span><span class="token keyword">long</span> deliveryTag<span class="token punctuation">,</span> <span class="token keyword">boolean</span> multiple<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>  
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ack: deliveryTag = "</span><span class="token operator">+</span>deliveryTag<span class="token operator">+</span><span class="token string">" multiple: "</span><span class="token operator">+</span>multiple<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre>
<p><strong>(2)消息队列丢数据</strong></p>
<p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p>
<p>那么如何持久化呢，这里顺便说一下吧，其实也很容易，就下面两步</p>
<ol>
<li>将queue的持久化标识durable设置为true,则代表是一个持久的队列</li>
<li>发送消息的时候将deliveryMode=2</li>
</ol>
<p>这样设置以后，rabbitMQ就算挂了，重启后也能恢复数据</p>
<p><strong>(3)消费者丢数据</strong></p>
<p>消费者丢数据一般是因为采用了自动确认消息模式。这种模式下，消费者会自动确认收到信息。这时rahbitMQ会立即将消息删除，这种情况下如果消费者出现异常而没能处理该消息，就会丢失该消息。<br>至于解决方案，采用手动确认消息即可。</p>
<h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><p>这里先引一张kafka Replication的数据流向图</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180602235933.png" alt=""></p>
<p>Producer在发布消息到某个Partition时，先通过ZooKeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少（也即该Partition有多少个Replica），Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader中pull数据。</p>
<p>针对上述情况，得出如下分析</p>
<p><strong>(1)生产者丢数据</strong></p>
<p>在kafka生产中，基本都有一个leader和多个follwer。follwer会去同步leader的信息。因此，为了避免生产者丢数据，做如下两点配置</p>
<ol>
<li>第一个配置要在producer端设置acks=all。这个配置保证了，follwer同步完成后，才认为消息发送成功。</li>
<li>在producer端设置retries=MAX，一旦写入失败，这无限重试</li>
</ol>
<p><strong>(2)消息队列丢数据</strong></p>
<p>针对消息队列丢数据的情况，无外乎就是，数据还没同步，leader就挂了，这时zookpeer会将其他的follwer切换为leader,那数据就丢失了。针对这种情况，应该做两个配置。</p>
<ol>
<li>replication.factor参数，这个值必须大于1，即要求每个partition必须有至少2个副本</li>
<li>min.insync.replicas参数，这个值必须大于1，这个是要求一个leader至少感知到有至少一个follower还跟自己保持联系</li>
</ol>
<p>这两个配置加上上面生产者的配置联合起来用，基本可确保kafka不丢数据</p>
<p><strong>(3)消费者丢数据</strong></p>
<p>这种情况一般是自动提交了offset，然后你处理程序过程中挂了。kafka以为你处理好了。再强调一次offset是干嘛的</p>
<p><strong>offset</strong>：指的是kafka的topic中的每个消费组消费的下标。简单的来说就是一条消息对应一个offset下标，每次消费数据的时候如果提交offset，那么下次消费就会从提交的offset加一那里开始消费。<br>比如一个topic中有100条数据，我消费了50条并且提交了，那么此时的kafka服务端记录提交的offset就是49(offset从0开始)，那么下次消费的时候offset就从50开始消费。</p>
<p>解决方案也很简单，改成手动提交即可。</p>
<h3 id="ActiveMQ和RocketMQ"><a href="#ActiveMQ和RocketMQ" class="headerlink" title="ActiveMQ和RocketMQ"></a>ActiveMQ和RocketMQ</h3><p>大家自行查阅吧</p>
<h2 id="7、如何保证消息的顺序性？"><a href="#7、如何保证消息的顺序性？" class="headerlink" title="7、如何保证消息的顺序性？"></a>7、如何保证消息的顺序性？</h2><p><strong>分析</strong>:其实并非所有的公司都有这种业务需求，但是还是对这个问题要有所复习。</p>
<p><strong>回答</strong>:针对这个问题，通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(kafka中就是partition,rabbitMq中就是queue)。然后只用一个消费者去消费该队列。</p>
<p>有的人会问:<strong>那如果为了吞吐量，有多个消费者去消费怎么办？</strong></p>
<p>这个问题，没有固定回答的套路。比如我们有一个微博的操作，发微博、写评论、删除微博，这三个异步操作。如果是这样一个业务场景，那只要重试就行。比如你一个消费者先执行了写评论的操作，但是这时候，微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行写评论的操作后，再执行，就可以成功。</p>
<p>总之，针对这个问题，我的观点是保证入队有序就行，出队以后的顺序交给消费者自己去保证，没有固定套路。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>写到这里，希望读者把本文提出的这几个问题，经过深刻的准备后，一般来说，能囊括大部分的消息队列的知识点。如果面试官不问这几个问题怎么办，简单，自己把几个问题讲清楚，突出以下自己考虑的全面性。</p>
<p>最后，其实我不太提倡这样突击复习，希望大家打好基本功，<strong>做一个爱思考，懂思考，会思考的程序员。</strong></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>架构</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>分布式</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计的 3 个原则</title>
    <url>/2018/07/10/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%203%20%E4%B8%AA%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>合适原则、简单原则、演化原则，架构设计时遵循这几个原则，有助于做出最好的选择。</p>
<h1 id="合适原则"><a href="#合适原则" class="headerlink" title="合适原则"></a>合适原则</h1><p><strong>合适原则宣言：“合适优于业界领先”。</strong></p>
<p>优秀的技术人员都有很强的技术情结，当他们做方案或者架构时，总想不断地挑战自己，想达到甚至优于业界领先水平是其中一个典型表现，因为这样才能够展现自己的优秀，才能在年终 KPI 绩效总结里面骄傲地写上“设计了 XX 方案，达到了和 Google 相同的技术水平”“XX 方案的性能测试结果大大优于阿里集团的 YY 方案”。</p>
<p>但现实是，大部分这样想和这样做的架构，最后可能都以失败告终！我在互联网行业见过“亿级用户平台”的失败案例，2011 年的时候，某个几个人规模的业务团队，雄心勃勃的提出要做一个和腾讯 QQ（那时候微信还没起来）一拼高下的“亿级用户平台”，最后结果当然是不出所料的失败了。</p>
<p>为什么会这样呢？</p>
<p>再好的梦想，也需要脚踏实地实现！这里的“脚踏实地”主要体现在下面几个方面。</p>
<ol>
<li><p>将军难打无兵之仗</p>
<p> 大公司的分工比较细，一个小系统可能就是一个小组负责，比如说某个通信大厂，做一个 OM 管理系统就有十几个人，阿里的中间件团队有几十个人，而大部分公司，整个研发团队可能就 100 多人，某个业务团队可能就十几个人。十几个人的团队，想做几十个人的团队的事情，而且还要做得更好，不能说绝对不可能，但难度是可想而知的。</p>
<p><strong>没那么多人，却想干那么多活，是失败的第一个主要原因。</strong></p>
</li>
<li><p>罗马不是一天建成的</p>
<p> 业界领先的很多方案，其实并不是一堆天才某个时期灵机一动，然后加班加点就做出来的，而是经过几年时间的发展才逐步完善和初具规模的。阿里中间件团队 2008 年成立，发展到现在已经有十年了。我们只知道他们抗住了多少次“双 11”，做了多少优秀的系统，但经历了什么样的挑战、踩了什么样的坑，只有他们自己知道！这些挑战和踩坑，都是架构设计非常关键的促进因素，单纯靠拍脑袋或者头脑风暴，是不可能和真正实战相比的。</p>
<p> <strong>没有那么多积累，却想一步登天，是失败的第二个主要原因。</strong></p>
</li>
<li><p>冰山下面才是关键</p>
<p> 可能有人认为，业界领先的方案都是天才创造出来的，所以自己也要造一个业界领先的方案，以此来证明自己也是天才。确实有这样的天才，但更多的时候，业界领先的方案其实都是“逼”出来的！简单来说，“业务”发展到一定阶段，量变导致了质变，出现了新的问题，已有的方式已经不能应对这些问题，需要用一种新的方案来解决，通过创新和尝试，才有了业界领先的方案。GFS 为何在 Google 诞生，而不是在 Microsoft 诞生？我认为 Google 有那么庞大的数据是一个主要的因素，而不是因为 Google 的工程师比 Microsoft 的工程师更加聪明。</p>
<p> <strong>没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因。</strong></p>
</li>
</ol>
<p>回到我前面提到的“亿级用户平台”失败的例子，分析一下原因。没有腾讯那么多的人（当然钱差得更多），没有 QQ 那样海量用户的积累，没有 QQ 那样的业务，这个项目失败其实是在一开始就注定的。注意这里的失败不是说系统做不出来，而是系统没有按照最初的目标来实现，上面提到的 3 个失败原因也全占了。</p>
<p>所以，真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。这也是很多 BAT 出来的架构师到了小公司或者创业团队反而做不出成绩的原因，因为没有了大公司的平台、资源、积累，只是生搬硬套大公司的做法，失败的概率非常高。</p>
<h1 id="简单原则"><a href="#简单原则" class="headerlink" title="简单原则"></a>简单原则</h1><p><strong>简单原则宣言：“简单优于复杂”。</strong></p>
<p>软件架构设计是一门技术活。所谓技术活，从历史上看，无论是瑞士的钟表，还是瓦特的蒸汽机；无论是莱特兄弟发明的飞机，还是摩托罗拉发明的手机，无一不是越来越精细、越来越复杂。因此当我们进行架构设计时，会自然而然地想把架构做精美、做复杂，这样才能体现我们的技术实力，也才能够将架构做成一件艺术品。</p>
<p>由于软件架构和建筑架构表面上的相似性，我们也会潜意识地将对建筑的审美观点移植到软件架构上面。我们惊叹于长城的宏伟、泰姬陵的精美、悉尼歌剧院的艺术感、迪拜帆船酒店的豪华感，因此，对于我们自己亲手打造的软件架构，我们也希望它宏伟、精美、艺术、豪华……总之就是不能寒酸、不能简单。</p>
<p>团队的压力有时也会有意无意地促进我们走向复杂的方向，因为大部分人在评价一个方案水平高低的时候，复杂性是其中一个重要的参考指标。例如设计一个主备方案，如果你用心跳来实现，可能大家都认为这太简单了。但如果你引入 ZooKeeper 来做主备决策，可能很多人会认为这个方案更加“高大上”一些，毕竟 ZooKeeper 使用的是 ZAB 协议，而 ZAB 协议本身就很复杂。其实，真正理解 ZAB 协议的人很少（我也不懂），但并不妨碍我们都知道 ZAB 协议很优秀。</p>
<p>刚才我聊的这些原因，会在潜意识层面促使初出茅庐的架构师，不自觉地追求架构的复杂性。然而，“复杂”在制造领域代表先进，在建筑领域代表领先，但在软件领域，却恰恰相反，代表的是“问题”。</p>
<p>软件领域的复杂性体现在两个方面：</p>
<ol>
<li><p>结构的复杂性</p>
<p> 结构复杂的系统几乎毫无例外具备两个特点：</p>
<ul>
<li>组成复杂系统的组件数量更多；</li>
<li>同时这些组件之间的关系也更加复杂。</li>
</ul>
</li>
</ol>
<p>我以图形的方式来说明复杂性：<br>2 个组件组成的系统：</p>
<p>3 个组件组成的系统：</p>
<p>4 个组件组成的系统：</p>
<p>5 个组件组成的系统：</p>
<p>结构上的复杂性存在的第一个问题是，<strong>组件越多，就越有可能其中某个组件出现故障</strong>，从而导致系统故障。这个概率可以算出来，假设组件的故障率是 10%（有 10% 的时间不可用），那么有 3 个组件的系统可用性是（1-10%）×（1-10%）×（1-10%）= 72.9%，有 5 个组件的系统可用性是（1-10%）×（1-10%）×（1-10%）×（1-10%）×（1-10%）=59%，两者的可用性相差 13%。</p>
<p>结构上的复杂性存在的第二个问题是，<strong>某个组件改动，会影响关联的所有组件</strong>，这些被影响的组件同样会继续递归影响更多的组件。还以上面图中 5 个组件组成的系统为例，组件 A 修改或者异常时，会影响组件 B/C/E，D 又会影响 E。这个问题会影响整个系统的开发效率，因为一旦变更涉及外部系统，需要协调各方统一进行方案评估、资源协调、上线配合。</p>
<p>结构上的复杂性存在的第三个问题是，<strong>定位一个复杂系统中的问题总是比简单系统更加困难</strong>。首先是组件多，每个组件都有嫌疑，因此要逐一排查；其次组件间的关系复杂，有可能表现故障的组件并不是真正问题的根源。</p>
<ol start="2">
<li>逻辑的复杂性</li>
</ol>
<p>意识到结构的复杂性后，我们的第一反应可能就是“降低组件数量”，毕竟组件数量越少，系统结构越简。最简单的结构当然就是整个系统只有一个组件，即系统本身，所有的功能和逻辑都在这一个组件中实现。</p>
<p>不幸的是，这样做是行不通的，原因在于除了结构的复杂性，还有逻辑的复杂性，即如果某个组件的逻辑太复杂，一样会带来各种问题。</p>
<p>逻辑复杂的组件，一个典型特征就是单个组件承担了太多的功能。以电商业务为例，常见的功能有：商品管理、商品搜索、商品展示、订单管理、用户管理、支付、发货、客服……把这些功能全部在一个组件中实现，就是典型的逻辑复杂性。</p>
<p>逻辑复杂几乎会导致软件工程的每个环节都有问题，假设现在淘宝将这些功能全部在单一的组件中实现，可以想象一下这个恐怖的场景：</p>
<ul>
<li>系统会很庞大，可能是上百万、上千万的代码规模，“clone”一次代码要 30 分钟。</li>
<li>几十、上百人维护这一套代码，某个“菜鸟”不小心改了一行代码，导致整站崩溃。</li>
<li>需求像雪片般飞来，为了应对，开几十个代码分支，然后各种分支合并、各种分支覆盖。</li>
<li>产品、研发、测试、项目管理不停地开会讨论版本计划，协调资源，解决冲突。</li>
<li>版本太多，每天都要上线几十个版本，系统每隔 1 个小时重启一次。</li>
<li>线上运行出现故障，几十个人扑上去定位和处理，一间小黑屋都装不下所有人，整个办公区闹翻天。</li>
<li>……</li>
</ul>
<p>不用多说，肯定谁都无法忍受这样的场景。</p>
<p>但是，为什么复杂的电路就意味更强大的功能，而复杂的架构却有很多问题呢？根本原因在于电路一旦设计好后进入生产，就不会再变，复杂性只是在设计时带来影响；而一个软件系统在投入使用后，后续还有源源不断的需求要实现，因此要不断地修改系统，复杂性在整个系统生命周期中都有很大影响。</p>
<p>功能复杂的组件，另外一个典型特征就是采用了复杂的算法。复杂算法导致的问题主要是难以理解，进而导致难以实现、难以修改，并且出了问题难以快速解决。</p>
<p>以 ZooKeeper 为例，ZooKeeper 本身的功能主要就是选举，为了实现分布式下的选举，采用了 ZAB 协议，所以 ZooKeeper 功能虽然相对简单，但系统实现却比较复杂。相比之下，etcd 就要简单一些，因为 etcd 采用的是 Raft 算法，相比 ZAB 协议，Raft 算法更加容易理解，更加容易实现。</p>
<p>综合前面的分析，我们可以看到，无论是结构的复杂性，还是逻辑的复杂性，都会存在各种问题，所以架构设计时如果简单的方案和复杂的方案都可以满足需求，最好选择简单的方案。《UNIX 编程艺术》总结的 KISS（Keep It Simple, Stupid!）原则一样适应于架构设计。</p>
<h1 id="演化原则"><a href="#演化原则" class="headerlink" title="演化原则"></a>演化原则</h1><p><strong>演化原则宣言：“演化优于一步到位”。</strong></p>
<p>软件架构从字面意思理解和建筑结构非常类似，事实上“架构”这个词就是建筑领域的专业名词，维基百科对“软件架构”的定义中有一段话描述了这种相似性：</p>
<p>从和目的、主题、材料和结构的联系上来说，软件架构可以和建筑物的架构相比拟。</p>
<p>例如，软件架构描述的是一个软件系统的结构，包括各个模块，以及这些模块的关系；建筑架构描述的是一幢建筑的结构，包括各个部件，以及这些部件如何有机地组成成一幢完美的建筑。</p>
<p>然而，字面意思上的相似性却掩盖了一个本质上的差异：建筑一旦完成（甚至一旦开建）就不可再变，而软件却需要根据业务的发展不断地变化！</p>
<p>古埃及的吉萨大金字塔，4000 多年前完成的，到现在还是当初的架构。</p>
<p>中国的明长城，600 多年前完成的，现在保存下来的长城还是当年的结构。</p>
<p>美国白宫，1800 年建成，200 年来进行了几次扩展，但整体结构并无变化，只是在旁边的空地扩建或者改造内部的布局。</p>
<p>对比一下，我们来看看软件架构。</p>
<p>Windows 系统的发展历史：</p>
<p>如果对比 Windows 8 的架构和 Windows 1.0 的架构，就会发现它们其实是两个不同的系统了！<br>Android 的发展历史：</p>
<p>同样，Android 6.0 和 Android 1.6 的差异也很大。</p>
<p>对于建筑来说，永恒是主题；而对于软件来说，变化才是主题。软件架构需要根据业务的发展而不断变化。设计 Windows 和 Android 的人都是顶尖的天才，即便如此，他们也不可能在 1985 年设计出 Windows 8，不可能在 2009 年设计出 Android 6.0。</p>
<p>如果没有把握“软件架构需要根据业务发展不断变化”这个本质，在做架构设计的时候就很容易陷入一个误区：试图一步到位设计一个软件架构，期望不管业务如何变化，架构都稳如磐石。</p>
<p>为了实现这样的目标，要么照搬业界大公司公开发表的方案；要么投入庞大的资源和时间来做各种各样的预测、分析、设计。无论哪种做法，后果都很明显：投入巨大，落地遥遥无期。更让人沮丧的是，就算跌跌撞撞拼死拼活终于落地，却发现很多预测和分析都是不靠谱的。</p>
<p>考虑到软件架构需要根据业务发展不断变化这个本质特点，软件架构设计其实更加类似于大自然“设计”一个生物，通过演化让生物适应环境，逐步变得更加强大：</p>
<p>首先，生物要适应当时的环境。</p>
<p>其次，生物需要不断地繁殖，将有利的基因传递下去，将不利的基因剔除或者修复。</p>
<p>第三，当环境变化时，生物要能够快速改变以适应环境变化；如果生物无法调整就被自然淘汰；新的生物会保留一部分原来被淘汰生物的基因。</p>
<p>软件架构设计同样是类似的过程：</p>
<p>首先，设计出来的架构要满足当时的业务需要。</p>
<p>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。</p>
<p>第三，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。</p>
<p>架构师在进行架构设计时需要牢记这个原则，时刻提醒自己不要贪大求全，或者盲目照搬大公司的做法。应该认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构。</p>
<p>即使是大公司的团队，在设计一个新系统的架构时，也需要遵循演化的原则，而不应该认为团队人员多、资源多，不管什么系统上来就要一步到位，因为业务的发展和变化是很快的，不管多牛的团队，也不可能完美预测所有的业务发展和变化路径。</p>
<h1 id="本节总结"><a href="#本节总结" class="headerlink" title="本节总结"></a>本节总结</h1><p>架构即决策。架构需要面向业务需求，并在各种资源（人、财、物、时、事）约束条件下去做权衡、取舍。而决策就会存在不确定性。采用一些高屋建瓴的设计原则有助于去消除不确定，去逼近解决问题的最优解。</p>
<ol>
<li><p>合适原则</p>
<p> 架构无优劣，但存合适性。“汝之蜜糖，吾之砒霜”；架构一定要匹配企业所在的业务阶段；不要面向简历去设计架构，高大上的架构不等于适用；削足适履与打肿充胖都不符合合适原则；所谓合适，一定要匹配业务所处阶段，能够合理地将资源整合在一起并发挥出最大功效，并能够快速落地。</p>
</li>
<li><p>简单原则</p>
<p> “我没有时间写一封短信，所以只好写一封长信”。其实，简单比复杂更加困难。面对系统结构、业务逻辑和复杂性，我们可以编写出复杂的系统，但在软件领域，复杂代表的是“问题”。架构设计时如果简单的方案和复杂的方案都可以满足需求，最好选择简单的方案。但是，事实上，当软件系统变得太复杂后，就会有人换一个思路进行重构、升级，将它重新变得简单，这也是软件开发的大趋势。 简单原则是一个朴素且伟大的原则，Google的MapReduce系统就采用了分而治之的思想，而背后就是将复杂问题转化为简单问题的典型案例。</p>
</li>
<li><p>演化原则</p>
<p> 大到人类社会、自然生物，小到一个细胞，似乎都遵循这一普世原则，软件架构也不例外。业务在发展、技术在创新、外部环境在变化，这一切都是在告诫架构师不要贪大求全，或者盲目照搬大公司的做法。应该认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构。怀胎需要十月，早一月或晚一月都很危险。</p>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 web 网站架构演变过程</title>
    <url>/2018/09/10/%E6%9E%B6%E6%9E%84/%E6%B5%85%E8%B0%88web%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们以 javaweb 为例，来搭建一个简单的电商系统，看看这个系统可以如何一步步演变。</p>
<p>该系统具备的功能： </p>
<ul>
<li>用户模块：用户注册和管理</li>
<li>商品模块：商品展示和管理</li>
<li>交易模块：创建交易和管理</li>
</ul>
<h1 id="阶段一、单机构建网站"><a href="#阶段一、单机构建网站" class="headerlink" title="阶段一、单机构建网站"></a>阶段一、单机构建网站</h1><p>网站的初期，我们经常会在单机上跑我们所有的程序和软件。此时我们使用一个容器，如 tomcat 、 jetty 、 jboos ，然后直接使用 JSP / servlet 技术，或者使用一些开源的框架如 maven + spring + struct + hibernate 、 maven + spring + springmvc + mybatis ；最后再选择一个数据库管理系统来存储数据，如 mysql 、 sqlserver 、 oracle ，然后通过 JDBC 进行数据库的连接和操作。</p>
<p>把以上的所有软件都装载同一台机器上，应用跑起来了，也算是一个小系统了。此时系统结果如下：<br><img src="http://ot0en8caw.bkt.clouddn.com/20180331123508.png" alt="单机构建网站"></p>
<h1 id="阶段二、应用服务器与数据库分离"><a href="#阶段二、应用服务器与数据库分离" class="headerlink" title="阶段二、应用服务器与数据库分离"></a>阶段二、应用服务器与数据库分离</h1><p>随着网站的上线，访问量逐步上升，服务器的负载慢慢提高，在服务器还没有超载的时候，我们应该就要做好准备，提升网站的负载能力。假如我们代码层面已难以优化，在不提高单台机器的性能的情况下，增加机器是一个不错的方式，不仅可以有效地提高系统的负载能力，而且性价比高。</p>
<p>增加的机器用来做什么呢？此时我们可以把数据库， web 服务器拆分开来，这样不仅提高了单台机器的负载能力，也提高了容灾能力。</p>
<p>应用服务器与数据库分开后的架构如下图所示：</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180331123552.png" alt="应用服务器与数据库分离"></p>
<h1 id="阶段三、应用服务器集群"><a href="#阶段三、应用服务器集群" class="headerlink" title="阶段三、应用服务器集群"></a>阶段三、应用服务器集群</h1><p>随着访问量继续增加，单台应用服务器已经无法满足需求了。在假设数据库服务器没有压力的情况下，我们可以把应用服务器从一台变成了两台甚至多台，把用户的请求分散到不同的服务器中，从而提高负载能力。多台应用服务器之间没有直接的交互，他们都是依赖数据库各自对外提供服务。著名的做故障切换的软件有 keepalived ， keepalived 是一个类似于 layer3、4、7 交换机制的软件，他不是某个具体软件故障切换的专属品，而是可以适用于各种软件的一款产品。 keepalived 配合上 ipvsadm 又可以做负载均衡，可谓是神器。</p>
<p>我们以增加了一台应用服务器为例，增加后的系统结构图如下：</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180331123712.png" alt="应用服务器集群 01"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>系统演变到这里，将会出现下面四个问题：</p>
<ol>
<li>用户的请求由谁来转发到到具体的应用服务器</li>
<li>有什么转发的算法</li>
<li>应用服务器如何返回用户的请求</li>
<li>用户如果每次访问到的服务器不一样，那么如何维护 session 的一致性</li>
</ol>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>我们来看看解决问题的方案：</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>第一个问题即是负载均衡的问题，一般有 5 种解决方案：</p>
<ol>
<li><p>*<em>http 重定向 *</em>。 HTTP 重定向就是应用层的请求转发。用户的请求其实已经到了 HTTP 重定向负载均衡服务器，服务器根据算法要求用户重定向，用户收到重定向请求后，再次请求真正的集群</p>
<ul>
<li><strong>优点</strong>：简单。</li>
<li><strong>缺点</strong>：性能较差。</li>
</ul>
</li>
<li><p>*<em>DNS 域名解析负载均衡 *</em>。 DNS 域名解析负载均衡就是在用户请求 DNS 服务器，获取域名对应的 IP 地址时， DNS 服务器直接给出负载均衡后的服务器 IP 。</p>
<ul>
<li><strong>优点</strong>：交给 DNS ，不用我们去维护负载均衡服务器。</li>
<li><strong>缺点</strong>：当一个应用服务器挂了，不能及时通知 DNS ，而且 DNS 负载均衡的控制权在域名服务商那里，网站无法做更多的改善和更强大的管理。</li>
</ul>
</li>
<li><p><strong>反向代理服务器</strong>。在用户的请求到达反向代理服务器时（已经到达网站机房），由反向代理服务器根据算法转发到具体的服务器。常用的 apache ， nginx 都可以充当反向代理服务器。</p>
<ul>
<li><strong>优点</strong>：部署简单。</li>
<li><strong>缺点</strong>：代理服务器可能成为性能的瓶颈，特别是一次上传大文件。</li>
</ul>
</li>
<li><p><strong>IP 层负载均衡</strong>。在请求到达负载均衡器后，负载均衡器通过修改请求的目的 IP 地址，从而实现请求的转发，做到负载均衡。</p>
<ul>
<li><strong>优点</strong>：性能更好。</li>
<li><strong>缺点</strong>：负载均衡器的宽带成为瓶颈。</li>
</ul>
</li>
<li><p><strong>数据链路层负载均衡</strong>。在请求到达负载均衡器后，负载均衡器通过修改请求的 mac 地址，从而做到负载均衡，与 IP 负载均衡不一样的是，当请求访问完服务器之后，直接返回客户。而无需再经过负载均衡器。</p>
</li>
</ol>
<h3 id="集群调度算法"><a href="#集群调度算法" class="headerlink" title="集群调度算法"></a>集群调度算法</h3><p>第二个问题即是集群调度算法问题，常见的调度算法有 10 种。</p>
<ol>
<li><p><strong>rr 轮询调度算法</strong>。顾名思义，轮询分发请求。</p>
<ul>
<li>优点：实现简单</li>
<li>缺点：不考虑每台服务器的处理能力</li>
</ul>
</li>
<li><p><strong>wrr 加权调度算法</strong>。我们给每个服务器设置权值 weight ，负载均衡调度器根据权值调度服务器，服务器被调用的次数跟权值成正比。</p>
<ul>
<li>优点：考虑了服务器处理能力的不同</li>
</ul>
</li>
<li><p><strong>sh 原地址散列</strong>：提取用户 IP ，根据散列函数得出一个 key ，再根据静态映射表，查处对应的 value ，即目标服务器 IP 。过目标机器超负荷，则返回空。</p>
</li>
<li><p><strong>dh 目标地址散列</strong>：同上，只是现在提取的是目标地址的 IP 来做哈希。</p>
<ul>
<li>优点：以上两种算法的都能实现同一个用户访问同一个服务器。</li>
</ul>
</li>
<li><p><strong>lc 最少连接</strong>。优先把请求转发给连接数少的服务器。</p>
<ul>
<li>优点：使得集群中各个服务器的负载更加均匀。</li>
</ul>
</li>
<li><p><strong>wlc 加权最少连接</strong>。在 lc 的基础上，为每台服务器加上权值。算法为：（ 活动连接数 * 256 + 非活动连接数 ）÷ 权重 ，计算出来的值小的服务器优先被选择。</p>
<ul>
<li>优点：可以根据服务器的能力分配请求。</li>
</ul>
</li>
<li><p><strong>sed 最短期望延迟</strong>。其实 sed 跟 wlc 类似，区别是不考虑非活动连接数。算法为：（ 活动连接数 + 1 ) * 256 ÷ 权重，同样计算出来的值小的服务器优先被选择。</p>
</li>
<li><p><strong>nq 永不排队</strong>。改进的 sed 算法。我们想一下什么情况下才能“永不排队”，那就是服务器的连接数为 0 的时候，那么假如有服务器连接数为 0 ，均衡器直接把请求转发给它，无需经过 sed 的计算。</p>
</li>
<li><p><strong>LBLC 基于局部性的最少连接</strong>。均衡器根据请求的目的 IP 地址，找出该 IP 地址最近被使用的服务器，把请求转发之，若该服务器超载，最采用最少连接数算法。</p>
</li>
<li><p><strong>LBLCR 带复制的基于局部性的最少连接</strong>。均衡器根据请求的目的 IP 地址，找出该 IP 地址最近使用的“服务器组”，注意，并不是具体某个服务器，然后采用最少连接数从该组中挑出具体的某台服务器出来，把请求转发之。若该服务器超载，那么根据最少连接数算法，在集群的非本服务器组的服务器中，找出一台服务器出来，加入本服务器组，然后把请求转发之。</p>
</li>
</ol>
<h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>第三个问题是集群模式问题，一般 3 种解决方案：</p>
<ol>
<li><p><strong>NAT</strong>：负载均衡器接收用户的请求，转发给具体服务器，服务器处理完请求返回给均衡器，均衡器再重新返回给用户。</p>
</li>
<li><p><strong>DR</strong>：负载均衡器接收用户的请求，转发给具体服务器，服务器出来玩请求后直接返回给用户。需要系统支持 IP Tunneling 协议，难以跨平台。</p>
</li>
<li><p><strong>TUN</strong>：同上，但无需 IP Tunneling 协议，跨平台性好，大部分系统都可以支持。</p>
</li>
</ol>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>第四个问题是 <strong>session</strong> 问题，一般有 4 种解决方案：</p>
<ol>
<li><p><strong>Session Sticky</strong>。 session sticky 就是把同一个用户在某一个会话中的请求，都分配到固定的某一台服务器中，这样我们就不需要解决跨服务器的 session 问题了，常见的算法有 ip_hash 法，即上面提到的两种散列算法。</p>
<ul>
<li>优点：实现简单。</li>
<li>缺点：应用服务器重启则 session 消失。</li>
</ul>
</li>
<li><p><strong>Session Replication</strong>。 session replication 就是在集群中复制 session ，使得每个服务器都保存有全部用户的 session 数据。</p>
<ul>
<li>优点：减轻负载均衡服务器的压力，不需要要实现 ip_hasp 算法来转发请求。</li>
<li>缺点：复制时宽带开销大，访问量大的话 session 占用内存大且浪费。</li>
</ul>
</li>
<li><p>*<em>Session 数据集中存储 *</em>： session 数据集中存储就是利用数据库来存储 session 数据，实现了 session 和应用服务器的解耦。</p>
<ul>
<li>优点：相比 session replication 的方案，集群间对于宽带和内存的压力减少了很多。</li>
<li>缺点：需要维护存储 session 的数据库。</li>
</ul>
</li>
<li><p><strong>Cookie Base</strong>： cookie base 就是把 session 存在 cookie 中，有浏览器来告诉应用服务器我的 session 是什么，同样实现了 session 和应用服务器的解耦。</p>
<ul>
<li>优点：实现简单，基本免维护。</li>
<li>缺点： cookie 长度限制，安全性低，宽带消耗。</li>
</ul>
</li>
</ol>
<p><strong>值得一提的是</strong>：</p>
<p>nginx 目前支持的负载均衡算法有 wrr 、 sh （支持一致性哈希）、 fair （本人觉得可以归结为 lc ）。但 nginx 作为均衡器的话，还可以一同作为静态资源服务器。</p>
<p>keepalived + ipvsadm 比较强大，目前支持的算法有： rr 、 wrr 、 lc 、 wlc 、 lblc 、 sh 、 dh</p>
<p>keepalived 支持集群模式有： NAT 、 DR 、 TUN</p>
<p>nginx 本身并没有提供 session 同步的解决方案，而 apache 则提供了 session 共享的支持。</p>
<p>好了，解决了以上的问题之后，系统的结构如下：</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180331123750.png" alt="应用服务器集群 02"></p>
<h1 id="阶段四、数据库读写分离化"><a href="#阶段四、数据库读写分离化" class="headerlink" title="阶段四、数据库读写分离化"></a>阶段四、数据库读写分离化</h1><p>上面我们总是假设数据库负载正常，但随着访问量的的提高，数据库的负载也在慢慢增大。那么可能有人马上就想到跟应用服务器一样，把数据库一份为二再负载均衡即可。但对于数据库来说，并没有那么简单。假如我们简单的把数据库一分为二，然后对于数据库的请求，分别负载到 A 机器和 B 机器，那么显而易见会造成两台数据库数据不统一的问题。那么对于这种情况，我们可以先考虑使用读写分离的方式。</p>
<p>读写分离后的数据库系统结构如下：</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180331123812.png" alt="数据库读写分离化"></p>
<p>** 这个结构变化后也会带来两个问题 **：</p>
<ol>
<li>主从数据库之间数据同步问题</li>
<li>应用对于数据源的选择问题
　</li>
</ol>
<p>** 解决问题方案 **：</p>
<ol>
<li>我们可以使用 MYSQL 自带的 master + slave 的方式实现主从复制。</li>
<li>采用第三方数据库中间件，例如 mycat 。 mycat 是从 cobar 发展而来的，而 cobar 是阿里开源的数据库中间件，后来停止开发。 mycat 是国内比较好的 mysql 开源数据库分库分表中间件。</li>
</ol>
<h1 id="阶段五、用搜索引擎缓解读库的压力"><a href="#阶段五、用搜索引擎缓解读库的压力" class="headerlink" title="阶段五、用搜索引擎缓解读库的压力"></a>阶段五、用搜索引擎缓解读库的压力</h1><p>数据库做读库的话，常常对模糊查找力不从心，即使做了读写分离，这个问题还未能解决。以我们所举的交易网站为例，发布的商品存储在数据库中，用户最常使用的功能就是查找商品，尤其是根据商品的标题来查找对应的商品。对于这种需求，一般我们都是通过 like 功能来实现的，但是这种方式的代价非常大。此时我们可以使用搜索引擎的倒排索引来完成。<br>** 搜索引擎具有以下优点 **：</p>
<ul>
<li>它能够大大提高查询速度。</li>
</ul>
<p>** 引入搜索引擎后也会带来以下的开销 **：</p>
<ul>
<li><p>带来大量的维护工作，我们需要自己实现索引的构建过程，设计全量 / 增加的构建方式来应对非实时与实时的查询需求。</p>
</li>
<li><p>需要维护搜索引擎集群</p>
<p>搜索引擎并不能替代数据库，他解决了某些场景下的 “读” 的问题，是否引入搜索引擎，需要综合考虑整个系统的需求。引入搜索引擎后的系统结构如下：</p>
</li>
</ul>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180331123824.png" alt="用搜索引擎缓解读库的压力"></p>
<h1 id="阶段六、用缓存缓解读库的压力"><a href="#阶段六、用缓存缓解读库的压力" class="headerlink" title="阶段六、用缓存缓解读库的压力"></a>阶段六、用缓存缓解读库的压力</h1><ol>
<li><p>后台应用层和数据库层的缓存</p>
<p> 随着访问量的增加，逐渐出现了许多用户访问同一部分内容的情况，对于这些比较热门的内容，没必要每次都从数据库读取。我们可以使用缓存技术，例如可以使用 google 的开源缓存技术 guava 或者使用 memcacahe 作为应用层的缓存，也可以使用 redis 作为数据库层的缓存。</p>
<p> 另外，在某些场景下，关系型数据库并不是很适合，例如我想做一个 “每日输入密码错误次数限制” 的功能，思路大概是在用户登录时，如果登录错误，则记录下该用户的 IP 和错误次数，那么这个数据要放在哪里呢？假如放在内存中，那么显然会占用太大的内容；假如放在关系型数据库中，那么既要建立数据库表，还要简历对应的 java bean ，还要写 SQL 等等。而分析一下我们要存储的数据，无非就是类似 {ip:errorNumber} 这样的 key : value 数据。对于这种数据，我们可以用 NOSQL 数据库来代替传统的关系型数据库。</p>
</li>
<li><p>页面缓存</p>
<p> 除了数据缓存，还有页面缓存。比如使用 HTML5 的 localstroage 或者 cookie。</p>
</li>
</ol>
<ul>
<li><strong>优点</strong>：<ul>
<li>减轻数据库的压力</li>
<li>大幅度提高访问速度</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>需要维护缓存服务器</li>
<li>提高了编码的复杂性</li>
</ul>
</li>
</ul>
<p><strong>值得一提的是</strong>：<br>缓存集群的调度算法不同与上面提到的应用服务器和数据库。最好采用“一致性哈希算法”，这样才能提高命中率。这个就不展开讲了，有兴趣的可以查阅相关资料。</p>
<p><strong>加入缓存后的结构</strong>：</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180331123903.png" alt="加入缓存后的结构"></p>
<h1 id="阶段七、数据库水平拆分与垂直拆分"><a href="#阶段七、数据库水平拆分与垂直拆分" class="headerlink" title="阶段七、数据库水平拆分与垂直拆分"></a>阶段七、数据库水平拆分与垂直拆分</h1><p>我们的网站演进到现在，交易、商品、用户的数据都还在同一个数据库中。尽管采取了增加缓存，读写分离的方式，但随着数据库的压力继续增加，数据库的瓶颈越来越突出，此时，我们可以有数据垂直拆分和水平拆分两种选择。</p>
<h2 id="数据垂直拆分"><a href="#数据垂直拆分" class="headerlink" title="数据垂直拆分"></a>数据垂直拆分</h2><p>垂直拆分的意思是把数据库中不同的业务数据拆分道不同的数据库中，结合现在的例子，就是把交易、商品、用户的数据分开。</p>
<ul>
<li><p><strong>优点</strong>：<br>解决了原来把所有业务放在一个数据库中的压力问题。<br>可以根据业务的特点进行更多的优化</p>
</li>
<li><p><strong>缺点</strong>：<br>需要维护多个数据库</p>
</li>
<li><p><strong>问题</strong>：<br>需要考虑原来跨业务的事务<br>跨数据库的 join</p>
</li>
<li><p><strong>解决问题方案</strong>：<br>我们应该在应用层尽量避免跨数据库的事物，如果非要跨数据库，尽量在代码中控制。<br>我们可以通过第三方应用来解决，如上面提到的 mycat ， mycat 提供了丰富的跨库 join 方案，详情可参考 mycat 官方文档。</p>
</li>
</ul>
<p>垂直拆分后的结构如下：<br><img src="http://ot0en8caw.bkt.clouddn.com/20180331123918.png" alt="垂直拆分后"></p>
<h2 id="数据水平拆分"><a href="#数据水平拆分" class="headerlink" title="数据水平拆分"></a>数据水平拆分</h2><p>数据水平拆分就是把同一个表中的数据拆分到两个甚至多个数据库中。产生数据水平拆分的原因是某个业务的数据量或者更新量到达了单个数据库的瓶颈，这时就可以把这个表拆分到两个或更多个数据库中。</p>
<ul>
<li><p><strong>优点</strong>：<br>如果我们能客服以上问题，那么我们将能够很好地对数据量及写入量增长的情况。</p>
</li>
<li><p><strong>问题</strong>：<br>访问用户信息的应用系统需要解决 SQL 路由的问题，因为现在用户信息分在了两个数据库中，需要在进行数据操作时了解需要操作的数据在哪里。<br>主键的处理也变得不同，例如原来自增字段，现在不能简单地继续使用了。<br>如果需要分页，就麻烦了。</p>
</li>
<li><p><strong>解决问题方案</strong>：<br>我们还是可以通过可以解决第三方中间件，如 mycat。mycat 可以通过 SQL 解析模块对我们的 SQL 进行解析，再根据我们的配置，把请求转发到具体的某个数据库。<br>我们可以通过 UUID 保证唯一或自定义 ID 方案来解决。<br>mycat 也提供了丰富的分页查询方案，比如先从每个数据库做分页查询，再合并数据做一次分页查询等等。<br>数据水平拆分后的结构：</p>
</li>
</ul>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180331123928.png" alt="水平拆分后"></p>
<h1 id="阶段八、应用的拆分"><a href="#阶段八、应用的拆分" class="headerlink" title="阶段八、应用的拆分"></a>阶段八、应用的拆分</h1><h2 id="拆分应用"><a href="#拆分应用" class="headerlink" title="拆分应用"></a>拆分应用</h2><p>随着业务的发展，业务越来越多，应用越来越大。我们需要考虑如何避免让应用越来越臃肿。这就需要把应用拆开，从一个应用变为俩个甚至更多。还是以我们上面的例子，我们可以把用户、商品、交易拆分开。变成 “用户、商品” 和“用户，交易”两个子系统。　　</p>
<p>拆分后的结构：<br><img src="http://ot0en8caw.bkt.clouddn.com/20180331123946.png" alt=""></p>
<ul>
<li><p><strong>问题</strong>：<br>这样拆分后，可能会有一些相同的代码，如用户相关的代码，商品和交易都需要用户信息，所以在两个系统中都保留差不多的操作用户信息的代码。如何保证这些代码可以复用是一个需要解决的问题。</p>
</li>
<li><p><strong>解决问题</strong>：<br>通过走服务化的路线来解决</p>
</li>
</ul>
<h2 id="走服务化的道路"><a href="#走服务化的道路" class="headerlink" title="走服务化的道路"></a>走服务化的道路</h2><p>为了解决上面拆分应用后所出现的问题，我们把公共的服务拆分出来，形成一种服务化的模式，简称 SOA。</p>
<p>采用服务化之后的系统结构：<br><img src="http://ot0en8caw.bkt.clouddn.com/20180331123955.png" alt=""></p>
<ul>
<li><p><strong>优点</strong>：<br>相同的代码不会散落在不同的应用中了，这些实现放在了各个服务中心，使代码得到更好的维护。<br>我们把对数据库的交互放在了各个服务中心，让”前端“的 web 应用更注重与浏览器交互的工作。</p>
</li>
<li><p><strong>问题</strong>：<br>如何进行远程的服务调用</p>
</li>
<li><p><strong>解决方法</strong>：<br>我们可以通过下面的引入消息中间件来解决</p>
</li>
</ul>
<h1 id="阶段九、引入消息中间件"><a href="#阶段九、引入消息中间件" class="headerlink" title="阶段九、引入消息中间件"></a>阶段九、引入消息中间件</h1><p>随着网站的继续发展，我们的系统中可能出现不同语言开发的子模块和部署在不同平台的子系统。此时我们需要一个平台来传递可靠的，与平台和语言无关的数据，并且能够把负载均衡透明化，能在调用过程中收集调用数据并分析之，推测出网站的访问增长率等等一系列需求，对于网站应该如何成长做出预测。开源消息中间件有阿里的 dubbo，可以搭配 Google 开源的分布式程序协调服务 zookeeper 实现服务器的注册与发现。</p>
<p>引入消息中间件后的结构：</p>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180331124003.png" alt=""></p>
<h1 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h1><p>以上的演变过程只是一个例子，并不适合所有的网站，实际中网站演进过程与自身业务和不同遇到的问题有密切的关系，没有固定的模式。只有认真的分析和不断地探究，才能发现适合自己网站的架构。</p>
<p>本文有什么说错的地方，希望大家指出，让我好改正过来，多谢。<br>本文转载自</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题--微服务--小米归纳</title>
    <url>/2019/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a>未归类</h1><h2 id="您对微服务有何了解？"><a href="#您对微服务有何了解？" class="headerlink" title="您对微服务有何了解？"></a>您对微服务有何了解？</h2><p><strong>微服务</strong>，又称微服务<strong>架构</strong>，是一种架构风格，它将应用程序构建为以<strong>业务领域</strong>为模型的小型自治服务集合  。</p>
<p>通俗地说，你必须看到蜜蜂如何通过对齐六角形蜡细胞来构建它们的蜂窝状物。他们最初从使用各种材料的小部分开始，并继续从中构建一个大型蜂箱。这些细胞形成图案，产生坚固的结构，将蜂窝的特定部分固定在一起。这里，每个细胞独立于另一个细胞，但它也与其他细胞相关。这意味着对一个细胞的损害不会损害其他细胞，因此，蜜蜂可以在不影响完整蜂箱的情况下重建这些细胞。</p>
<p><img src="https://i.loli.net/2019/03/19/5c90b73662fd8.png" alt=""></p>
<p>请参考上图。这里，每个六边形形状代表单独的服务组件。与蜜蜂的工作类似，每个敏捷团队都使用可用的框架和所选的技术堆栈构建单独的服务组件。就像在蜂箱中一样，每个服务组件形成一个强大的微服务架构，以提供更好的可扩展性。此外，敏捷团队可以单独处理每个服务组件的问题，而对整个应用程序没有影响或影响最小。</p>
<h2 id="微服务架构有哪些优势？"><a href="#微服务架构有哪些优势？" class="headerlink" title="微服务架构有哪些优势？"></a>微服务架构有哪些优势？</h2><p><img src="https://i.loli.net/2019/03/19/5c90b78c7722a.png" alt=""></p>
<ul>
<li><strong>独立开发</strong>  – 所有微服务都可以根据各自的功能轻松开发</li>
<li><strong>独立部署</strong>  – 基于其服务，可以在任何应用程序中单独部署它们</li>
<li><strong>故障隔离</strong>  – 即使应用程序的一项服务不起作用，系统仍可继续运行</li>
<li><strong>混合技术堆栈</strong>  – 可以使用不同的语言和技术来构建同一应用程序的不同服务</li>
<li><strong>粒度缩放</strong>  – 单个组件可根据需要进行缩放，无需将所有组件缩放在一起</li>
</ul>
<h2 id="微服务有哪些特点？"><a href="#微服务有哪些特点？" class="headerlink" title="微服务有哪些特点？"></a>微服务有哪些特点？</h2><p><img src="https://i.loli.net/2019/03/19/5c90b7a798e40.png" alt=""></p>
<ul>
<li><strong>解耦</strong>  – 系统内的服务很大程度上是分离的。因此，整个应用程序可以轻松构建，更改和扩展</li>
<li><strong>组件化</strong>  – 微服务被视为可以轻松更换和升级的独立组件<br>业务能力  – 微服务非常简单，专注于单一功能</li>
<li><strong>自治</strong>  – 开发人员和团队可以彼此独立工作，从而提高速度<br>持续交付  – 通过软件创建，测试和批准的系统自动化，允许频繁发布软件</li>
<li><strong>责任</strong>  – 微服务不关注应用程序作为项目。相反，他们将应用程序视为他们负责的产品</li>
<li><strong>分散治理</strong>  – 重点是使用正确的工具来做正确的工作。这意味着没有标准化模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题</li>
<li><strong>敏捷</strong>  – 微服务支持敏捷开发。任何新功能都可以快速开发并再次丢弃</li>
</ul>
<h2 id="设计微服务的最佳实践是什么？"><a href="#设计微服务的最佳实践是什么？" class="headerlink" title="设计微服务的最佳实践是什么？"></a>设计微服务的最佳实践是什么？</h2><p><img src="https://i.loli.net/2019/03/19/5c90b80f82113.png" alt=""></p>
<h2 id="微服务架构如何运作？"><a href="#微服务架构如何运作？" class="headerlink" title="微服务架构如何运作？"></a>微服务架构如何运作？</h2><p>微服务架构具有以下组件：<br><img src="https://i.loli.net/2019/03/19/5c90b81dec0cb.png" alt=""></p>
<ul>
<li><strong>客户端</strong>  – 来自不同设备的不同用户发送请求。</li>
<li><strong>身份提供商</strong>  – 验证用户或客户身份并颁发安全令牌。</li>
<li><strong>API网关</strong>  – 处理客户端请求。</li>
<li><strong>静态内容</strong>  – 容纳系统的所有内容。</li>
<li><strong>管理</strong>  – 在节点上平衡服务并识别故障。</li>
<li><strong>服务发现</strong>  – 查找微服务之间通信路径的指南。</li>
<li><strong>内容交付网络</strong>  – 代理服务器及其数据中心的分布式网络。</li>
<li><strong>远程服务</strong>  – 启用驻留在IT设备网络上的远程访问信息。</li>
</ul>
<h2 id="微服务架构的优缺点是什么？"><a href="#微服务架构的优缺点是什么？" class="headerlink" title="微服务架构的优缺点是什么？"></a>微服务架构的优缺点是什么？</h2><table>
<thead>
<tr>
<th align="center">微服务架构的优点</th>
<th align="center">微服务架构的缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">自由使用不同的技术</td>
<td align="center">增加故障排除挑战</td>
</tr>
<tr>
<td align="center">每个微服务都侧重于单一功能</td>
<td align="center">由于远程呼叫而增加延迟</td>
</tr>
<tr>
<td align="center">支持单个可部署单元</td>
<td align="center">增加了配置和其他操作的工作量</td>
</tr>
<tr>
<td align="center">允许经常发布软件</td>
<td align="center">难以保持交易安全</td>
</tr>
<tr>
<td align="center">确保每项服务的安全性</td>
<td align="center">艰难地跨越各种边界跟踪数据</td>
</tr>
<tr>
<td align="center">多个服务是并行开发和部署的</td>
<td align="center">难以在服务之间进行编码</td>
</tr>
</tbody></table>
<h2 id="单机，SOA和微服务架构有什么区别？"><a href="#单机，SOA和微服务架构有什么区别？" class="headerlink" title="单机，SOA和微服务架构有什么区别？"></a>单机，SOA和微服务架构有什么区别？</h2><p><img src="https://i.loli.net/2019/03/19/5c90b8c15a970.png" alt=""></p>
<ul>
<li><strong>单机架构</strong>类似于大容器，其中应用程序的所有软件组件组装在一起并紧密封装。</li>
<li>一个<strong>面向服务</strong>的架构是一种相互通信服务的集合。通信可以涉及简单的数据传递，也可以涉及两个或多个协调某些活动的服务。</li>
<li><strong>微服务架构</strong>是一种架构风格，它将应用程序构建为以业务域为模型的小型自治服务集合。</li>
</ul>
<h2 id="在使用微服务架构时，您面临哪些挑战？"><a href="#在使用微服务架构时，您面临哪些挑战？" class="headerlink" title="在使用微服务架构时，您面临哪些挑战？"></a>在使用微服务架构时，您面临哪些挑战？</h2><p>开发一些较小的微服务听起来很容易，但开发它们时经常遇到的挑战如下。</p>
<ul>
<li><strong>自动化组件</strong>：难以自动化，因为有许多较小的组件。因此，对于每个组件，我们必须遵循Build，Deploy和Monitor的各个阶段。</li>
<li><strong>易感性</strong>：将大量组件维护在一起变得难以部署，维护，监控和识别问题。它需要在所有组件周围具有很好的感知能力。</li>
<li><strong>配置管理</strong>：有时在各种环境中维护组件的配置变得困难。</li>
<li><strong>调试</strong>：很难找到错误的每一项服务。维护集中式日志记录和仪表板以调试问题至关重要。</li>
</ul>
<h2 id="SOA和微服务架构之间的主要区别是什么？"><a href="#SOA和微服务架构之间的主要区别是什么？" class="headerlink" title="SOA和微服务架构之间的主要区别是什么？"></a>SOA和微服务架构之间的主要区别是什么？</h2><table>
<thead>
<tr>
<th align="center">SOA</th>
<th align="center">微服务</th>
</tr>
</thead>
<tbody><tr>
<td align="center">遵循“ 尽可能多的共享 ”架构方法</td>
<td align="center">遵循“ 尽可能少分享 ”的架构方法</td>
</tr>
<tr>
<td align="center">重要性在于  业务功能  重用</td>
<td align="center">重要性在于“ 有界背景 ” 的概念</td>
</tr>
<tr>
<td align="center">他们有  共同的 治理  和标准</td>
<td align="center">他们专注于  人们的 合作  和其他选择的自由</td>
</tr>
<tr>
<td align="center">使用  企业服务总线（ESB）  进行通信</td>
<td align="center">简单的消息系统</td>
</tr>
<tr>
<td align="center">它们支持  多种消息协议</td>
<td align="center">他们使用  轻量级协议  ，如  HTTP / REST  等。</td>
</tr>
<tr>
<td align="center">多线程，  有更多的开销来处理I / O.</td>
<td align="center">单线程  通常使用Event Loop功能进行非锁定I / O处理</td>
</tr>
<tr>
<td align="center">最大化应用程序服务可重用性</td>
<td align="center">专注于  解耦</td>
</tr>
<tr>
<td align="center">传统的关系数据库  更常用</td>
<td align="center">现代  关系数据库 更常用</td>
</tr>
<tr>
<td align="center">系统的变化需要修改整体</td>
<td align="center">系统的变化是创造一种新的服务</td>
</tr>
<tr>
<td align="center">DevOps / Continuous Delivery正在变得流行，但还不是主流</td>
<td align="center">专注于DevOps /持续交付</td>
</tr>
</tbody></table>
<h2 id="微服务有什么特点？"><a href="#微服务有什么特点？" class="headerlink" title="微服务有什么特点？"></a>微服务有什么特点？</h2><p><img src="https://i.loli.net/2019/03/19/5c90b9a246819.png" alt=""></p>
<h2 id="什么是领域驱动设计？"><a href="#什么是领域驱动设计？" class="headerlink" title="什么是领域驱动设计？"></a>什么是领域驱动设计？</h2><p><img src="https://i.loli.net/2019/03/19/5c90b9abdb0a0.png" alt=""></p>
<h2 id="为什么需要域驱动设计（DDD）？"><a href="#为什么需要域驱动设计（DDD）？" class="headerlink" title="为什么需要域驱动设计（DDD）？"></a>为什么需要域驱动设计（DDD）？</h2><p><img src="https://i.loli.net/2019/03/19/5c90b9b7884a5.png" alt=""></p>
<h2 id="什么是无所不在的语言？"><a href="#什么是无所不在的语言？" class="headerlink" title="什么是无所不在的语言？"></a>什么是无所不在的语言？</h2><p>如果您必须定义<strong>泛在语言（UL）</strong>，那么它是特定域的开发人员和用户使用的通用语言，通过该语言可以轻松解释域。</p>
<p>无处不在的语言必须非常清晰，以便它将所有团队成员放在同一页面上，并以机器可以理解的方式进行翻译。</p>
<h2 id="什么是凝聚力？"><a href="#什么是凝聚力？" class="headerlink" title="什么是凝聚力？"></a>什么是凝聚力？</h2><p>模块内部元素所属的程度被认为是<strong>凝聚力</strong>。</p>
<h2 id="什么是耦合？"><a href="#什么是耦合？" class="headerlink" title="什么是耦合？"></a>什么是耦合？</h2><p>组件之间依赖关系强度的度量被认为是<strong>耦合</strong>。一个好的设计总是被认为具有<strong>高内聚力</strong>和<strong>低耦合性</strong>。</p>
<h2 id="什么是REST-RESTful以及它的用途是什么？"><a href="#什么是REST-RESTful以及它的用途是什么？" class="headerlink" title="什么是REST / RESTful以及它的用途是什么？"></a>什么是REST / RESTful以及它的用途是什么？</h2><p><strong>Representational State Transfer（REST）/ RESTful</strong>  Web服务是一种帮助计算机系统通过Internet进行通信的架构风格。这使得微服务更容易理解和实现。</p>
<p>微服务可以使用或不使用RESTful API实现，但使用RESTful API构建松散耦合的微服务总是更容易。</p>
<h2 id="你对Spring-Boot有什么了解？"><a href="#你对Spring-Boot有什么了解？" class="headerlink" title="你对Spring Boot有什么了解？"></a>你对Spring Boot有什么了解？</h2><p>事实上，随着新功能的增加，弹簧变得越来越复杂。如果必须启动新的spring项目，则必须添加构建路径或添加maven依赖项，配置应用程序服务器，添加spring配置。所以一切都必须从头开始。</p>
<p><strong>Spring Boot</strong>是解决这个问题的方法。使用spring boot可以避免所有样板代码和配置。因此，基本上认为自己就好像你正在烘烤蛋糕一样，春天就像制作蛋糕所需的成分一样，弹簧靴就是你手中的完整蛋糕。</p>
<p><img src="https://i.loli.net/2019/03/19/5c90ba2940125.png" alt=""></p>
<h2 id="什么是Spring引导的执行器？"><a href="#什么是Spring引导的执行器？" class="headerlink" title="什么是Spring引导的执行器？"></a>什么是Spring引导的执行器？</h2><p>Spring Boot执行程序提供了restful Web服务，以访问生产环境中运行应用程序的当前状态。在执行器的帮助下，您可以检查各种指标并监控您的应用程序。</p>
<h2 id="什么是Spring-Cloud？"><a href="#什么是Spring-Cloud？" class="headerlink" title="什么是Spring Cloud？"></a>什么是Spring Cloud？</h2><p>根据Spring Cloud的官方网站，Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，领导选举，分布式会话，集群状态）。</p>
<h2 id="Spring-Cloud解决了哪些问题？"><a href="#Spring-Cloud解决了哪些问题？" class="headerlink" title="Spring Cloud解决了哪些问题？"></a>Spring Cloud解决了哪些问题？</h2><p>在使用Spring Boot开发分布式微服务时，我们面临的问题很少由Spring Cloud解决。</p>
<ul>
<li><strong>与分布式系统相关的复杂性</strong> – 包括网络问题，延迟开销，带宽问题，安全问题。</li>
<li><strong>处理服务发现的能力</strong> – 服务发现允许集群中的进程和服务找到彼此并进行通信。</li>
<li><strong>解决冗余问题</strong> – 冗余问题经常发生在分布式系统中。</li>
<li><strong>负载平衡</strong>  – 改进跨多个计算资源（例如计算机集群，网络链接，中央处理单元）的工作负载分布。</li>
<li><strong>减少性能问题</strong> – 减少因各种操作开销导致的性能问题。</li>
</ul>
<h2 id="在Spring-MVC应用程序中使用WebMvcTest注释有什么用处？"><a href="#在Spring-MVC应用程序中使用WebMvcTest注释有什么用处？" class="headerlink" title="在Spring MVC应用程序中使用WebMvcTest注释有什么用处？"></a>在Spring MVC应用程序中使用WebMvcTest注释有什么用处？</h2><p><img src="https://i.loli.net/2019/03/19/5c90ba7ae7c9b.png" alt=""></p>
<p>在测试目标只关注Spring MVC组件的情况下，<strong>WebMvcTest</strong>注释用于单元测试Spring MVC应用程序。在上面显示的快照中，我们只想启动ToTestController。执行此单元测试时，不会启动所有其他控制器和映射。</p>
<h2 id="你能否给出关于休息和微服务的要点？"><a href="#你能否给出关于休息和微服务的要点？" class="headerlink" title="你能否给出关于休息和微服务的要点？"></a>你能否给出关于休息和微服务的要点？</h2><p><strong>休息</strong></p>
<p>虽然您可以通过多种方式实现微服务，但REST over HTTP是实现微服务的一种方式。REST还可用于其他应用程序，如Web应用程序，API设计和MVC应用程序，以提供业务数据。</p>
<p><strong>微服务</strong></p>
<p>微服务是一种体系结构，其中系统的所有组件都被放入单独的组件中，这些组件可以单独构建，部署和扩展。微服务的某些原则和最佳实践有助于构建弹性应用程序。</p>
<p>简而言之，您可以说REST是构建微服务的媒介。</p>
<h2 id="什么是不同类型的微服务测试？"><a href="#什么是不同类型的微服务测试？" class="headerlink" title="什么是不同类型的微服务测试？"></a>什么是不同类型的微服务测试？</h2><p>在使用微服务时，由于有多个微服务协同工作，测试变得非常复杂。因此，测试分为不同的级别。</p>
<ul>
<li>在<strong>底层</strong>，我们有<strong>面向技术的测试</strong>，如单元测试和性能测试。这些是完全自动化的。</li>
<li>在<strong>中间层面</strong>，我们进行了诸如压力测试和可用性测试之类的<strong>探索性测试</strong>。</li>
<li>在<strong>顶层</strong>， 我们的<strong>验收测试</strong>数量很少。这些验收测试有助于利益相关者理解和验证软件功能。</li>
</ul>
<h2 id="您对Distributed-Transaction有何了解？"><a href="#您对Distributed-Transaction有何了解？" class="headerlink" title="您对Distributed Transaction有何了解？"></a>您对Distributed Transaction有何了解？</h2><p><strong>分布式事务</strong>是指单个事件导致两个或多个不能以原子方式提交的单独数据源的突变的任何情况。在微服务的世界中，它变得更加复杂，因为每个服务都是一个工作单元，并且大多数时候多个服务必须协同工作才能使业务成功。</p>
<h2 id="什么是Idempotence以及它在哪里使用？"><a href="#什么是Idempotence以及它在哪里使用？" class="headerlink" title="什么是Idempotence以及它在哪里使用？"></a>什么是Idempotence以及它在哪里使用？</h2><p><strong>幂等</strong>性是能够以这样的方式做两次事情的特性，即最终结果将保持不变，即好像它只做了一次。</p>
<p><strong>用法</strong>：在远程服务或数据源中<strong>使用</strong> Idempotence，这样当它多次接收指令时，它只处理指令一次。</p>
<h2 id="什么是有界上下文？"><a href="#什么是有界上下文？" class="headerlink" title="什么是有界上下文？"></a>什么是有界上下文？</h2><p>有界上下文是域驱动设计的核心模式。DDD战略设计部门的重点是处理大型模型和团队。DDD通过将大型模型划分为不同的有界上下文并明确其相互关系来处理大型模型。</p>
<h2 id="什么是双因素身份验证？"><a href="#什么是双因素身份验证？" class="headerlink" title="什么是双因素身份验证？"></a>什么是双因素身份验证？</h2><p>双因素身份验证为帐户登录过程启用第二级身份验证。<br><img src="https://i.loli.net/2019/03/19/5c90bb2116b58.png" alt=""><br>因此，假设用户必须只输入用户名和密码，那么这被认为是单因素身份验证。</p>
<h2 id="双因素身份验证的凭据类型有哪些？"><a href="#双因素身份验证的凭据类型有哪些？" class="headerlink" title="双因素身份验证的凭据类型有哪些？"></a>双因素身份验证的凭据类型有哪些？</h2><p>这三种凭证是：<br><img src="https://i.loli.net/2019/03/19/5c90bb3297d7f.png" alt=""></p>
<h2 id="什么是客户证书？"><a href="#什么是客户证书？" class="headerlink" title="什么是客户证书？"></a>什么是客户证书？</h2><p>客户端系统用于向远程服务器发出经过身份验证的请求的一种数字证书称为<strong>客户端证书</strong>。客户端证书在许多相互认证设计中起着非常重要的作用，为请求者的身份提供了强有力的保证。</p>
<h2 id="PACT在微服务架构中的用途是什么？"><a href="#PACT在微服务架构中的用途是什么？" class="headerlink" title="PACT在微服务架构中的用途是什么？"></a>PACT在微服务架构中的用途是什么？</h2><p><strong>PACT</strong>是一个开源工具，允许测试服务提供者和消费者之间的交互，与合同隔离，从而提高微服务集成的可靠性。</p>
<p>微服务中的用法：</p>
<ul>
<li>用于在微服务中实现消费者驱动的合同。</li>
<li>测试微服务的消费者和提供者之间的消费者驱动的合同。</li>
</ul>
<h2 id="什么是OAuth？"><a href="#什么是OAuth？" class="headerlink" title="什么是OAuth？"></a>什么是OAuth？</h2><p><strong>OAuth</strong>代表开放授权协议。这允许通过在HTTP服务上启用客户端应用程序（例如第三方提供商Facebook，GitHub等）来访问资源所有者的资源。因此，您可以在不使用其凭据的情况下与另一个站点共享存储在一个站点上的资源。</p>
<h2 id="康威定律是什么？"><a href="#康威定律是什么？" class="headerlink" title="康威定律是什么？"></a>康威定律是什么？</h2><p>任何设计系统的组织（广泛定义）都将产生一种设计，其结构是组织通信结构的副本。” –  <strong>Mel Conway</strong></p>
<p><img src="https://i.loli.net/2019/03/19/5c90bb735fb05.png" alt=""></p>
<p>该法律基本上试图传达这样一个事实：为了使软件模块起作用，整个团队应该进行良好的沟通。因此，系统的结构反映了产生它的组织的社会边界。</p>
<h2 id="合同测试你懂什么？"><a href="#合同测试你懂什么？" class="headerlink" title="合同测试你懂什么？"></a>合同测试你懂什么？</h2><p>根据Martin Flower的说法，<strong>合同测试</strong>是在外部服务边界进行的测试，用于验证其是否符合消费服务预期的合同。</p>
<p>此外，合同测试不会深入测试服务的行为。更确切地说，它测试该服务调用的输入＆输出包含所需的属性和所述响应延迟，吞吐量是允许的限度内。</p>
<h2 id="什么是端到端微服务测试？"><a href="#什么是端到端微服务测试？" class="headerlink" title="什么是端到端微服务测试？"></a>什么是端到端微服务测试？</h2><p>端到端测试验证了工作流中的每个流程都正常运行。这可确保系统作为一个整体协同工作并满足所有要求。</p>
<p>通俗地说，你可以说端到端测试是一种测试，在特定时期后测试所有东西。</p>
<p><img src="https://i.loli.net/2019/03/19/5c90bb8fe26f4.png" alt=""></p>
<h2 id="Container在微服务中的用途是什么？"><a href="#Container在微服务中的用途是什么？" class="headerlink" title="Container在微服务中的用途是什么？"></a>Container在微服务中的用途是什么？</h2><p>容器是管理基于微服务的应用程序以便单独开发和部署它们的好方法。您可以将微服务封装在容器映像及其依赖项中，然后可以使用它来滚动按需实例的微服务，而无需任何额外的工作。</p>
<p><img src="https://i.loli.net/2019/03/19/5c90bba02e670.png" alt=""></p>
<h2 id="什么是微服务架构中的DRY？"><a href="#什么是微服务架构中的DRY？" class="headerlink" title="什么是微服务架构中的DRY？"></a>什么是微服务架构中的DRY？</h2><p><strong>DRY</strong>代表<strong>不要重复自己</strong>。它基本上促进了重用代码的概念。这导致开发和共享库，这反过来导致紧密耦合。</p>
<h2 id="什么是消费者驱动的合同（CDC）？"><a href="#什么是消费者驱动的合同（CDC）？" class="headerlink" title="什么是消费者驱动的合同（CDC）？"></a>什么是消费者驱动的合同（CDC）？</h2><p>这基本上是用于开发微服务的模式，以便它们可以被外部系统使用。当我们处理微服务时，有一个特定的提供者构建它，并且有一个或多个使用微服务的消费者。</p>
<p>通常，提供程序在XML文档中指定接口。但在消费者驱动的合同中，每个服务消费者都传达了提供商期望的接口。</p>
<h2 id="Web，RESTful-API在微服务中的作用是什么？"><a href="#Web，RESTful-API在微服务中的作用是什么？" class="headerlink" title="Web，RESTful API在微服务中的作用是什么？"></a>Web，RESTful API在微服务中的作用是什么？</h2><p>微服务架构基于一个概念，其中所有服务应该能够彼此交互以构建业务功能。因此，要实现这一点，每个微服务必须具有接口。这使得Web API成为微服务的一个非常重要的推动者。RESTful API基于Web的开放网络原则，为构建微服务架构的各个组件之间的接口提供了最合理的模型。</p>
<h2 id="您对微服务架构中的语义监控有何了解？"><a href="#您对微服务架构中的语义监控有何了解？" class="headerlink" title="您对微服务架构中的语义监控有何了解？"></a>您对微服务架构中的语义监控有何了解？</h2><p>语义监控，也称为 <strong>综合监控</strong>,  将自动化测试与监控应用程序相结合，以检测业务失败因素。</p>
<h2 id="我们如何进行跨功能测试？"><a href="#我们如何进行跨功能测试？" class="headerlink" title="我们如何进行跨功能测试？"></a>我们如何进行跨功能测试？</h2><p>跨功能测试是对非功能性需求的验证，即那些无法像普通功能那样实现的需求。</p>
<h2 id="我们如何在测试中消除非决定论？"><a href="#我们如何在测试中消除非决定论？" class="headerlink" title="我们如何在测试中消除非决定论？"></a>我们如何在测试中消除非决定论？</h2><p><strong>非确定性测试</strong>（NDT）基本上是不可靠的测试。所以，有时可能会发生它们通过，显然有时它们也可能会失败。当它们失败时，它们会重新运行通过。</p>
<p>从测试中删除非确定性的一些方法如下：</p>
<ol>
<li>隔离</li>
<li>异步</li>
<li>远程服务</li>
<li>隔离</li>
<li>时间</li>
<li>资源泄漏</li>
</ol>
<h2 id="Mock或Stub有什么区别？"><a href="#Mock或Stub有什么区别？" class="headerlink" title="Mock或Stub有什么区别？"></a>Mock或Stub有什么区别？</h2><p><strong>存根</strong></p>
<ul>
<li>一个有助于运行测试的虚拟对象。</li>
<li>在某些可以硬编码的条件下提供固定行为。</li>
<li>永远不会测试存根的任何其他行为。</li>
</ul>
<p>例如，对于空堆栈，您可以创建一个只为empty（）方法返回true的存根。因此，这并不关心堆栈中是否存在元素。</p>
<p><strong>嘲笑</strong></p>
<ul>
<li>一个虚拟对象，其中最初设置了某些属性。</li>
<li>此对象的行为取决于set属性。</li>
<li>也可以测试对象的行为。</li>
</ul>
<p>例如，对于Customer对象，您可以通过设置名称和年龄来模拟它。您可以将age设置为12，然后测试isAdult（）方法，该方法将在年龄大于18时返回true。因此，您的Mock Customer对象适用于指定的条件。</p>
<h2 id="您对Mike-Cohn的测试金字塔了解多少？"><a href="#您对Mike-Cohn的测试金字塔了解多少？" class="headerlink" title="您对Mike Cohn的测试金字塔了解多少？"></a>您对Mike Cohn的测试金字塔了解多少？</h2><p><strong>Mike Cohn</strong>  提供了一个名为<strong>Test Pyramid</strong>的模型。这描述了软件开发所需的自动化测试类型。</p>
<p><img src="https://i.loli.net/2019/03/19/5c90bc400f9cc.png" alt=""></p>
<p>根据金字塔，第一层的测试数量应该最高。在服务层，测试次数应小于单元测试级别，但应大于端到端级别。</p>
<h2 id="Docker的目的是什么？"><a href="#Docker的目的是什么？" class="headerlink" title="Docker的目的是什么？"></a>Docker的目的是什么？</h2><p>Docker提供了一个可用于托管任何应用程序的容器环境。在此，软件应用程序和支持它的依赖项紧密打包在一起。</p>
<p>因此，这个打包的产品被称为Container，因为它是由Docker完成的，所以它被称为Docker容器！</p>
<h2 id="什么是金丝雀释放？"><a href="#什么是金丝雀释放？" class="headerlink" title="什么是金丝雀释放？"></a>什么是金丝雀释放？</h2><p>Canary Releasing是一种降低在生产中引入新软件版本的风险的技术。这是通过将变更缓慢地推广到一小部分用户，然后将其发布到整个基础架构，即将其提供给每个人来完成的。</p>
<h2 id="什么是持续集成（CI）？"><a href="#什么是持续集成（CI）？" class="headerlink" title="什么是持续集成（CI）？"></a>什么是持续集成（CI）？</h2><p>持续集成（CI）是每次团队成员提交版本控制更改时自动构建和测试代码的过程。这鼓励开发人员通过在每个小任务完成后将更改合并到共享版本控制存储库来共享代码和单元测试。</p>
<h2 id="什么是持续监测？"><a href="#什么是持续监测？" class="headerlink" title="什么是持续监测？"></a>什么是持续监测？</h2><p>持续监控深入监控覆盖范围，从浏览器内前端性能指标，到应用程序性能，再到主机虚拟化基础架构指标。</p>
<h2 id="架构师在微服务架构中的角色是什么？"><a href="#架构师在微服务架构中的角色是什么？" class="headerlink" title="架构师在微服务架构中的角色是什么？"></a>架构师在微服务架构中的角色是什么？</h2><p>微服务架构中的架构师扮演以下角色：</p>
<ul>
<li>决定整个软件系统的布局。</li>
<li>帮助确定组件的分区。因此，他们确保组件相互粘合，但不紧密耦合。</li>
<li>与开发人员共同编写代码，了解日常生活中面临的挑战。</li>
<li>为开发微服务的团队提供某些工具和技术的建议。</li>
<li>提供技术治理，以便技术开发团队遵循微服务原则。</li>
</ul>
<h2 id="我们可以用微服务创建状态机吗？"><a href="#我们可以用微服务创建状态机吗？" class="headerlink" title="我们可以用微服务创建状态机吗？"></a>我们可以用微服务创建状态机吗？</h2><p>我们知道拥有自己的数据库的每个微服务都是一个可独立部署的程序单元，这反过来又让我们可以创建一个状态机。因此，我们可以为特定的微服务指定不同的状态和事件。</p>
<p>例如，我们可以定义Order微服务。订单可以具有不同的状态。Order状态的转换可以是Order微服务中的独立事件。</p>
<h2 id="什么是微服务中的反应性扩展？"><a href="#什么是微服务中的反应性扩展？" class="headerlink" title="什么是微服务中的反应性扩展？"></a>什么是微服务中的反应性扩展？</h2><p>Reactive Extensions也称为Rx。这是一种设计方法，我们通过调用多个服务来收集结果，然后编译组合响应。这些调用可以是同步或异步，阻塞或非阻塞。Rx是分布式系统中非常流行的工具，与传统流程相反。</p>
<p>希望这些微服务面试问题可以帮助您进行微服务架构师访谈。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMq 消息订阅模式--原创 彭应智</title>
    <url>/2018/11/10/Java/spring/RabbitMq%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Rabbit-概念"><a href="#Rabbit-概念" class="headerlink" title="Rabbit 概念"></a>Rabbit 概念</h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><blockquote>
<p>名词解释系小米自己的理解。和书籍、网站等有所出入。仅代表本人理解的</p>
</blockquote>
<ul>
<li><strong>生产者</strong> 是发送消息的</li>
<li><strong>交换器</strong> 是负责转发消息的</li>
<li><strong>队列</strong> 是存储消息的</li>
<li><strong>消费者</strong> 是接收消息的</li>
</ul>
<h1 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h1><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MqConfig</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/**
     * 获取交换机
     * @return
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> FanoutExchange <span class="token function">fanoutExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FanoutExchange</span><span class="token punctuation">(</span><span class="token string">"testSubscribe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 定时器
 */</span>
<span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sender</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> AmqpTemplate amqpTemplate<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 定时发消息
     * 每五秒发送一次
     */</span>
    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>cron <span class="token operator">=</span> <span class="token string">"0/5 * * * * ？*"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        Random r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Long num <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">nextLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Sender : "</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sender : "</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//往交换机发送消息</span>
        amqpTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"testSubscribe"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="订阅方"><a href="#订阅方" class="headerlink" title="订阅方"></a>订阅方</h1><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MqConfig</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/**
     * 新建消息队列
     * @return
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> Queue <span class="token function">AMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"testSubscribe.client02"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 获取交换机
     * @return
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> FanoutExchange <span class="token function">fanoutExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FanoutExchange</span><span class="token punctuation">(</span><span class="token string">"testSubscribe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 绑定交换机
     * @param AMessage
     * @param fanoutExchange
     * @return
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    Binding <span class="token function">bindingExchangeA</span><span class="token punctuation">(</span>Queue AMessage<span class="token punctuation">,</span> FanoutExchange fanoutExchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> BindingBuilder<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>AMessage<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span>fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Listener</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/**
     * 监听消息队列
     * @param num
     */</span>
    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"testSubscribe.client02"</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@RabbitHandler</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSubscribe</span><span class="token punctuation">(</span>Long num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Thread thread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"\n这是：{}\n线程ID：{}\n线程名称：{}\n监听队列为{}\n获得的数据为：{}"</span><span class="token punctuation">,</span><span class="token string">"client02"</span><span class="token punctuation">,</span> thread<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> thread<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"testSubscribe"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>MessageFormat<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"\n这是：{0}\n线程ID：{1}\n线程名称：{2}\n监听队列为{3}\n获得的数据为：{4}"</span><span class="token punctuation">,</span><span class="token string">"client02"</span><span class="token punctuation">,</span> thread<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> thread<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"testSubscribe"</span><span class="token punctuation">,</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我的方案是</p>
<ul>
<li><p><strong>发送方</strong> 发送方只需要把消息发送给交换机</p>
<blockquote>
<p>所以发送方只需要定义交换机并往交换机中发送消息，至于消息最终发到哪些队列无需关心。</p>
</blockquote>
</li>
<li><p><strong>接收方</strong> 由接收方定义队列和配置交换机</p>
<blockquote>
<p>接收定义交换机和队列，并声明交换机和队列的关系。此后便可以从队列中获取消息。</p>
</blockquote>
</li>
</ul>
<p>发布/订阅</p>
<ul>
<li>接收方从交换机订阅</li>
<li>发送方发布到交换机</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa 最大分页 size --原创 彭应智</title>
    <url>/2018/08/10/Java/spring/Spring%20Data%20Jpa%E6%9C%80%E5%A4%A7%E5%88%86%E9%A1%B5size/</url>
    <content><![CDATA[<p>我们需要重写PageableHandlerMethodArgumentResolver这个Bean，<br>调用其中的setMaxPageSize()来配置最大分页的size。默认值为2000.</p>
<p>如下代码配置最大分页的size为Integer的最大值2147483647：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@EnableConfigurationProperties</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PaginationConfiguration</span> <span class="token keyword">extends</span> <span class="token class-name">SpringDataWebConfiguration</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> PageableHandlerMethodArgumentResolver <span class="token function">pageableResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        PageableHandlerMethodArgumentResolver pageableHandlerMethodArgumentResolver <span class="token operator">=</span>
                <span class="token keyword">new</span> <span class="token class-name">PageableHandlerMethodArgumentResolver</span><span class="token punctuation">(</span><span class="token function">sortResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        pageableHandlerMethodArgumentResolver<span class="token punctuation">.</span><span class="token function">setMaxPageSize</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> pageableHandlerMethodArgumentResolver<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>原创</tag>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>spring mvc valid</title>
    <url>/2018/12/10/Java/spring/spring%20mvc%20valid/</url>
    <content><![CDATA[<h1 id="一览"><a href="#一览" class="headerlink" title="一览"></a>一览</h1><h2 id="JSR303定义的校验类型"><a href="#JSR303定义的校验类型" class="headerlink" title="JSR303定义的校验类型"></a>JSR303定义的校验类型</h2><table>
<thead>
<tr>
<th>对象</th>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>All</td>
<td>@Null</td>
<td>验证对象是否为null</td>
</tr>
<tr>
<td>All</td>
<td>@NotNull</td>
<td>验证对象是否不为null, 无法查检长度为0的字符串</td>
</tr>
<tr>
<td>String</td>
<td>@NotBlank</td>
<td>检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.</td>
</tr>
<tr>
<td>String,Array</td>
<td>@NotEmpty</td>
<td>检查约束元素是否为NULL或者是EMPTY.</td>
</tr>
<tr>
<td>Boolean</td>
<td>@AssertTrue</td>
<td>验证 Boolean 对象是否为 true</td>
</tr>
<tr>
<td>Boolean</td>
<td>@AssertFalse</td>
<td>验证 Boolean 对象是否为 false</td>
</tr>
<tr>
<td>Array,Collection,Map,String</td>
<td>@Size(min=, max=)</td>
<td>验证对象（Array,Collection,Map,String）长度是否在给定的范围之内</td>
</tr>
<tr>
<td></td>
<td>@Length(min=, max=)</td>
<td>Validates that the annotated string is between min and max included.</td>
</tr>
<tr>
<td>Date</td>
<td>@Past</td>
<td>验证 Date 和 Calendar 对象是否在当前时间之前</td>
</tr>
<tr>
<td>Date</td>
<td>@Future</td>
<td>验证 Date 和 Calendar 对象是否在当前时间之后</td>
</tr>
<tr>
<td>Date</td>
<td>@Pattern</td>
<td>验证 String 对象是否符合正则表达式的规则</td>
</tr>
<tr>
<td>Number , String</td>
<td>@Min</td>
<td>验证 Number 和 String 对象是否大等于指定的值</td>
</tr>
<tr>
<td>Number , String</td>
<td>@Max</td>
<td>验证 Number 和 String 对象是否小等于指定的值</td>
</tr>
<tr>
<td>BigDecimal</td>
<td>@DecimalMax</td>
<td>被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度</td>
</tr>
<tr>
<td>BigDecimal</td>
<td>@DecimalMin</td>
<td>被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度</td>
</tr>
<tr>
<td>Number,String</td>
<td>@Digits(integer=,fraction=)</td>
<td>验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。</td>
</tr>
<tr>
<td>Number</td>
<td>@Range(min=, max=)</td>
<td>Checks whether the annotated value lies between (inclusive) the specified minimum and maximum.</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>tumblr Api -- 小米规整</title>
    <url>/2018/09/13/%E6%94%B6%E9%9B%86/api/tumblr%20Api/</url>
    <content><![CDATA[<h1 id="注册开发者密钥"><a href="#注册开发者密钥" class="headerlink" title="注册开发者密钥"></a>注册开发者密钥</h1><p><a href="https://www.tumblr.com/oauth/apps" target="_blank" rel="noopener">点击注册</a></p>
<h1 id="API汇总"><a href="#API汇总" class="headerlink" title="API汇总"></a>API汇总</h1><table>
<thead>
<tr>
<th>name</th>
<th>url</th>
</tr>
</thead>
<tbody><tr>
<td>Blog</td>
<td>api.tumblr.com/v2/blog/{blog-identifier}/…</td>
</tr>
<tr>
<td>User</td>
<td>api.tumblr.com/v2/user/…</td>
</tr>
<tr>
<td>post</td>
<td>api.tumblr.com/v2/blog/{blog-identifier}/posts[/type]</td>
</tr>
</tbody></table>
<p>明细</p>
<table>
<thead>
<tr>
<th>type</th>
<th>name</th>
<th>url</th>
<th>method</th>
<th>Authentication</th>
</tr>
</thead>
<tbody><tr>
<td>blog</td>
<td>info</td>
<td>api.tumblr.com/v2/blog/{blog-identifier}/info?api_key={key}</td>
<td>GET</td>
<td>API key</td>
</tr>
</tbody></table>
<h1 id="API-明细"><a href="#API-明细" class="headerlink" title="API 明细"></a>API 明细</h1><h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p><code>/info</code> — Retrieve Blog Info</p>
<p>This method returns general information about the blog, such as the title, number of posts, and other high-level data.</p>
<h4 id="url"><a href="#url" class="headerlink" title="url"></a>url</h4><table>
<thead>
<tr>
<th>type</th>
<th>name</th>
<th>url</th>
<th>method</th>
<th>Authentication</th>
</tr>
</thead>
<tbody><tr>
<td>blog</td>
<td>info</td>
<td>api.tumblr.com/v2/blog/{blog-identifier}/info?api_key={key}</td>
<td>GET</td>
<td>API key</td>
</tr>
</tbody></table>
<h4 id="Request-Parameters"><a href="#Request-Parameters" class="headerlink" title="Request Parameters"></a>Request Parameters</h4><table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
<th>Required?</th>
</tr>
</thead>
<tbody><tr>
<td>blog-identifier</td>
<td>String</td>
<td>Any blog identifier See the Overview for more details.</td>
<td>N/A</td>
<td>Yes</td>
</tr>
<tr>
<td>api_key</td>
<td>String</td>
<td>Your OAuth Consumer Key See Authentication for more details.</td>
<td>N/A</td>
<td>Yes</td>
</tr>
</tbody></table>
<h3 id="avatar"><a href="#avatar" class="headerlink" title="avatar"></a>avatar</h3><p><code>/avatar</code> — Retrieve a Blog Avatar<br>You can get a blog’s avatar in 9 different sizes. The default size is 64x64.</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><table>
<thead>
<tr>
<th>URI</th>
<th>HTTP Method</th>
<th>Authentication</th>
</tr>
</thead>
<tbody><tr>
<td>api.tumblr.com/v2/blog/{blog-identifier}/avatar[/size]</td>
<td>GET</td>
<td>None</td>
</tr>
</tbody></table>
<h4 id="Request-Parameters-1"><a href="#Request-Parameters-1" class="headerlink" title="Request Parameters"></a>Request Parameters</h4><table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
<th>Required?</th>
</tr>
</thead>
<tbody><tr>
<td>blog-identifier</td>
<td>String</td>
<td>Any blog identifier</td>
<td>N/A</td>
<td>Yes</td>
</tr>
<tr>
<td>size</td>
<td>Number</td>
<td>The size of the avatar (square, one value for both length and width). Must be one of the values:16, 24, 30, 40, 48, 64, 96, 128, 512</td>
<td>64</td>
<td>No</td>
</tr>
</tbody></table>
<h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method"></a>Method</h4><table>
<thead>
<tr>
<th>URI</th>
<th>HTTP Method</th>
<th>Authentication</th>
</tr>
</thead>
<tbody><tr>
<td>api.tumblr.com/v2/blog/{blog-identifier}/posts[/type]?api_key={key}&amp;[optional-params=]</td>
<td>GET</td>
<td>API key</td>
</tr>
</tbody></table>
<h4 id="Request-Parameters-2"><a href="#Request-Parameters-2" class="headerlink" title="Request Parameters"></a>Request Parameters</h4><table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
<th>Required?</th>
</tr>
</thead>
<tbody><tr>
<td>blog-identifier</td>
<td>String</td>
<td>Any blog identifier</td>
<td>N/A</td>
<td>Yes</td>
</tr>
<tr>
<td>api_key</td>
<td>String</td>
<td>Your OAuth Consumer Key</td>
<td>N/A</td>
<td>Yes</td>
</tr>
<tr>
<td>type</td>
<td>String</td>
<td>The type of post to return. Specify one of the following:  text, quote, link, answer, video, audio, photo, chat</td>
<td>None – return all types</td>
<td>No</td>
</tr>
<tr>
<td>id</td>
<td>Number</td>
<td>A specific post ID. Returns the single post specified or (if not found) a 404 error.</td>
<td>None</td>
<td>No</td>
</tr>
<tr>
<td>tag</td>
<td>String</td>
<td>Limits the response to posts with the specified tag</td>
<td>None</td>
<td>No</td>
</tr>
<tr>
<td>limit</td>
<td>Number</td>
<td>The number of posts to return: 1–20, inclusive</td>
<td>20</td>
<td>No</td>
</tr>
<tr>
<td>offset</td>
<td>Number</td>
<td>Post number to start at</td>
<td>0 (first post)</td>
<td>No</td>
</tr>
<tr>
<td>reblog_info</td>
<td>Boolean</td>
<td>Indicates whether to return reblog information (specify true or false). Returns the various reblogged_ fields.</td>
<td>False</td>
<td>No</td>
</tr>
<tr>
<td>notes_info</td>
<td>Boolean</td>
<td>Indicates whether to return notes information (specify true or false). Returns note count and note metadata.</td>
<td>False</td>
<td>No</td>
</tr>
<tr>
<td>filter</td>
<td>String</td>
<td>Specifies the post format to return, other than HTML:</td>
<td>None (HTML)</td>
<td>No</td>
</tr>
<tr>
<td>before</td>
<td>Number</td>
<td>Returns posts published earlier than a specified Unix timestamp, in seconds.</td>
<td>False</td>
<td>No</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Java编程风格指南</title>
    <url>/2020/10/20/Java/Google%20Java%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。</p>
<p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。</p>
<h2 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h2><p>在本文档中，除非另有说明：</p>
<p>术语class可表示一个普通类，枚举类，接口或是annotation类型(<code>@interface</code>)<br>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。<br>其他的术语说明会偶尔在后面的文档出现。</p>
<h2 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h2><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p>
<h1 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h1><h2 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h2><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p>
<h2 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h2><p>源文件编码格式为UTF-8。</p>
<h2 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h2><h3 id="2-3-1-空白字符"><a href="#2-3-1-空白字符" class="headerlink" title="2.3.1 空白字符"></a>2.3.1 空白字符</h3><p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p>
<ul>
<li>所有其它字符串中的空白字符都要进行转义。</li>
<li>制表符不用于缩进。</li>
</ul>
<h3 id="2-3-2-特殊转义序列"><a href="#2-3-2-特殊转义序列" class="headerlink" title="2.3.2 特殊转义序列"></a>2.3.2 特殊转义序列</h3><p>对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, “, ‘及\)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。</p>
<h3 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h3><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p>
<blockquote>
<p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p>
</blockquote>
<p>例如：</p>
<pre class=" language-java"><code class="language-java">String unitAbbrev <span class="token operator">=</span> <span class="token string">"μs"</span><span class="token punctuation">;</span>                                 <span class="token operator">|</span> 赞，即使没有注释也非常清晰
String unitAbbrev <span class="token operator">=</span> <span class="token string">"\u03bcs"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "μs"                    | 允许，但没有理由要这样做</span>
String unitAbbrev <span class="token operator">=</span> <span class="token string">"\u03bcs"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Greek letter mu, "s"    | 允许，但这样做显得笨拙还容易出错</span>
String unitAbbrev <span class="token operator">=</span> <span class="token string">"\u03bcs"</span><span class="token punctuation">;</span>                            <span class="token operator">|</span> 很糟，读者根本看不出这是什么
<span class="token keyword">return</span> <span class="token string">'\ufeff'</span> <span class="token operator">+</span> content<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释</span></code></pre>
<blockquote>
<p>Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)</p>
</blockquote>
<h1 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h1><p>一个源文件包含(按顺序地)：</p>
<ol>
<li>许可证或版权信息(如有需要)</li>
<li>package语句</li>
<li>import语句</li>
<li>一个顶级类(只有一个)</li>
</ol>
<p>以上每个部分之间用一个空行隔开。</p>
<h2 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h2><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p>
<h2 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h2><p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p>
<h2 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h2><h3 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h3><p>即，不要出现类似这样的import语句：<code>import java.util.*</code>;</p>
<h3 id="3-3-2-不要换行"><a href="#3-3-2-不要换行" class="headerlink" title="3.3.2 不要换行"></a>3.3.2 不要换行</h3><p>import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)</p>
<h3 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h3><p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p>
<p>所有的静态导入独立成组<br><code>com.google</code> imports(仅当这个源文件是在<code>com.google</code>包下)<br>第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun<br><code>java</code> imports<br><code>javax</code> imports<br>组内不空行，按字典序排列。</p>
<h2 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h2><h3 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h3><p>每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。</p>
<p>例外：package-info.java，该文件中可没有package-info类。</p>
<h3 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h3><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p>
<h3 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h3><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p>
<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p>术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p>
<h2 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h2><h3 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h3><p>大括号与<code>if, else, for, do, while</code>语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p>
<h3 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h3><p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (<a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html" target="_blank" rel="noopener">Egyptian brackets</a>):</p>
<ul>
<li>左大括号前不换行</li>
<li>左大括号后换行</li>
<li>右大括号前换行</li>
<li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li>
</ul>
<p>示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ProblemException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>4.8.1节给出了enum类的一些例外。</p>
<h3 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h3><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成<code>{}</code>，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。</p>
<p>示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">doNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre>
<h2 id="4-2-块缩进：2个空格"><a href="#4-2-块缩进：2个空格" class="headerlink" title="4.2 块缩进：2个空格"></a>4.2 块缩进：2个空格</h2><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p>
<h2 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h2><p>每个语句后要换行。</p>
<h2 id="4-4-列限制：80或100"><a href="#4-4-列限制：80或100" class="headerlink" title="4.4 列限制：80或100"></a>4.4 列限制：80或100</h2><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p>
<p>例外：</p>
<ol>
<li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。</li>
<li>package和import语句(见3.2节和3.3节)。</li>
<li>注释中那些可能被剪切并粘贴到shell中的命令行。</li>
</ol>
<h2 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h2><p>术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p>
<p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p>
<blockquote>
<p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p>
</blockquote>
<h3 id="4-5-1-从哪里断开"><a href="#4-5-1-从哪里断开" class="headerlink" title="4.5.1 从哪里断开"></a>4.5.1 从哪里断开</h3><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p>
<ol>
<li>如果在<code>非赋值运算符</code>处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<code>&lt;T extends Foo &amp; Bar&gt;</code>)，catch块中的管道符号(<code>catch (FooException | BarException e</code>)</li>
<li>如果在<code>赋值运算符处</code>断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于<code>foreach</code>语句中的分号。</li>
<li>方法名或构造函数名与左括号留在同一行。</li>
<li>逗号(,)与其前面的内容留在同一行。</li>
</ol>
<h3 id="4-5-2-自动换行时缩进至少-4个空格"><a href="#4-5-2-自动换行时缩进至少-4个空格" class="headerlink" title="4.5.2 自动换行时缩进至少+4个空格"></a>4.5.2 自动换行时缩进至少+4个空格</h3><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p>
<p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p>
<p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p>
<h2 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h2><h3 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h3><p>以下情况需要使用一个空行：</p>
<ol>
<li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。<ul>
<li><strong>例外：</strong>两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li>
</ul>
</li>
<li>在函数体内，语句的逻辑分组间使用空行。</li>
<li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li>
<li>要满足本文档中其他节的空行要求(比如3.3节：import语句)<br>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</li>
</ol>
<h3 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h3><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p>
<ol>
<li>分隔任何保留字与紧随其后的左括号(<code>(</code>)(如<code>if, for catch</code>等)。</li>
<li>分隔任何保留字与其前面的右大括号(<code>}</code>)(如<code>else, catch</code>)。</li>
<li>在任何左大括号前({)，两个例外：<ul>
<li><code>@SomeAnnotation({a, b})</code>(不使用空格)。</li>
<li><code>String[][] x = foo;</code>(大括号间没有空格，见下面的Note)。</li>
</ul>
</li>
<li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul>
<li>类型界限中的&amp;(<code>&lt;T extends Foo &amp; Bar&gt;</code>)。</li>
<li>catch块中的管道符号(<code>catch (FooException | BarException e</code>)。</li>
<li><code>foreach</code>语句中的分号。</li>
</ul>
</li>
<li>在<code>, : ;</code>及右括号(<code>)</code>)后</li>
<li>如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。</li>
<li>类型和变量之间：List list。</li>
<li>数组初始化中，大括号内的空格是可选的，即<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>都是可以的。</li>
</ol>
<blockquote>
<p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p>
</blockquote>
<h3 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h3><p><strong>术语说明</strong>：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p>
<p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p>
<p>以下示例先展示未对齐的代码，然后是对齐的代码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// this is fine</span>
<span class="token keyword">private</span> Color color<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// this too</span>

<span class="token keyword">private</span> <span class="token keyword">int</span>   x<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// permitted, but future edits</span>
<span class="token keyword">private</span> Color color<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// may leave it unaligned</span></code></pre>
<blockquote>
<p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p>
</blockquote>
<h2 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h2><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p>
<h1 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h1><h3 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h3><p>枚举常量间用逗号隔开，换行可选。</p>
<p>没有方法和文档的枚举类可写成数组初始化的格式：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">enum</span> Suit <span class="token punctuation">{</span> CLUBS<span class="token punctuation">,</span> HEARTS<span class="token punctuation">,</span> SPADES<span class="token punctuation">,</span> DIAMONDS <span class="token punctuation">}</span></code></pre>
<p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p>
<h3 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h3><h4 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h4><p>不要使用组合声明，比如<code>int a, b</code>;。</p>
<h4 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h4><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p>
<h3 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h3><h4 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h4><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> 
<span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token number">3</span>
<span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span>
<span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span></code></pre>
<h4 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h4><p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p>
<h3 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h3><p><strong>术语说明</strong>：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。</p>
<h4 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h4><p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p>
<p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p>
<h4 id="4-8-4-2-Fall-through：注释"><a href="#4-8-4-2-Fall-through：注释" class="headerlink" title="4.8.4.2 Fall-through：注释"></a>4.8.4.2 Fall-through：注释</h4><p>在一个switch块内，每个语句组要么通过<code>break, continue, return</code>或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。示例：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">switch</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
  <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
    <span class="token function">prepareOneOrTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// fall through</span>
  <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>
    <span class="token function">handleOneTwoOrThree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">default</span><span class="token operator">:</span>
    <span class="token function">handleLargeNumber</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="4-8-4-3-default的情况要写出来"><a href="#4-8-4-3-default的情况要写出来" class="headerlink" title="4.8.4.3 default的情况要写出来"></a>4.8.4.3 default的情况要写出来</h4><p>每个switch语句都包含一个<code>default</code>语句组，即使它什么代码也不包含。</p>
<h3 id="4-8-5-注解-Annotations"><a href="#4-8-5-注解-Annotations" class="headerlink" title="4.8.5 注解(Annotations)"></a>4.8.5 注解(Annotations)</h3><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token annotation punctuation">@Nullable</span>
<span class="token keyword">public</span> String <span class="token function">getNameIfPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre>
<p>例外：单个的注解可以和签名的第一行出现在同一行。例如：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre>
<p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Partial</span> <span class="token annotation punctuation">@Mock</span> DataLoader loader<span class="token punctuation">;</span></code></pre>
<p>参数和局部变量注解没有特定规则。</p>
<h3 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h3><h4 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h4><p>块注释与其周围的代码在同一缩进级别。它们可以是<code>/* ... *</code>/风格，也可以是<code>// ...</code>风格。对于多行的<code>/* ... */</code>注释，后续行必须从<em>开始， 并且与前一行的</em>对齐。以下示例注释都是OK的。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*
 * This is          // And so           /* Or you can
 * okay.            // is this.          * even do this. */</span>
 <span class="token operator">*</span><span class="token operator">/</span></code></pre>
<p>注释不要封闭在由星号或其它字符绘制的框架里。</p>
<p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用<code>/* ... */</code>。</p>
<h3 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h3><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">protected</span> <span class="token keyword">private</span> <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">synchronized</span> <span class="token keyword">native</span> <span class="token keyword">strictfp</span></code></pre>
<p>命名约定</p>
<h2 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h2><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p>
<p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p>
<h2 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h2><h3 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h3><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p>
<h3 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h3><p>类名都以<code>UpperCamelCase</code>风格编写。</p>
<p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p>
<p>测试类的命名以它要测试的类的名称开始，以<code>Test</code>结束。例如，<code>HashTest</code>或<code>HashIntegrationTest</code>。</p>
<h3 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h3><p>方法名都以<code>lowerCamelCase</code>风格编写。</p>
<p>方法名通常是动词或动词短语。</p>
<p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如<code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p>
<h3 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h3><p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p>
<p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远<code>不打算</code>改变对象一般是不够的，它要真的一直不变才能将它示为常量。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Constants</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUMBER <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableList<span class="token operator">&lt;</span>String<span class="token operator">></span> NAMES <span class="token operator">=</span> ImmutableList<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> Joiner COMMA_JOINER <span class="token operator">=</span> Joiner<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// because Joiner is immutable</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> SomeMutableType<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_ARRAY <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">enum</span> SomeEnum <span class="token punctuation">{</span> ENUM_CONSTANT <span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Not constants</span>
<span class="token keyword">static</span> String nonFinal <span class="token operator">=</span> <span class="token string">"non-final"</span><span class="token punctuation">;</span>
<span class="token keyword">final</span> String nonStatic <span class="token operator">=</span> <span class="token string">"non-static"</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> mutableCollection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableSet<span class="token operator">&lt;</span>SomeMutableType<span class="token operator">></span> mutableElements <span class="token operator">=</span> ImmutableSet<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>mutable<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> Logger logger <span class="token operator">=</span> Logger<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> nonEmptyArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"these"</span><span class="token punctuation">,</span> <span class="token string">"can"</span><span class="token punctuation">,</span> <span class="token string">"change"</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>这些名字通常是名词或名词短语。</p>
<h3 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h3><p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p>
<p>这些名字通常是名词或名词短语。</p>
<h3 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h3><p>参数名以<code>lowerCamelCase</code>风格编写。</p>
<p>参数应该避免用单个字符命名。</p>
<h3 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h3><p>局部变量名以<code>lowerCamelCase</code>风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p>
<p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p>
<p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p>
<h3 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h3><p>类型变量可用以下两种风格之一进行命名：</p>
<ul>
<li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li>
<li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。<h2 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h2><a href="http://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB" target="_blank" rel="noopener">驼峰式命名法</a>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</li>
</ul>
<p>名字从<code>散文形式</code>(prose form)开始:</p>
<ol>
<li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li>
<li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。</li>
</ol>
<ul>
<li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li>
</ul>
<ol>
<li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：</li>
</ol>
<ul>
<li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li>
<li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li>
</ul>
<ol>
<li>最后将所有的单词连接起来得到一个标识符。<br>示例：<pre><code>Prose form                Correct               Incorrect</code></pre></li>
</ol>
<hr>
<p>“XML HTTP request”        XmlHttpRequest        XMLHTTPRequest<br>“new customer ID”         newCustomerId         newCustomerID<br>“inner stopwatch”         innerStopwatch        innerStopWatch<br>“supports IPv6 on iOS?”   supportsIpv6OnIos     supportsIPv6OnIOS<br>“YouTube importer”        YouTubeImporter<br>                          YoutubeImporter*</p>
<pre><code>加星号处表示可以，但不推荐。

&gt; Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名`checkNonempty`和`checkNonEmpty`也都是正确的。

# 编程实践
## 6.1 @Override：能用则用
只要是合法的，就把`@Override`注解给用上。

## 6.2 捕获的异常：不能忽视
除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个`AssertionError`重新抛出。)

如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。
```java
try {
  int i = Integer.parseInt(response);
  return handleNumericResponse(i);
} catch (NumberFormatException ok) {
  // it's not numeric; that's fine, just continue
}
return handleTextResponse(response);</code></pre><p>例外：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>
  emptyStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchElementException</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h2><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p>
<pre class=" language-java"><code class="language-java">Foo aFoo <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
Foo<span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// good</span>
aFoo<span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// bad</span>
<span class="token function">somethingThatYieldsAFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// very bad</span></code></pre>
<h2 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h2><p>极少会去重写<code>Object.finalize</code>。</p>
<blockquote>
<p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解<a href="http://books.google.com/books?isbn=8131726592" target="_blank" rel="noopener">Effective Java</a> 第7条款：“Avoid Finalizers”，然后不要使用它。</p>
</blockquote>
<h1 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h1><h2 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h2><h3 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h3><p>Javadoc块的基本格式如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * Multiple lines of Javadoc text are written here,
 * wrapped normally...
 */</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">method</span><span class="token punctuation">(</span>String p1<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre>
<p>或者是以下单行形式：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** An especially short bit of Javadoc. */</span></code></pre>
<p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p>
<h3 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h3><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签<code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p>
<h3 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h3><p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p>
<h2 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h2><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p>
<p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p>
<blockquote>
<p>Tip：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p>
</blockquote>
<h2 id="7-3-哪里需要使用Javadoc"><a href="#7-3-哪里需要使用Javadoc" class="headerlink" title="7.3 哪里需要使用Javadoc"></a>7.3 哪里需要使用Javadoc</h2><p>至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：</p>
<h3 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h3><p>对于简单明显的方法如<code>getFoo</code>，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p>
<p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p>
<blockquote>
<p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>， 就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p>
</blockquote>
<h3 id="7-3-2-例外：重写"><a href="#7-3-2-例外：重写" class="headerlink" title="7.3.2 例外：重写"></a>7.3.2 例外：重写</h3><p>如果一个方法重写了超类中的方法，那么Javadoc并非必需的。</p>
<h3 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h3><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p>
<p>后记<br>本文档翻译自<a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html" target="_blank" rel="noopener">Google Java Style</a>， 译者<a href="http://weibo.com/hawstein" target="_blank" rel="noopener">@Hawstein</a>,转载自<a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener">Hawstein’s Blog</a>。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题--Java集合--小米归纳</title>
    <url>/2019/03/22/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>Java 集合的脑图<br><img src="https://i.loli.net/2019/03/22/5c9432565c117.png" alt=""></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="Java-集合框架有哪些？"><a href="#Java-集合框架有哪些？" class="headerlink" title="Java 集合框架有哪些？"></a>Java 集合框架有哪些？</h2><p>Java 集合框架，可以看看 <a href="http://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">《Java 集合框架》</a> 文章。</p>
<h3 id="🦅-说出一些集合框架的优点？"><a href="#🦅-说出一些集合框架的优点？" class="headerlink" title="🦅 说出一些集合框架的优点？"></a>🦅 说出一些集合框架的优点？</h3><p>集合框架的部分优点如下：</p>
<ol>
<li>使用核心集合类降低开发成本，而非实现我们自己的集合类。</li>
<li>随着使用经过严格测试的集合框架类，代码质量会得到提高。</li>
<li>通过使用 JDK 附带的集合类，可以降低代码维护成本。</li>
<li>复用性和可操作性。</li>
</ol>
<h3 id="🦅-集合框架中的泛型有什么优点？"><a href="#🦅-集合框架中的泛型有什么优点？" class="headerlink" title="🦅 集合框架中的泛型有什么优点？"></a>🦅 集合框架中的泛型有什么优点？</h3><p>Java5 引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型。因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现 ClassCastException，因为你将会在编译时得到报错信息。</p>
<p>泛型也使得代码整洁，我们不需要使用显式转换和 <code>instanceOf</code> 操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。</p>
<h2 id="Java-集合框架的基础接口有哪些？"><a href="#Java-集合框架的基础接口有哪些？" class="headerlink" title="Java 集合框架的基础接口有哪些？"></a>Java 集合框架的基础接口有哪些？</h2><ul>
<li>Collection ，为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java 平台不提供这个接口任何直接的实现。<ul>
<li>Set ，是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。</li>
<li>List ，是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List 更像长度动态变换的数组。</li>
</ul>
</li>
<li>Map ，是一个将 key 映射到 value 的对象。一个 Map 不能包含重复的 key，每个 key 最多只能映射一个 value 。</li>
<li>一些其它的接口有 Queue、Dequeue、SortedSet、SortedMap 和 ListIterator 。<h3 id="🦅-为何-Collection-不从-Cloneable-和-Serializable-接口继承？"><a href="#🦅-为何-Collection-不从-Cloneable-和-Serializable-接口继承？" class="headerlink" title="🦅 为何 Collection 不从 Cloneable 和 Serializable 接口继承？"></a>🦅 为何 Collection 不从 Cloneable 和 Serializable 接口继承？</h3></li>
</ul>
<p>Collection 接口指定一组对象，对象即为它的元素。</p>
<ul>
<li>如何维护这些元素由 Collection 的具体实现决定。例如，一些如 List 的 Collection 实现允许重复的元素，而其它的如 Set 就不允许。</li>
<li>很多 Collection 实现有一个公有的 clone 方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为 Collection 是一个抽象表现，重要的是实现。</li>
</ul>
<p>当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制，<strong>特定的实现应该决定它是否可以被克隆和序列化</strong>。</p>
<h3 id="🦅-为何-Map-接口不继承-Collection-接口？"><a href="#🦅-为何-Map-接口不继承-Collection-接口？" class="headerlink" title="🦅 为何 Map 接口不继承 Collection 接口？"></a>🦅 为何 Map 接口不继承 Collection 接口？</h3><p>尽管 Map 接口和它的实现也是集合框架的一部分，但 Map 不是集合，集合也不是 Map。因此，Map 继承 Collection 毫无意义，反之亦然。</p>
<p>如果 Map 继承 Collection 接口，那么元素去哪儿？Map 包含 key-value 对，它提供抽取 key 或 value 列表集合( Collection )的方法，但是它不适合“一组对象”规范。</p>
<h3 id="🦅-Collection-和-Collections-的区别？"><a href="#🦅-Collection-和-Collections-的区别？" class="headerlink" title="🦅 Collection 和 Collections 的区别？"></a>🦅 Collection 和 Collections 的区别？</h3><ul>
<li>Collection ，是集合类的上级接口，继承与他的接口主要有 Set 和List 。</li>
<li>Collections ，是针对集合类的一个工具类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li>
</ul>
<h3 id="🦅-集合框架里实现的通用算法有哪些？"><a href="#🦅-集合框架里实现的通用算法有哪些？" class="headerlink" title="🦅 集合框架里实现的通用算法有哪些？"></a>🦅 集合框架里实现的通用算法有哪些？</h3><p>Java 集合框架提供常用的算法实现，比如排序和搜索。</p>
<p>Collections类包含这些方法实现。大部分算法是操作 List 的，但一部分对所有类型的集合都是可用的。部分算法有排序、搜索、混编、最大最小值。</p>
<h3 id="🦅-集合框架底层数据结构总结"><a href="#🦅-集合框架底层数据结构总结" class="headerlink" title="🦅 集合框架底层数据结构总结"></a>🦅 集合框架底层数据结构总结</h3><ol>
<li><p>List</p>
<ul>
<li>ArrayList ：Object 数组。</li>
<li>Vector ：Object 数组。</li>
<li>LinkedList ：双向链表(JDK6 之前为循环链表，JDK7 取消了循环)。</li>
</ul>
</li>
<li><p>Map</p>
<ul>
<li>HashMap ：<ul>
<li>JDK8 之前，HashMap 由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</li>
<li>JDK8 以后，在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8 ）时，将链表转化为红黑树，以减少搜索时间。</li>
</ul>
</li>
<li>LinkedHashMap ：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》 。</li>
<li>Hashtable ：数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</li>
<li>TreeMap ：红黑树（自平衡的排序二叉树）。</li>
</ul>
</li>
<li><p>Set</p>
<ul>
<li>HashSet ：无序，唯一，基于 HashMap 实现的，底层采用 HashMap 来保存元素。</li>
<li>LinkedHashSet ：LinkedHashSet 继承自 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的。</li>
<li>TreeSet ：有序，唯一，红黑树(自平衡的排序二叉树)。</li>
</ul>
</li>
</ol>
<h2 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器(Iterator)？"></a>什么是迭代器(Iterator)？</h2><p>Iterator 接口，提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素，但是不可以直接调用集合的 <code>#remove(Object Obj)</code> 方法删除，可以通过迭代器的 <code>#remove()</code> 方法删除。</p>
<h3 id="🦅-Iterator-和-ListIterator-的区别是什么？"><a href="#🦅-Iterator-和-ListIterator-的区别是什么？" class="headerlink" title="🦅 Iterator 和 ListIterator 的区别是什么？"></a>🦅 Iterator 和 ListIterator 的区别是什么？</h3><ul>
<li>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。</li>
<li>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。</li>
<li>ListIterator 实现了 Iterator 接口，并包含其他的功能。比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。</li>
</ul>
<h3 id="🦅-快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"><a href="#🦅-快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？" class="headerlink" title="🦅 快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"></a>🦅 快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？</h3><p>差别在于 ConcurrentModification 异常：</p>
<ul>
<li>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。 在 <code>java.util</code> 包下的都是快速失败。</li>
<li>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。在 <code>java.util.concurrent</code> 包下的全是安全失败的。</li>
</ul>
<h3 id="🦅-如何删除-List-中的某个元素？"><a href="#🦅-如何删除-List-中的某个元素？" class="headerlink" title="🦅 如何删除 List 中的某个元素？"></a>🦅 如何删除 List 中的某个元素？</h3><p>有两种方式，分别如下：</p>
<ul>
<li>方式一，使用 Iterator ，顺序向下，如果找到元素，则使用 remove 方法进行移除。</li>
<li>方式二，倒序遍历 List ，如果找到元素，则使用 remove 方法进行移除。</li>
</ul>
<h3 id="🦅-Enumeration-和-Iterator-接口有什么不同？"><a href="#🦅-Enumeration-和-Iterator-接口有什么不同？" class="headerlink" title="🦅 Enumeration 和 Iterator 接口有什么不同？"></a>🦅 Enumeration 和 Iterator 接口有什么不同？</h3><p>Enumeration 跟 Iterator 相比较快两倍，而且占用更少的内存。<br>但是，Iterator 相对于 Enumeration 更安全，因为其他线程不能修改当前迭代器遍历的集合对象。同时，Iterators 允许调用者从底层集合中移除元素，这些 Enumerations 都没法完成。</p>
<p>对于很多胖友，可能并未使用过 Enumeration 类，所以可以看看 <a href="http://www.runoob.com/java/java-enumeration-interface.html" target="_blank" rel="noopener">《Java Enumeration 接口》</a> 文章。</p>
<h3 id="🦅-为何-Iterator-接口没有具体的实现？"><a href="#🦅-为何-Iterator-接口没有具体的实现？" class="headerlink" title="🦅 为何 Iterator 接口没有具体的实现？"></a>🦅 为何 Iterator 接口没有具体的实现？</h3><p>Iterator 接口，定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的 Iterator 的集合类都有它自己的 Iterator 实现内部类。</p>
<p>这就允许集合类去选择迭代器是 fail-fast 还是 fail-safe 的。比如，ArrayList 迭代器是 fail-fast 的，而 CopyOnWriteArrayList 迭代器是 fail-safe 的。</p>
<h2 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别?"></a>Comparable 和 Comparator 的区别?</h2><ul>
<li>Comparable 接口，在 <code>java.lang</code> 包下，用于当前对象和其它对象的比较，所以它有一个 <code>#compareTo(Object obj)</code> 方法用来排序，该方法只有一个参数。</li>
<li>Comparator 接口，在 <code>java.util</code> 包下，用于传入的两个对象的比较，所以它有一个 <code>#compare(Object obj1, Object obj2)</code> 方法用来排序，该方法有两个参数。<br>详细的，可以看看 <a href="https://blog.csdn.net/whing123/article/details/77851737" target="_blank" rel="noopener">《Java 自定义比较器》</a> 文章，重点是如何自己实现 Comparable 和 Comparator 的方法。</li>
</ul>
<h3 id="🦅-compareTo-方法的返回值表示的意思？"><a href="#🦅-compareTo-方法的返回值表示的意思？" class="headerlink" title="🦅 compareTo 方法的返回值表示的意思？"></a>🦅 compareTo 方法的返回值表示的意思？</h3><ul>
<li>大于 0 ，表示对象大于参数对象。</li>
<li>小于 0 ，表示对象小于参数对象</li>
<li>等于 0 ，表示两者相等。</li>
</ul>
<h3 id="🦅-如何对-Object-的-List-排序？"><a href="#🦅-如何对-Object-的-List-排序？" class="headerlink" title="🦅 如何对 Object 的 List 排序？"></a>🦅 如何对 Object 的 List 排序？</h3><ul>
<li>对 Object[] 数组进行排序时，我们可以用 Arrays#sort(…) 方法。</li>
<li>对 List<object> 数组进行排序时，我们可以用 Collections#sort(…) 方法。

<h2 id="有哪些关于-Java-集合框架的最佳实践？"><a href="#有哪些关于-Java-集合框架的最佳实践？" class="headerlink" title="有哪些关于 Java 集合框架的最佳实践？"></a>有哪些关于 Java 集合框架的最佳实践？</h2><ul>
<li>基于应用的需求来选择使用正确类型的集合，这对性能来说是非常重要的。例如，如果元素的大小是固定的，并且知道优先级，我们将会使用一个 Array ，而不是 ArrayList 。</li>
<li>一些集合类允许我们指定他们的初始容量。因此，如果我们知道存储数据的大概数值，就可以避免重散列或者大小的调整。</li>
<li>总是使用泛型来保证类型安全，可靠性和健壮性。同时，使用泛型还可以避免运行时的 ClassCastException 异常。</li>
<li>在 Map 中使用 JDK 提供的不可变类作为一个 key，这样可以避免 hashcode 的实现和我们自定义类的 equals 方法。</li>
<li>应该依照接口而不是实现来编程。</li>
<li>返回零长度的集合或者数组，而不是返回一个 null ，这样可以防止底层集合是空的。</li>
</ul>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="List-和-Set-区别？"><a href="#List-和-Set-区别？" class="headerlink" title="List 和 Set 区别？"></a>List 和 Set 区别？</h2><p>List，Set 都是继承自 Collection 接口。</p>
<ul>
<li>List 特点：元素有放入顺序，元素可重复。</li>
<li>Set 特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉。</li>
</ul>
<blockquote>
<p>注意：元素虽然无放入顺序，但是元素在 Set 中的位置是有该元素的 hashcode 决定的，其位置其实是固定的。</p>
<p>另外 List 支持 for 循环，也就是通过下标来遍历，也可以用迭代器，但是 Set 只能用迭代，因为他无序，无法用下标来取得想要的值。</p>
</blockquote>
<p>Set 和 List 对比：</p>
<ul>
<li>Set：检索元素效率高，删除和插入效率低，插入和删除不会引起元素位置改变。</li>
<li>List：和数组类似，List 可以动态增长，查找元素效率低，插入删除元素效率，因为可能会引起其他元素位置改变。</li>
</ul>
<h2 id="List-和-Map-区别？"><a href="#List-和-Map-区别？" class="headerlink" title="List 和 Map 区别？"></a>List 和 Map 区别？</h2><ul>
<li>List 是对象集合，允许对象重复。</li>
<li>Map 是键值对的集合，不允许 key 重复。</li>
</ul>
<h2 id="Array-和-ArrayList-有何区别？什么时候更适合用-Array？"><a href="#Array-和-ArrayList-有何区别？什么时候更适合用-Array？" class="headerlink" title="Array 和 ArrayList 有何区别？什么时候更适合用 Array？"></a>Array 和 ArrayList 有何区别？什么时候更适合用 Array？</h2><ul>
<li>Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。</li>
<li>Array 是指定大小的，而 ArrayList 大小是固定的，可自动扩容。</li>
<li>Array 没有提供 ArrayList 那么多功能，比如 addAll、removeAll 和 iterator 等。</li>
</ul>
<p>尽管 ArrayList 明显是更好的选择，但也有些时候 Array 比较好用，比如下面的三种情况。</p>
<ul>
<li>1、如果列表的大小已经指定，大部分情况下是存储和遍历它们</li>
<li>2、对于遍历基本数据类型，尽管 Collections 使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。</li>
<li>3、如果你要使用多维数组，使用 [][] 比 List 会方便。</li>
</ul>
<h2 id="ArrayList-与-LinkedList-区别？"><a href="#ArrayList-与-LinkedList-区别？" class="headerlink" title="ArrayList 与 LinkedList 区别？"></a>ArrayList 与 LinkedList 区别？</h2><h3 id="🦅-ArrayList"><a href="#🦅-ArrayList" class="headerlink" title="🦅 ArrayList"></a>🦅 ArrayList</h3><ul>
<li>优点：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</li>
<li>缺点：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。</li>
</ul>
<h3 id="🦅-LinkedList"><a href="#🦅-LinkedList" class="headerlink" title="🦅 LinkedList"></a>🦅 LinkedList</h3><ul>
<li>优点：LinkedList 基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址。对于新增和删除操作 add 和 remove ，LinedList 比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。</li>
<li>缺点：因为 LinkedList 要移动指针，所以查询操作性能比较低。</li>
</ul>
<h3 id="🦅-适用场景分析："><a href="#🦅-适用场景分析：" class="headerlink" title="🦅 适用场景分析："></a>🦅 适用场景分析：</h3><ul>
<li><p>当需要对数据进行对随机访问的情况下，选用 ArrayList 。</p>
</li>
<li><p>当需要对数据进行多次增加删除修改时，采用 LinkedList 。</p>
<blockquote>
<p>如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用 ArrayList 。</p>
</blockquote>
</li>
<li><p>当然，绝大数业务的场景下，使用 ArrayList 就够了。主要是，注意好避免 ArrayList 的扩容，以及非顺序的插入。</p>
</li>
</ul>
<h3 id="🦅-ArrayList-是如何扩容的？"><a href="#🦅-ArrayList-是如何扩容的？" class="headerlink" title="🦅 ArrayList 是如何扩容的？"></a>🦅 ArrayList 是如何扩容的？</h3><p>直接看 <a href="https://www.cnblogs.com/kuoAT/p/6771653.html" target="_blank" rel="noopener">《ArrayList 动态扩容详解》</a> 文章，很详细。主要结论如下：</p>
<ul>
<li>如果通过无参构造的话，初始数组容量为 0 ，当真正对数组进行添加时，才真正分配容量。每次按照 1.5 倍（位运算）的比率通过 copeOf 的方式扩容。</li>
<li>在 JKD6 中实现是，如果通过无参构造的话，初始数组容量为10，每次通过 copeOf 的方式扩容后容量为原来的 1.5 倍。</li>
</ul>
<blockquote>
<p>重点是 1.5 倍扩容，这是和 HashMap 2 倍扩容不同的地方。</p>
</blockquote>
<h3 id="🦅-ArrayList-集合加入-1-万条数据，应该怎么提高效率？"><a href="#🦅-ArrayList-集合加入-1-万条数据，应该怎么提高效率？" class="headerlink" title="🦅 ArrayList 集合加入 1 万条数据，应该怎么提高效率？"></a>🦅 ArrayList 集合加入 1 万条数据，应该怎么提高效率？</h3><p>ArrayList 的默认初始容量为 10 ，要插入大量数据的时候需要不断扩容，而扩容是非常影响性能的。因此，现在明确了 10 万条数据了，我们可以直接在初始化的时候就设置 ArrayList 的容量！</p>
<p>这样就可以提高效率了~</p>
<h2 id="ArrayList-与-Vector-区别？"><a href="#ArrayList-与-Vector-区别？" class="headerlink" title="ArrayList 与 Vector 区别？"></a>ArrayList 与 Vector 区别？</h2><p>ArrayList 和 Vector 都是用数组实现的，主要有这么三个区别：</p>
<ol>
<li><p>Vector 是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果，而 ArrayList 不是。这个可以从源码中看出，Vector 类中的方法很多有 <code>synchronized</code> 进行修饰，这样就导致了 Vector 在效率上无法与 ArrayList 相比。</p>
<blockquote>
<p>Vector 是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。</p>
</blockquote>
</li>
<li><p>两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同。</p>
</li>
<li><p>Vector 可以设置增长因子，而 ArrayList 不可以。</p>
</li>
</ol>
<p>适用场景分析：</p>
<ol>
<li><p>Vector 是线程同步的，所以它也是线程安全的，而 ArrayList 是线程无需同步的，是不安全的。如果不考虑到线程的安全因素，一般用 ArrayList 效率比较高。</p>
<blockquote>
<p>实际场景下，如果需要多线程访问安全的数组，使用 CopyOnWriteArrayList 。</p>
</blockquote>
</li>
<li><p>如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用 Vector 有一定的优势。</p>
<blockquote>
<p>这种情况下，使用 LinkedList 更合适。</p>
</blockquote>
</li>
</ol>
<h2 id="HashMap-和-Hashtable-的区别？"><a href="#HashMap-和-Hashtable-的区别？" class="headerlink" title="HashMap 和 Hashtable 的区别？"></a>HashMap 和 Hashtable 的区别？</h2><blockquote>
<p>Hashtable 是在 Java 1.0 的时候创建的，而集合的统一规范命名是在后来的 Java2.0 开始约定的，而当时其他一部分集合类的发布构成了新的集合框架。</p>
</blockquote>
<ol>
<li>Hashtable 继承 Dictionary ，HashMap 继承的是 Java2 出现的 Map 接口。</li>
<li>HashMap 去掉了 Hashtable 的 contains 方法，但是加上了 containsValue 和 containsKey 方法。</li>
<li>HashMap 允许空键值，而 Hashtable 不允许。</li>
<li><strong>【重点】</strong> HashTable 是同步的，而 HashMap 是非同步的，效率上比 HashTable 要高。也因此，HashMap 更适合于单线程环境，而 HashTable 适合于多线程环境。</li>
<li>HashMap 的迭代器（Iterator）是 fail-fast 迭代器，HashTable的 enumerator 迭代器不是 fail-fast 的。</li>
<li>HashTable 中数组默认大小是 11 ，扩容方法是 old * 2 + 1 ，HashMap 默认大小是 16 ，扩容每次为 2 的指数大小。</li>
</ol>
<p>一般现在不建议用 HashTable 。主要原因是两点：</p>
<ol>
<li>HashTable 是遗留类，内部实现很多没优化和冗余。</li>
<li>即使在多线程环境下，现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用 Hashtable 。</li>
</ol>
<h3 id="🦅-Hashtable-的-size-方法中明明只有一条语句-quot-return-count-quot-，为什么还要做同步？"><a href="#🦅-Hashtable-的-size-方法中明明只有一条语句-quot-return-count-quot-，为什么还要做同步？" class="headerlink" title="🦅 Hashtable 的 #size() 方法中明明只有一条语句 &quot;return count;&quot; ，为什么还要做同步？"></a>🦅 Hashtable 的 <code>#size()</code> 方法中明明只有一条语句 <code>"return count;"</code> ，为什么还要做同步？</h3><p>同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程 A 在执行 Hashtable 的 put 方法添加数据，线程 B 则可以正常调用 <code>#size()</code> 方法读取 Hashtable 中当前元素的个数，那读取到的值可能不是最新的，可能线程 A 添加了完了数据，但是没有对 <code>count++</code> ，线程 B 就已经读取 <code>count</code> 了，那么对于线程 B 来说读取到的 <code>count</code> 一定是不准确的。</p>
<p>而给 <code>#size()</code> 方法加了同步之后，意味着线程 B 调用 <code>#size()</code> 方法只有在线程 A 调用 <code>put</code> 方法完毕之后才可以调用，这样就保证了线程安全性。</p>
<h2 id="HashSet-和-HashMap-的区别？"><a href="#HashSet-和-HashMap-的区别？" class="headerlink" title="HashSet 和 HashMap 的区别？"></a>HashSet 和 HashMap 的区别？</h2><ul>
<li>Set 是线性结构，值不能重复。HashSet 是 Set 的 hash 实现，HashSet 中值不能重复是用 HashMap 的 key 来实现的。</li>
<li>Map 是键值对映射，可以空键空值。HashMap 是 Map 的 hash 实现，key 的唯一性是通过 key 值 hashcode 的唯一来确定，value 值是则是链表结构。</li>
</ul>
<blockquote>
<p>因为不同的 key 值，可能有相同的 hashcode ，所以 value 值需要是链表结构。</p>
</blockquote>
<p>他们的共同点都是 hash 算法实现的唯一性，他们都不能持有基本类型，只能持有对象。</p>
<p>为了更好的性能，Netty 自己实现了 key 为基本类型的 HashMap ，例如 IntObjectHashMap 。</p>
<h2 id="HashSet-和-TreeSet-的区别？"><a href="#HashSet-和-TreeSet-的区别？" class="headerlink" title="HashSet 和 TreeSet 的区别？"></a>HashSet 和 TreeSet 的区别？</h2><ul>
<li>HashSet 是用一个 hash 表来实现的，因此，它的元素是无序的。添加，删除和 HashSet 包括的方法的持续时间复杂度是 O(1) 。</li>
<li>TreeSet 是用一个树形结构实现的，因此，它是有序的。添加，删除和 TreeSet 包含的方法的持续时间复杂度是 O(logn) 。<h3 id="🦅-如何决定选用-HashMap-还是-TreeMap？"><a href="#🦅-如何决定选用-HashMap-还是-TreeMap？" class="headerlink" title="🦅 如何决定选用 HashMap 还是 TreeMap？"></a>🦅 如何决定选用 HashMap 还是 TreeMap？</h3></li>
</ul>
<p>对于在 Map 中插入、删除和定位元素这类操作，HashMap 是最好的选择。<br>然而，假如你需要对一个有序的 key 集合进行遍历， TreeMap 是更好的选择。<br>基于你的 collection 的大小，也许向 HashMap 中添加元素会更快，再将 HashMap 换为 TreeMap 进行有序 key 的遍历。</p>
<h2 id="HashMap-和-ConcurrentHashMap-的区别？"><a href="#HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="HashMap 和 ConcurrentHashMap 的区别？"></a>HashMap 和 ConcurrentHashMap 的区别？</h2><p>ConcurrentHashMap 是线程安全的 HashMap 的实现。主要区别如下：</p>
<ol>
<li><p>ConcurrentHashMap 对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用 lock 锁进行保护，相对 于Hashtable 的 syn 关键字锁的粒度更精细了一些，并发性能更好。而 HashMap 没有锁机制，不是线程安全的。</p>
<blockquote>
<p>JDK8 之后，ConcurrentHashMap 启用了一种全新的方式实现,利用 CAS 算法。</p>
</blockquote>
</li>
<li><p>HashMap 的键值对允许有 null ，但是 ConCurrentHashMap 都不允许。</p>
</li>
</ol>
<h2 id="队列和栈是什么，列出它们的区别？"><a href="#队列和栈是什么，列出它们的区别？" class="headerlink" title="队列和栈是什么，列出它们的区别？"></a>队列和栈是什么，列出它们的区别？</h2><p>栈和队列两者都被用来预存储数据。</p>
<ul>
<li>java.util.Queue 是一个接口，它的实现类在Java并发包中。<ul>
<li>队列允许先进先出（FIFO）检索元素，但并非总是这样。</li>
<li>Deque 接口允许从两端检索元素。</li>
</ul>
</li>
<li>栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。<ul>
<li>Stack 是一个扩展自 Vector 的类，而 Queue 是一个接口。</li>
</ul>
</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="HashMap-的工作原理是什么？"><a href="#HashMap-的工作原理是什么？" class="headerlink" title="HashMap 的工作原理是什么？"></a>HashMap 的工作原理是什么？</h2><p>我们知道在 Java 中最常用的两种结构是数组和模拟指针（引用），几乎所有的数据结构都可以利用这两种来组合实现，HashMap 也是如此。实际上 HashMap 是一个“<strong>链表散列</strong>”。</p>
<p>HashMap 是基于 hashing 的原理。</p>
<p>HashMap 图解<br><img src="https://i.loli.net/2019/03/22/5c947041a1fd1.png" alt=""></p>
<ul>
<li>我们使用 <code>#put(key, value)</code> 方法来存储对象到 HashMap 中，使用 <code>get(key)</code> 方法从 HashMap 中获取对象。</li>
<li>当我们给 <code>#put(key, value)</code> 方法传递键和值时，我们先对键调用 <code>#hashCode()</code> 方法，返回的 hashCode 用于找到 bucket 位置来储存 Entry 对象。</li>
</ul>
<h3 id="🦅-当两个对象的-hashCode-相同会发生什么？"><a href="#🦅-当两个对象的-hashCode-相同会发生什么？" class="headerlink" title="🦅 当两个对象的 hashCode 相同会发生什么？"></a>🦅 当两个对象的 hashCode 相同会发生什么？</h3><p>因为 hashcode 相同，所以它们的 bucket 位置相同，“碰撞”会发生。</p>
<p>因为 HashMap 使用链表存储对象，这个 Entry（包含有键值对的 Map.Entry 对象）会存储在链表中。</p>
<h3 id="🦅-hashCode-和-equals-方法有何重要性？"><a href="#🦅-hashCode-和-equals-方法有何重要性？" class="headerlink" title="🦅 hashCode 和 equals 方法有何重要性？"></a>🦅 hashCode 和 equals 方法有何重要性？</h3><p>HashMap 使用 key 对象的 <code>#hashCode()</code> 和 <code>#equals(Object obj)</code> 方法去决定 key-value 对的索引。当我们试着从 HashMap 中获取值的时候，这些方法也会被用到。</p>
<ul>
<li>如果这两个方法没有被正确地实现，在这种情况下，两个不同 Key 也许会产生相同的 <code>#hashCode()</code> 和 <code>#equals(Object obj)</code> 输出，HashMap 将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。</li>
</ul>
<p>同样的，所有不允许存储重复数据的集合类都使用 <code>#hashCode()</code> 和 <code>#equals(Object obj)</code> 去查找重复，所以正确实现它们非常重要。<code>#hashCode()</code> 和 <code>#equals(Object obj)</code> 方法的实现，应该遵循以下规则：</p>
<ul>
<li>如果 <code>o1.equals(o2)</code> ，那么 <code>o1.hashCode() == o2.hashCode()</code> 总是为 true 的。</li>
<li>如果 <code>o1.hashCode() == o2.hashCode()</code> ，并不意味 <code>o1.equals(o2)</code> 会为 true 。</li>
</ul>
<h3 id="🦅-HashMap-默认容量是多少？"><a href="#🦅-HashMap-默认容量是多少？" class="headerlink" title="🦅 HashMap 默认容量是多少？"></a>🦅 HashMap 默认容量是多少？</h3><p>默认容量都是 16 ，负载因子是 0.75 。就是当 HashMap 填充了 75% 的 busket 是就会扩容，最小的可能性是（ 16 * 0.75 = 12 ），一般为原内存的 2 倍。</p>
<h3 id="🦅-有哪些顺序的-HashMap-实现类？"><a href="#🦅-有哪些顺序的-HashMap-实现类？" class="headerlink" title="🦅 有哪些顺序的 HashMap 实现类？"></a>🦅 有哪些顺序的 HashMap 实现类？</h3><ul>
<li>LinkedHashMap ，是基于元素进入集合的顺序或者被访问的先后顺序排序。</li>
<li>TreeMap ，是基于元素的固有顺序 (由 Comparator 或者 Comparable 确定)。</li>
</ul>
<h3 id="🦅-我们能否使用任何类作为-Map-的-key？"><a href="#🦅-我们能否使用任何类作为-Map-的-key？" class="headerlink" title="🦅 我们能否使用任何类作为 Map 的 key？"></a>🦅 我们能否使用任何类作为 Map 的 key？</h3><p>我们可以使用任何类作为 Map 的 key ，然而在使用它们之前，需要考虑以下几点：</p>
<ol>
<li>如果类重写了 equals 方法，它也应该重写 hashcode 方法。</li>
<li>类的所有实例需要遵循与 equals 和 hashcode 相关的规则。</li>
<li>如果一个类没有使用 equals ，你不应该在 hashcode 中使用它。</li>
<li>用户自定义 key 类的最佳实践是使之为不可变的，这样，hashcode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashcode 和 equals 在未来不会改变，这样就会解决与可变相关的问题了。</li>
</ol>
<blockquote>
<p>比如，我有一个 类MyKey ，在 HashMap 中使用它。代码如下：</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//传递给MyKey的name参数被用于equals()和hashCode()中</span>
MyKey key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyKey</span><span class="token punctuation">(</span><span class="token string">'Pankaj'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//assume hashCode=1234</span>
myHashMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">'Value'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 以下的代码会改变key的hashCode()和equals()值</span>
key<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">'Amit'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//assume new hashCode=7890</span>
<span class="token comment" spellcheck="true">//下面会返回null，因为HashMap会尝试查找存储同样索引的key，而key已被改变了，匹配失败，返回null</span>
myHashMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyKey</span><span class="token punctuation">(</span><span class="token string">'Pankaj'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>那就是为何 String 和 Integer 被作为 HashMap 的 key 大量使用。</p>
<h3 id="🦅-HashMap-的长度为什么是-2-的幂次方？"><a href="#🦅-HashMap-的长度为什么是-2-的幂次方？" class="headerlink" title="🦅 HashMap 的长度为什么是 2 的幂次方？"></a>🦅 HashMap 的长度为什么是 2 的幂次方？</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p>
<p>这个算法应该如何设计呢？我们首先可能会想到采用 <code>%</code> 取余的操作来实现。但是，重点来了：</p>
<p>取余( <code>%</code> )操作中如果除数是 2 的幂次则等价于与其除数减一的与( <code>&amp;</code> )操作（也就是说 <code>hash % length == hash &amp; (length - 1)</code> 的前提是 length 是 2 的 n 次方；）。<br>并且，采用二进制位操作 <code>&amp;</code>，相对于 <code>%</code> 能够提高运算效率，</p>
<p>这就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<h2 id="HashSet-的工作原理是什么？"><a href="#HashSet-的工作原理是什么？" class="headerlink" title="HashSet 的工作原理是什么？"></a>HashSet 的工作原理是什么？</h2><p>HashSet 是构建在 HashMap 之上的 Set hashing 实现类。让我们直接撸下源码，代码如下：</p>
<pre class=" language-java"><code class="language-java">
<span class="token keyword">private</span> <span class="token keyword">transient</span> HashMap<span class="token operator">&lt;</span>E<span class="token punctuation">,</span>Object<span class="token operator">></span> map<span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><code>map</code> 属性，当我们创建一个 HashMap 对象时，其内部也会创建一个 <code>map</code> 对象。后续 HashSet 所有的操作，实际都是基于这个 <code>map</code> 之上的封装。</li>
<li><code>PRESENT</code> 静态属性，所有 <code>map</code> 中 KEY 对应的值，都是它，避免重复创建。</li>
<li>OK ，再来看一眼 add 方法，代码如下：</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>是不是一目了然。</p>
<h3 id="🦅-HashSet-如何检查重复？"><a href="#🦅-HashSet-如何检查重复？" class="headerlink" title="🦅 HashSet 如何检查重复？"></a>🦅 HashSet 如何检查重复？</h3><p>如下摘取自 《Head First Java》 第二版：</p>
<p>当你把对象加入 HashSet 时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较。</p>
<ul>
<li>如果没有相符的 hashcode ，HashSet会假设对象没有重复出现。</li>
<li>但是如果发现有相同 hashcode 值的对象，这时会调用 equals 方法来检查 hashcode 相等的对象是否真的相同。<ul>
<li>如果两者相同，HashSet 就不会让加入操作成功。</li>
<li>如果两者不同，HashSet 就会让加入操作成功。</li>
</ul>
</li>
</ul>
<h2 id="EnumSet-是什么？"><a href="#EnumSet-是什么？" class="headerlink" title="EnumSet 是什么？"></a>EnumSet 是什么？</h2><p><code>java.util.EnumSet</code> ，是使用枚举类型的集合实现。</p>
<ul>
<li>当集合创建时，枚举集合中的所有元素必须来自单个指定的枚举类型，可以是显示的或隐示的。EnumSet 是不同步的，不允许值为 null 的元素。</li>
<li>它也提供了一些有用的方法，比如 <code>#copyOf(Collection c)</code>、<code>#of(E first, E... rest)</code> 和 <code>#complementOf(EnumSet s)</code> 方法。<br>关于 EnumSet 的源码解析，见 <a href="https://blog.csdn.net/u010887744/article/details/50834738" target="_blank" rel="noopener">《EnumSet 源码分析》</a> 文章。</li>
</ul>
<h2 id="TODO-TreeMap-原理"><a href="#TODO-TreeMap-原理" class="headerlink" title="TODO TreeMap 原理"></a>TODO TreeMap 原理</h2><p>Java 中的 TreeMap 是使用红黑树实现的。</p>
<p>TODO TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</p>
<p>等到源码解析后，在进行补充。</p>
<h2 id="Java-Priority-Queue-是什么"><a href="#Java-Priority-Queue-是什么" class="headerlink" title="Java Priority Queue 是什么?"></a>Java Priority Queue 是什么?</h2><p>PriorityQueue 是一个基于优先级堆的无界队列，它的元素都以他们的自然顺序有序排列。</p>
<ul>
<li>在它创建的时候，我们可以可以提供一个比较器 Comparator 来负责PriorityQueue 中元素的排序。</li>
<li>PriorityQueue 不允许 <code>null</code> 元素，不允许不提供自然排序的对象，也不允许没有任何关联 Comparator 的对象。<br>最后，PriorityQueue 不是线程安全的，在执行入队和出队操作它需要 <code>O(log(n))</code> 的时间复杂度。</li>
</ul>
<h3 id="🦅-poll-方法和-remove-方法的区别？"><a href="#🦅-poll-方法和-remove-方法的区别？" class="headerlink" title="🦅 poll 方法和 remove 方法的区别？"></a>🦅 poll 方法和 remove 方法的区别？</h3><p>poll 和 remove 方法，都是从队列中取出一个元素，差别在于：</p>
<ul>
<li>poll 方法，在获取元素失败的时候会返回空</li>
<li>remove() 方法，失败的时候会抛出异常。</li>
</ul>
<h3 id="🦅-LinkedHashMap-和-PriorityQueue-的区别是什么？"><a href="#🦅-LinkedHashMap-和-PriorityQueue-的区别是什么？" class="headerlink" title="🦅 LinkedHashMap 和 PriorityQueue 的区别是什么？"></a>🦅 LinkedHashMap 和 PriorityQueue 的区别是什么？</h3><ul>
<li>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，LinkedHashMap 维持的顺序是元素插入的顺序。</li>
<li>当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</li>
</ul>
</object></li></ul><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 SecurityContext 询问调用方数据</title>
    <url>/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%204%20%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>Java EE 8 Security API 入门，第 4 部分</p>
<blockquote>
<p><strong>关于本系列</strong></p>
<p>期盼已久的新 Java EE Security API (JSR 375) 推动 Java 企业安全性进入了云和微服务计算时代。本系列将展示新安全机制如何简化和标准化各种 Java EE 容器实现之间的安全处理，然后帮助您开始在受云支持的项目中使用它们。</p>
</blockquote>
<blockquote>
<p>此内容是该系列 4 部分中的第 4 部分： Java EE 8 Security API 入门</p>
<ul>
<li><a href="/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%201%20%E9%83%A8%E5%88%86/">第 1 部分: 针对云和微服务平台的 Java 企业安全性</a></li>
<li><a href="/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%202%20%E9%83%A8%E5%88%86/">第 2 部分: 通过 HttpAuthenticationMechanism 执行 Web 身份验证</a></li>
<li><a href="/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%203%20%E9%83%A8%E5%88%86/">第 3 部分: 通过 IdentityStore 安全地访问用户凭证</a></li>
<li><a href="http://localhost:4000/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%204%20%E9%83%A8%E5%88%86/" target="_blank" rel="noopener">第 4 部分: 通过 SecurityContext 询问调用方数据</a></li>
</ul>
</blockquote>
<p>本系列的上一篇文章介绍了 IdentityStore，这是一个抽象，用于设置和配置对 Java™ Web 应用程序中的用户凭证数据的安全访问。尽管开发人员能结合使用 IdentityStore 和 HttpAuthenticationMechanism 来实现强大的内置身份验证和授权，但 HttpAuthenticationMechanism 的声明性安全模型无法满足某些安全需求。这时 SecurityContext API 就派上了用场。</p>
<p>在本文中，您将了解如何使用 SecurityContext 以编程方式扩展 <a href="https://www.ibm.com/developerworks/cn/java/j-javaee8-security-api-2/index.html" target="_blank" rel="noopener">HttpAuthenticationMechanism</a>，从而使您的 Web 应用程序能拒绝或允许访问应用程序资源。请注意，本文中的示例基于一个 servlet 容器。</p>
<p><a href="https://github.com/readlearncode/Java-EE-8-Sampler/tree/master/security-1-0" target="_blank" rel="noopener">获取代码</a></p>
<h1 id="安装-Soteria"><a href="#安装-Soteria" class="headerlink" title="安装 Soteria"></a>安装 Soteria</h1><p>我们将使用 Java EE 8 Security API 参考实现 Soteria 来探索 IdentityStore。您可以通过两种方式之一获取 Soteria。</p>
<h2 id="1-在-POM-中显式指定-Soteria"><a href="#1-在-POM-中显式指定-Soteria" class="headerlink" title="1.在 POM 中显式指定 Soteria"></a>1.在 POM 中显式指定 Soteria</h2><p>使用以下 Maven 坐标在 POM 中指定 Soteria：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.glassfish.soteria<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javax.security.enterprise<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
<h2 id="2-使用内置的-Java-EE-8-坐标"><a href="#2-使用内置的-Java-EE-8-坐标" class="headerlink" title="2.使用内置的 Java EE 8 坐标"></a>2.使用内置的 Java EE 8 坐标</h2><p>符合 Java EE 8 规范的服务器将拥有自己的新 Java EE 8 Security API 实现，否则它们会依靠 Sotoria 的实现。无论如何，您都只需要 Java EE 8 坐标：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>javax<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javaee-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
<p>SecurityContext 接口位于 javax.security.enterprise 包中。</p>
<h1 id="SecurityContext-的用途"><a href="#SecurityContext-的用途" class="headerlink" title="SecurityContext 的用途"></a>SecurityContext 的用途</h1><p>创建 SecurityContext API 是为了跨 servlet 和 EJB 容器提供一致的应用程序安全保护方法。安全上下文可用于访问与目前已验证用户有关的安全相关信息，这可以通过编程方式触发一个基于 Web 的身份验证流程的启动。</p>
<p>Servlet 和 EJB 容器实现安全上下文对象的方式类似，但存在差异。例如，要获取某个用户在 servlet 容器内的身份，将会使用一个 HttpServletRequest 实例并调用 getUserPrincipal() 方法来返回一个 <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/UserPrincipal.html" target="_blank" rel="noopener">UserPrincipal</a> 对象。在 EJB 容器中，会在一个 EJBContext 实例上调用一个同名的方法。类似地，如果您想要测试某个用户是否属于某个容器角色，则会在 servlet 容器中的 HttpServletRequest 实例上调用 isUserRole() 方法。在 EJB 容器中，会在 EJBContext 实例上调用 isCallerInRole() 方法。</p>
<p>通过提供一种单一机制，以编程方式跨 servlet 和 EJB 容器获取身份验证和授权信息，新的 SecurityContext 解决了这些和其他差异。新的 Java EE 8 Security API 规范规定，servlet 中必须包含 SecurityContext，而且 EJB 容器应与 Java EE 8 兼容。一些服务器供应商也可能在其他容器中提供 SecurityContext。</p>
<h1 id="SecurityContext-的工作原理"><a href="#SecurityContext-的工作原理" class="headerlink" title="SecurityContext 的工作原理"></a>SecurityContext 的工作原理</h1><p>SecurityContext 接口为编程性安全提供了一个入口点，而且是一种<a href="http://www.cdi-spec.org/" target="_blank" rel="noopener">可注入的类型</a>。它由以下 5 个方法组成，每个方法都没有默认实现。</p>
<h2 id="调用方数据方法"><a href="#调用方数据方法" class="headerlink" title="调用方数据方法"></a>调用方数据方法</h2><ul>
<li>getCallerPrincipal() 方法 获取表示当前已验证用户姓名的、特定于容器的主体。如果当前调用方未经身份验证，则返回 null。返回的主体类型可能与 HttpAuthenticationMechanism 最初建立的类型不同。这个 getCallerPrincipal() 方法与 EJBContext 接口上的同名方法之间的重要区别是，它返回一个 Principal 实例，其中包含未经身份验证的用户的 null 名称。</li>
<li>getPrincipalsByType() 方法 从经身份验证的调用方的 Subject 返回所有指定类型的 Principal；如果未找到该类型或当前用户未经身份验证，则返回一个空集合。当容器的调用方主体与应用程序的调用方主体具有不同类型时，或者应用程序只需要其调用方主体所提供的信息时，可以使用此方法。</li>
<li>isCallerInRole() 方法 确定调用方是否包含在以 String 形式传入的角色中。如果用户拥有该角色，则返回 true；否则返回 false。调用此方法所返回的结果，与执行特定于容器的调用时相同。如果 SecurityContext.isUserInRole() 返回 true，那么调用 HttpServletRequest.isUserInRole() 或 EJBContext.isCallerInRole() 将返回 true。</li>
</ul>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><ul>
<li>hasAccessToWebResource() 方法 确定调用方能否访问当前应用程序中的给定 HTTP 方法的给定 Web 资源。这是依据 Servlet 4.0 的安全约束规范在应用程序的安全约束中进行配置的。</li>
<li>authenticate() 方法 以编程方式触发容器开始或继续与调用方进行基于 HTTP 的身份验证对话，就好像客户端执行了调用来访问该资源一样。此方法依赖于一个有效的 servlet 上下文，因为它需要一个 HttpServletRequest 和 HttpServletResponse 实例。此方法仅在 servlet 容器中有效。</li>
</ul>
<p>在大致了解这些方法和它们的功能后，我们将看一些代码示例。下面的所有示例都适用于 Servlet 4.0 Web 应用程序中的 SecurityContext 方法。</p>
<h1 id="示例-1：在-servlet-中测试调用方数据"><a href="#示例-1：在-servlet-中测试调用方数据" class="headerlink" title="示例 1：在 servlet 中测试调用方数据"></a>示例 1：在 servlet 中测试调用方数据</h1><h2 id="SecurityContext-的-getCallerPrincipal-、getPrincipalsByType-和-isCallerInRole-方法"><a href="#SecurityContext-的-getCallerPrincipal-、getPrincipalsByType-和-isCallerInRole-方法" class="headerlink" title="SecurityContext 的 getCallerPrincipal()、getPrincipalsByType() 和 isCallerInRole() 方法"></a>SecurityContext 的 getCallerPrincipal()、getPrincipalsByType() 和 isCallerInRole() 方法</h2><p>清单 3 将 SecurityContext 的 3 个用于测试调用方数据的方法组合到一个 servlet 中，以便演示它们的用法。在下面的示例中，SecurityContext 可用作一个 CDI bean，所以可注入到任何上下文感知的实例中。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">"/securityContextServlet"</span><span class="token punctuation">)</span> 
<span class="token annotation punctuation">@ServletSecurity</span><span class="token punctuation">(</span><span class="token annotation punctuation">@HttpConstraint</span><span class="token punctuation">(</span>rolesAllowed <span class="token operator">=</span> <span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecurityContextServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span> 
    <span class="token annotation punctuation">@Inject</span> 
    <span class="token keyword">private</span> SecurityContext securityContext<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span> 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span> 
        <span class="token comment" spellcheck="true">// Example 1: Is the caller is one of the three roles: admin, user and demo </span>

        PrintWriter pw <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">boolean</span> role <span class="token operator">=</span> securityContext<span class="token punctuation">.</span><span class="token function">isCallerInRole</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        pw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"User has role 'admin': "</span> <span class="token operator">+</span> role <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        role <span class="token operator">=</span> securityContext<span class="token punctuation">.</span><span class="token function">isCallerInRole</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"User has role 'user': "</span> <span class="token operator">+</span> role <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        role <span class="token operator">=</span> securityContext<span class="token punctuation">.</span><span class="token function">isCallerInRole</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pw<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"User has role 'demo': "</span> <span class="token operator">+</span> role <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

        <span class="token comment" spellcheck="true">// Example 2: What is the caller principal name </span>
        String contextName <span class="token operator">=</span> null<span class="token punctuation">;</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>securityContext<span class="token punctuation">.</span><span class="token function">getCallerPrincipal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            contextName <span class="token operator">=</span> securityContext<span class="token punctuation">.</span><span class="token function">getCallerPrincipal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span> 
        response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"context username: "</span> <span class="token operator">+</span> contextName <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

        <span class="token comment" spellcheck="true">// Example 3: Retrieve all CustomPrincipal </span>
        Set<span class="token operator">&lt;</span>CustomPrincipal<span class="token operator">></span> customPrincipals <span class="token operator">=</span> securityContext <span class="token punctuation">.</span><span class="token function">getPrincipalsByType</span><span class="token punctuation">(</span>CustomPrincipal<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>CustomPrincipal customPrincipal <span class="token operator">:</span> customPrincipals<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>customPrincipal<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span></code></pre>
<p>在第一个示例中，安全上下文用于测试目前已经过身份验证的用户所参与的逻辑角色。测试的角色包括 admin、user 和 demo。</p>
<p>在第二个示例中，将了解如何使用 getCallerPrincipal() 方法来检索表示已经过身份验证的调用方的名称的、特定于平台的调用方主体。如果当前用户未经过身份验证，此方法将会返回 null，所以必须执行适当的 null 检查。</p>
<p>最后一个示例将展示如何使用 getPrincipalsByType() 方法按类型检索一组主体。</p>
<p>接下来，在清单 4 中，您会看到一个实现 Principal 接口的自定义主体。对 getPrincipalsByType() 方法的调用将检索一组此类型的主体。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomPrincipal</span> <span class="token keyword">implements</span> <span class="token class-name">Principal</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> String name<span class="token punctuation">;</span> 

    <span class="token keyword">public</span> <span class="token function">CustomPrincipal</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 

    <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">return</span> name<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span></code></pre>
<h1 id="示例-2：测试调用方对-Web-资源的访问"><a href="#示例-2：测试调用方对-Web-资源的访问" class="headerlink" title="示例 2：测试调用方对 Web 资源的访问"></a>示例 2：测试调用方对 Web 资源的访问</h1><h2 id="SecurityContext-的-hasAccessToWebResources-方法"><a href="#SecurityContext-的-hasAccessToWebResources-方法" class="headerlink" title="SecurityContext 的 hasAccessToWebResources() 方法"></a>SecurityContext 的 hasAccessToWebResources() 方法</h2><p>清单 5 将展示如何使用 hasAccessToWebResource() 来测试调用方使用指定的 HTTP 方法对给定 Web 资源的访问。在这里，我将 SecurityContext 实例注入到了 servlet 中，并调用了 hasAccessToWebResource()。我们想要测试调用方是否拥有位于 URI /secretServlet 上的资源的 GET 访问权（如清单 6 所示），所以我们将显示的参数传递给该方法。如果调用方拥有 admin 角色，该方法将返回 true；否则会返回 false。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">"/hasAccessServlet"</span><span class="token punctuation">)</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HasAccessServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Inject</span> <span class="token keyword">private</span> SecurityContext securityContext<span class="token punctuation">;</span> 

    <span class="token annotation punctuation">@Override</span> 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">,</span> HttpServletResponse res<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span> 
        <span class="token keyword">boolean</span> hasAccess <span class="token operator">=</span> securityContext<span class="token punctuation">.</span><span class="token function">hasAccessToWebResource</span><span class="token punctuation">(</span><span class="token string">"/secretServlet"</span><span class="token punctuation">,</span> <span class="token string">"GET"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">"/secretServlet"</span><span class="token punctuation">)</span> 
<span class="token annotation punctuation">@ServletSecurity</span><span class="token punctuation">(</span><span class="token annotation punctuation">@HttpConstraint</span><span class="token punctuation">(</span>rolesAllowed <span class="token operator">=</span> <span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecretServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre>
<h1 id="示例-3：身份验证调用方的访问"><a href="#示例-3：身份验证调用方的访问" class="headerlink" title="示例 3：身份验证调用方的访问"></a>示例 3：身份验证调用方的访问</h1><h2 id="SecurityContext-的-authenticate-方法"><a href="#SecurityContext-的-authenticate-方法" class="headerlink" title="SecurityContext 的 authenticate() 方法"></a>SecurityContext 的 authenticate() 方法</h2><p>最后一个示例将展示如何使用 authenticate() 方法来验证用户输入的凭证。首先，用户将一个用户名和密码输入 JSF 中，如清单 7 所示。提交后，LoginBean 处理并验证凭证，如清单 8 所示。</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name"><span class="token namespace">jsf:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span>Username <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">></span></span> 
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">jsf:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">jsf:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#{loginBean.username}<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span> 
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span>Password <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">></span></span> 
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">jsf:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">jsf:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#{loginBean.password}<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span> 
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Login<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">jsf:</span>action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#{loginBean.login}<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></code></pre>
<p>输入的 username 和 password 是在 LoginBean 上设置的（清单 8），以便生成一个 Credential 实例。然后使用此凭证创建一个 AuthenticationParameters 实例。此实例与 HttpServletRequest 和 HttpServletResponse 实例一起传递给 authenticate() 方法，后两个实例是从 FacesContext 检索获得的。然后，AuthenticationParameters 实例返回 AuthenticationStatus 枚举的一个值。</p>
<p>AuthenticationStatus 枚举表明了身份验证流程的状态，并且可以是以下值之一：</p>
<ul>
<li><strong>NOT_DONE</strong>：调用了身份验证机制，但它决定不执行身份验证。通常，在采用抢先安全保护时会返回此状态。</li>
<li><strong>SEND_CONTINUE</strong>：调用了身份验证机制，而且发起了与调用方的多步骤身份验证对话。</li>
<li><strong>SUCCESS</strong>：调用了身份验证机制，而且已成功对调用方进行身份验证。调用方主体可用。<br>SEND_FAILURE：调用了身份验证机制，但调用方未成功通过身份验证，因此调用方主体不可用。</li>
</ul>
<p>请注意，在 Java EE 8 中，JSF 2.3 已允许注入 FacesContext。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Named</span> 
<span class="token annotation punctuation">@RequestScoped</span> 
<span class="token annotation punctuation">@FacesConfig</span><span class="token punctuation">(</span>version <span class="token operator">=</span> JSF_2_3<span class="token punctuation">)</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginBean</span> <span class="token punctuation">{</span> 
    <span class="token annotation punctuation">@Inject</span> 
    <span class="token keyword">private</span> SecurityContext securityContext<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Inject</span> 
    <span class="token keyword">private</span> FacesContext facesContext<span class="token punctuation">;</span> 
    <span class="token keyword">private</span> String username<span class="token punctuation">,</span> password<span class="token punctuation">;</span> 

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Credential credential <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UsernamePasswordCredential</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Password</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        AuthenticationStatus status <span class="token operator">=</span> securityContext<span class="token punctuation">.</span><span class="token function">authenticate</span><span class="token punctuation">(</span> <span class="token function">getRequestFrom</span><span class="token punctuation">(</span>facesContext<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getResponseFrom</span><span class="token punctuation">(</span>facesContext<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">withParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">credential</span><span class="token punctuation">(</span>credential<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>SEND_CONTINUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            facesContext<span class="token punctuation">.</span><span class="token function">responseComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>SEND_FAILURE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">addError</span><span class="token punctuation">(</span>facesContext<span class="token punctuation">,</span> <span class="token string">"Authentication failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span> 

    <span class="token keyword">private</span> <span class="token keyword">static</span> HttpServletResponse <span class="token function">getResponseFrom</span><span class="token punctuation">(</span>FacesContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">return</span> <span class="token punctuation">(</span>HttpServletResponse<span class="token punctuation">)</span> context <span class="token punctuation">.</span><span class="token function">getExternalContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 

    <span class="token keyword">private</span> <span class="token keyword">static</span> HttpServletRequest <span class="token function">getRequestFrom</span><span class="token punctuation">(</span>FacesContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">return</span> <span class="token punctuation">(</span>HttpServletRequest<span class="token punctuation">)</span> context <span class="token punctuation">.</span><span class="token function">getExternalContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span> 

    <span class="token comment" spellcheck="true">// Getter and setters omitted </span>
<span class="token punctuation">}</span></code></pre>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>在本系列中，您了解了新 Java EE 8 Security API 如何将一些最受欢迎且值得信赖的 Java EE 技术集成到常见的企业身份验证和授权例程中。除了其他特性之外，Java 开发人员社区想要一种在 servlet 和 EJB 容器间保持一致的简化的安全模型，SecurityContext 恰好提供了此模型。</p>
<p>尽管我的示例基于一个 servlet 容器，但 SecurityContext 使得跨 servlet 和 EJB 容器一致地询问调用方主体变得很简单。如果开发人员需要为最近的 Java EE 应用程序组合 XML 与基于注解的配置，他们会对迁移到纯注解框架感到高兴。新 Security API 也支持 XML 声明，这使得将旧项目迁移到 Java EE 8 变得相对简单和轻松，而没有任何更改安全性配置的迫切需求。</p>
<p>希望您喜欢本系列，并能将新知识应用到实践中。一定要在下面的最终测验中测试您的理解情况。</p>
<h1 id="测试您的知识"><a href="#测试您的知识" class="headerlink" title="测试您的知识"></a>测试您的知识</h1><ol>
<li>以下哪些方法属于 SecurityContext 接口？<ol>
<li>getCallerPrincipal()</li>
<li>isUserRole()</li>
<li>getPrincipalsByType()</li>
<li>isCallerInRole()</li>
<li>isCallerPrincipal()</li>
</ol>
</li>
<li>hasAccessToWebResource() 方法对什么执行测试？<ol>
<li>指定的用户能否访问给定的资源</li>
<li>servlet 是否有权访问资源</li>
<li>调用方能否访问指定的资源</li>
<li>调用方能否访问远程 Web 资源</li>
</ol>
</li>
<li>getPrincipalsByType() 方法会返回什么？<ol>
<li>来自调用方 Subject 的一组给定类型的 Principal</li>
<li>来自上下文的给定类型的 Principal</li>
<li>一个给定类型的 Principal 列表</li>
<li>如果调用方未经授权，则返回 Null</li>
<li>如果调用方未经授权，则返回一个空集合</li>
</ol>
</li>
<li>以下哪些是 getCallerPrincipal() 方法的行为？<ol>
<li>返回经过验证的调用方的名称</li>
<li>如果当前调用方未经过身份验证，则返回 null</li>
<li>返回调用方的一组 Principal</li>
<li>返回经过验证的调用方的特定于平台的 Principal</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">问题</th>
<th align="center">答案</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">134</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">15</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">24</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java EE</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet 4.0 入门</title>
    <url>/2020/10/20/Java/javaEE/servlet4/</url>
    <content><![CDATA[<blockquote><p>Servlet 4.0 入门</p>
<footer><strong>Alex Theedom</strong><cite><a href="https://www.ibm.com/developerworks/cn/java/j-javaee8-servlet4/index.html?ca=drs-" target="_blank" rel="noopener">Servlet 4.0 入门</a></cite></footer></blockquote>

<p>Java™ Servlet API 是主流服务器端 Java 的基本构建块，也是 Java EE 技术的一部分，例如，用于 Web 服务的 JAX - RS、JSF (JavaServer Faces) 和 JSP (JavaServer Pages)。Java servlet 也独立存在，提供一系列支持动态 Web 内容的功能。其中包括过滤器、Web 安全性以及用于处理 HTTP 请求和响应的功能。</p>
<p>Servlet 4.0 是 API 的最新版本，也是 <a href="https://www.ibm.com/developerworks/cn/java/j-whats-new-in-javaee-8/index.html" target="_blank" rel="noopener">Java EE 8</a> 规范的核心更新。正如您将在本教程中了解到的，Servlet 4.0 已为 HTTP/2 准备就绪，完全包含服务器推送，同时还将其扩展到基于 servlet 的技术，如 JSF 2.3。本教程还介绍了新型 HttpServletMapping 接口, 它支持运行时发现 servlet 的映射 URL。</p>
<blockquote>
<p>HTTP/2 是什么？<br>HTTP/2 的首要目标是改善 Web 应用程序用户的体验。HTTP 1.1 是一个二进制协议，它拥有包括轻量型、安全和快速在内的所有优势。HTTP/2 保持了原始 HTTP 协议的语义，但更改了在系统之间传输数据的方式。请查看我的文章“HTTP/2 幕后原理”（developerWorks，2017 年 7 月），深入了解 HTTP/2。</p>
</blockquote>
<p>获取代码</p>
<h1 id="Servlet-简介"><a href="#Servlet-简介" class="headerlink" title="Servlet 简介"></a>Servlet 简介</h1><p>Java servlet 是一项基于 HTTP 协议运行的服务器端技术。Servlet 等待客户端向服务器发送请求消息，然后向客户端返回响应消息。请求和响应消息由两部分组成：</p>
<ul>
<li>标头包含消息相关信息。</li>
<li>主体包含消息的有效载荷，即其内容。</li>
</ul>
<p>在传统交换中，客户端通过从浏览器或 curl 等另一个 HTTP 客户端请求特定的 URL 来调用 servlet。</p>
<p>在清单 1 中，请求 servlet 路径时，会激活该 servlet 。请求会被委派给相应的方法，这由 HTTP 方法来确定。在这种情况下，由于请求是 GET 方法请求，因此通过 Java servlet 的 doGet() 方法来处理该请求。</p>
<p>以下交换的 servlet 路径是：<a href="http://hostname/applicationroot/showlogoservlet" target="_blank" rel="noopener">http://hostname/applicationroot/showlogoservlet</a>.</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">"/showlogoservlet"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>

   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>
                        HttpServletResponse response<span class="token punctuation">)</span> 
                        <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>

       <span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span><span class="token string">"/showlogo.jsp"</span><span class="token punctuation">)</span>
         <span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h1 id="Servlet-4-0-的主要新功能"><a href="#Servlet-4-0-的主要新功能" class="headerlink" title="Servlet 4.0 的主要新功能"></a>Servlet 4.0 的主要新功能</h1><p>Servlet 4.0 的主要新功能为服务器推送和全新 API，该 API 可在运行时发现 servlet 的 URL 映射。</p>
<p>服务器推送是最直观的 HTTP/2 强化功能，通过 PushBuilder 接口在 servlet 中公开。服务器推送功能还在 JavaServer Faces API 中实现，并在 RenderResponsePhase 生命周期内调用，以便 JSF 页面可以利用其增强性能。</p>
<p>全新 servlet 映射发现接口 HttpServletMapping 使框架能够获取有关激活给定 servlet 请求的 URL 信息。这可能对框架尤为有用，这些框架需要这一信息来运行内部工作。</p>
<p>在接下来的部分，我将概述服务器推送及其如何在 Java servlet 中运行，包括 JSF 2.3 中的服务器推送。我还将展示一个交换示例，重点介绍全新 servlet 映射发现功能。</p>
<h1 id="Servlet-4-0-中的服务器推送"><a href="#Servlet-4-0-中的服务器推送" class="headerlink" title="Servlet 4.0 中的服务器推送"></a>Servlet 4.0 中的服务器推送</h1><p>服务器推送使服务器能预测客户端请求的资源需求。然后，在完成请求处理之前，它可以将这些资源发送到客户端。</p>
<p>要了解服务器推送的好处，可以考虑一个包含图像和其他依赖项（比如 CSS 和 JavaScript 文件）的网页。客户端发出一个针对该网页的请求。服务器然后分析所请求的页面，确定呈现它所需的资源，并主动将这些资源发送到客户端的缓存。</p>
<p>在执行所有这些操作的同时，服务器仍在处理原始网页请求。客户端收到响应时，它需要的资源已经位于缓存中。</p>
<h2 id="PushBuilder"><a href="#PushBuilder" class="headerlink" title="PushBuilder"></a>PushBuilder</h2><p>Servlet 4.0 通过 PushBuilder 接口公开服务器推送。为了能够进行访问，您需要通过调用 newPushBuilder() 方法，从 HttpServletRequest 获取 PushBuilder 实例。清单 2 展示了如何获取 PushBuilder 实例。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> 
                     HttpServletResponse response<span class="token punctuation">)</span> 
                     <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>

   PushBuilder pushBuilder <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">newPushBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>
<p>每次调用 newPushBuilder() 方法时，都将返回 PushBuilder 的新实例。如果服务器推送不可用，newPushBuilder() 将返回 null。在某些情况下，客户端可能会为请求事务拒绝服务器推送。如果客户端没有使用安全连接，服务器推送也不会起作用。因此，务必要在对 PushBuilder 实例调用方法之前，针对 null 返回值进行测试。</p>
<p>顾名思义，PushBuilder 实现 Builder 模式。在这一实现过程中，通过链接赋值方法构建推送请求。这些赋值方法通过设置 HTTP 标头、方法类型（GET 是唯一的可接受值）、查询字符串、会话 ID 和资源路径（即，将要推出资源的路径），来配置 PushBuilder 实例。</p>
<p>大多数来自原始 HttpServletRequest 实例的请求标头，只添加到 PushBuilder 实例中。由于正确运行服务器推送并不需要某些标头，因此不包括以下标头：</p>
<ul>
<li>条件标头</li>
<li>Range 标头</li>
<li>Expect 标头</li>
<li>Authorization 标头</li>
<li>Referrer 标头</li>
</ul>
<p>现在，让我们看看如何构造和引发服务器推送操作。</p>
<h2 id="1-设置推送资源"><a href="#1-设置推送资源" class="headerlink" title="1.设置推送资源"></a>1.设置推送资源</h2><p>这一路径是在向客户端推送资源之前必须设置的唯一配置。设置路径需要调用 path() 方法。该方法只能被调用一次，因为它会改变 PushBuilder 对象的路径值。该路径可能会以正斜杠（“/”）开头，指示资源路径是绝对路径；否则，该资源会被认为是相对于关联请求的上下文路径。该路径可以包含一个查询字符串，该查询字符串将与 queryString() 方法设置的任何字符串合并。</p>
<h2 id="2-推送资源"><a href="#2-推送资源" class="headerlink" title="2.推送资源"></a>2.推送资源</h2><p>接下来，您将调用 push() 方法， 将资源推送到客户端。push() 方法用于发起与客户端的推送“对话”。在后台，会向客户端发送一个 PUSH_PROMISE 帧，类似于发送资源的意图通知。客户端可以通过发回 RST_STREAM 来拒绝资源。这种机制允许客户端保留对接收到的资源的控制。因此，客户端不会因不需要的资源或已经在缓存中的资源而过载。</p>
<p>如清单 3 所示，一旦获得了 PushBuilder 的实例，就可以多次重复使用。路径和条件标头都为 null，但是所有其他字段都原样保留。这些可以在另一个服务器推送中重复使用。</p>
<pre class=" language-java"><code class="language-java">PushBuilder pushBuilder <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">newPushBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>pushBuilder <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   pushBuilder<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token string">"images/hero-banner.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   pushBuilder<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token string">"css/menu.css"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   pushBuilder<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token string">"js/marquee.js"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>在清单 3 中，hero-banner.jpg 的路径是通过 path() 方法在 PushBuilder 实例上设置的，并通过调用 push() 推送到客户端。push() 方法是非阻塞的，且立即返回，以便后续可推送更多资源（本例中为 menu.css 和 marquee.js）。</p>
<p>服务器推送实战</p>
<h1 id="将服务器推送与-JSF-结合使用"><a href="#将服务器推送与-JSF-结合使用" class="headerlink" title="将服务器推送与 JSF 结合使用"></a>将服务器推送与 JSF 结合使用</h1><p>JavaServer Faces 已经将每个页面的资源需求标识为页面呈现生命周期的一部分，所以它非常适合用于服务器推送。就开发人员而言，比较好的一方面是，您不必为了激活此功能而煞费苦心。您可以免费升级到 JSF 2.3。</p>
<p>清单 4 展示了JSF 和服务器推送的集成情况。</p>
<pre class=" language-jsp"><code class="language-jsp"><h:head>
   <h:outputStylesheet library="css" name="logo.css"/>
   <h:outputScript library="js" name="logo.js"/>
   <title>JSF 2.3 ServerPush Example</title>
</h:head>
<h:body>
   <h:form>
       <h:graphicImage library="images" name="logo.jpg"/>
   </h:form>
</h:body>
</html></code></pre>
<p>清单 4 中的 JSF 页面需要以下三种资源：</p>
<ul>
<li>名为 logo.css 的 CSS 文件。</li>
<li>名为 logo.js 的 JavaScript 文件。</li>
<li>名为 logo.jpg 的图像。</li>
</ul>
<p>当 JSF 引擎正在处理和呈现页面时，这些资源将被逐个推送到客户端。这发生在 JSF 的呈现响应阶段。然后，会为每个资源调用 ExternalContextImpl.encodeResourceURL() 方法，并向其传递资源的新 URL。从与 ExternalContext 相关联的 HttpServletRequest 实例获取新的 PushBuilder 对象。如果支持服务器推送，那么会在向客户端呈现页面之前将资源推送到客户端。</p>
<p>JSF 2.3 中的服务器推送</p>
<blockquote>
<p>JSP 中的服务器推送</p>
<p>由于 JavaServer Pages 是一项传统技术，服务器推送尚未集成到 JavaServer Pages 中。但您可以在 JSP 中利用服务器推送，通过使用 servlet 过滤器来缓存和推送资源。请查看 Jetty 9 的 PushCacheFilter，获取工作方式示例。</p>
</blockquote>
<h1 id="HttpServletMapping-接口"><a href="#HttpServletMapping-接口" class="headerlink" title="HttpServletMapping 接口"></a>HttpServletMapping 接口</h1><p>Servlet 4.0 的全新 <a href="https://javaee.github.io/javaee-spec/javadocs/javax/servlet/http/HttpServletMapping.html" target="_blank" rel="noopener">servlet 映射发现</a> API 使服务器能够对 URL（可调用 servlet）执行运行时检查。例如，对 file.ext, /path 和 /path/file.ext 的请求将通过 URL 模式 /path/* 和 *.ext 激活 servlet。</p>
<p>HttpServletMapping 接口支持运行时发现 servlet 的映射 URL。您可以在 HttpServletRequest 实例上调用 getHttpServletMapping()，获取接口的实例。您可以使用以下方法获取有关 servlet 映射 URL 的信息：</p>
<ul>
<li>getMatchValue() 返回部分 URI 路径，该路径会导致请求匹配。</li>
<li>getPattern() 返回 URL 模式的 String 表示形式。</li>
<li>getServletName() 返回 servlet 名称的 String 表示形式。</li>
<li>getMappingMatch() 返回匹配的类型，表示为 MappingMatch 枚举值，该枚举值将为以下值之一：CONTEXT_ROOT、DEFAULT、EXACT、EXTENSION 或 PATH。</li>
</ul>
<p>清单 5 展示了四种 API 方法的实际应用。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"/path/*"</span><span class="token punctuation">,</span> <span class="token string">"*.ext"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServletMapping</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>

    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>
                         HttpServletResponse response<span class="token punctuation">)</span> 
                         <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>

        HttpServletMapping mapping <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHttpServletMapping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String mapping <span class="token operator">=</span> mapping<span class="token punctuation">.</span><span class="token function">getMappingMatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String value <span class="token operator">=</span> mapping<span class="token punctuation">.</span><span class="token function">getMatchValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String pattern <span class="token operator">=</span> mapping<span class="token punctuation">.</span><span class="token function">getPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String servletName <span class="token operator">=</span> mapping<span class="token punctuation">.</span><span class="token function">getServletName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>servlet 映射 URL 的运行时发现</p>
<h1 id="Servlet-4-0-的细微变化"><a href="#Servlet-4-0-的细微变化" class="headerlink" title="Servlet 4.0 的细微变化"></a>Servlet 4.0 的细微变化</h1><p>除了服务器推送和全新 HttpServletMapping 接口，Servlet 4.0 还包括少量值得注意的新增功能和变更。</p>
<ol>
<li>Trailer 响应标头支持发送方在分块消息的末尾包含额外字段。这用于提供在发送消息主体时可能会动态生成的元数据，例如，消息完整性检查、数字签名或后期处理状态。</li>
<li>Servlet 4.0 添加了 GenericFilter 和 HttpFilter 抽象类，这些抽象类通过最低限度地实现生命周期方法 init() 和 destroy()，简化了编写过滤器。</li>
<li>Servlet 4.0 还集成了全新的 HTTP Trailer，支持发送方在分块消息的末尾包含额外的字段。</li>
<li>ServletContext 接口采用了一些新方法：<ul>
<li>addJspFile() 可将带有给定 JSP 文件的 servlet 添加到 servlet 上下文中。</li>
<li>getSessionTimeout() 和 setSessionTimeout() 可提供对会话超时的访问权限。</li>
<li>getRequestCharacterEncoding() 和 setRequestCharacterEncoding() 可为当前的 servlet 上下文提供访问权限，并改变默认的请求字符编码。</li>
</ul>
</li>
<li>HttpServletRequest 接口上的 isRequestedSessionIdFromUrl() 方法已被弃用。</li>
<li>由于升级到 Java SE 8，默认方法已被添加到侦听器接口中。</li>
</ol>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>Servlet 4.0 已经发布，主要用于整合全新 HTTP/2 协议及其众多性能增强功能。PushBuilder 接口对推送到客户端的资源提供细粒度控制，使交叉实现生动有趣。例如，Jetty 9 在 PushCacheFilter Web 过滤器中使用 PushBuilder API 实现了服务器推送功能。此过滤器在首次请求时缓存了资源。即使仍在服务器端处理请求，它也能够将后续请求推送到客户端。</p>
<p>虽然 JSF 2.3 内置了服务器推送功能，但 JavaServer Pages 并没有此功能。JSF 与服务器推送的集成十分有用，开发人员因而可减少对性能问题的关注，而更加着力于设计动态网页。对于想要在 JSP 中实现相似功能的开发人员，就需要使用 Web 过滤器这样的定制解决方案，例如 Jetty 9 中的 PushCacheFilter Web 过滤器。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java EE</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Framework 5 中的新特性</title>
    <url>/2018/12/10/Java/spring/Spring%20Framework%205%20%E4%B8%AD%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>Spring 5 于 2017 年 9 月发布了通用版本 (GA)，它标志着自 2013 年 12 月以来第一个主要 Spring Framework 版本。它提供了一些人们期待已久的改进，还采用了一种全新的编程范例，以反应式宣言中陈述的反应式原则为基础。</p>
<p>这个版本是很长时间以来最令人兴奋的 Spring Framework 版本。Spring 5 兼容 Java™8 和 JDK 9，它集成了反应式流，以便提供一种颠覆性方法来实现端点和 Web 应用程序开发。</p>
<p>诚然，反应式编程不仅是此版本的主题，还是令许多开发人员激动不已的重大特性。人们对能够针对负载波动进行无缝扩展的灾备和响应式服务的需求在不断增加，Spring 5 很好地满足了这一需求。</p>
<p>本文将全面介绍 Spring 5。我将介绍 Java SE 8 和 Java EE 7 API 的基准升级、Spring 5 的新反应式编程模型、HTTP/2 支持，以及 Spring 通过 Kotlin 对函数式编程的全面支持。我还会简要介绍测试和性能增强，最后介绍对 Spring 核心和容器的一般性修订。</p>
<h1 id="升级到-Java-SE-8-和-Java-EE-7"><a href="#升级到-Java-SE-8-和-Java-EE-7" class="headerlink" title="升级到 Java SE 8 和 Java EE 7"></a>升级到 Java SE 8 和 Java EE 7</h1><p>直到现在，Spring Framework 仍支持一些弃用的 Java 版本，但 Spring 5 已从旧包袱中解放出来。为了充分利用 Java 8 特性，它的代码库已进行了改进，而且该框架要求将 Java 8 作为最低的 JDK 版本。</p>
<p>Spring 5 在类路径（和模块路径）上完全兼容 Java 9，而且它通过了 JDK 9 测试套件的测试。对 Java 9 爱好者而言，这是一条好消息，因为在 Java 9 发布后，Spring 能立即使用它。</p>
<p>在 API 级别上，Spring 5 兼容 Java EE 8 技术，满足对 Servlet 4.0、Bean Validation 2.0 和全新的 JSON Binding API 的需求。对 Java EE API 的最低要求为 V7，该版本引入了针对 Servlet、JPA 和 Bean Validation API 的次要版本。</p>
<h1 id="反应式编程模型"><a href="#反应式编程模型" class="headerlink" title="反应式编程模型"></a>反应式编程模型</h1><p>Spring 5 最令人兴奋的新特性是它的反应式编程模型。Spring 5 Framework 基于一种反应式基础而构建，而且是完全异步和非阻塞的。只需少量的线程，新的事件循环执行模型就可以垂直扩展。</p>
<p>该框架采用反应式流来提供在反应式组件中传播负压的机制。负压是一个确保来自多个生产者的数据不会让使用者不堪重负的概念。</p>
<p>Spring WebFlux 是 Spring 5 的反应式核心，它为开发人员提供了两种为 Spring Web 编程而设计的编程模型：一种基于注解的模型和 Functional Web Framework (WebFlux.fn)。</p>
<p>基于注解的模型是 Spring WebMVC 的现代替代方案，该模型基于反应式基础而构建，而 Functional Web Framework 是基于 @Controller 注解的编程模型的替代方案。这些模型都通过同一种反应式基础来运行，后者调整非阻塞 HTTP 来适应反应式流 API。</p>
<h1 id="使用注解进行编程"><a href="#使用注解进行编程" class="headerlink" title="使用注解进行编程"></a>使用注解进行编程</h1><p>WebMVC 程序员应该对 Spring 5 的基于注解的编程模型非常熟悉。Spring 5 调整了 WebMVC 的 @Controller 编程模型，采用了相同的注解。</p>
<p>在清单 1 中，BookController 类提供了两个方法，分别响应针对某个图书列表的 HTTP 请求，以及针对具有给定 id 的图书的 HTTP 请求。请注意 resource 方法返回的对象（Mono 和 Flux）。这些对象是实现反应式流规范中的 Publisher 接口的反应式类型。它们的职责是处理数据流。Mono 对象处理一个仅含 1 个元素的流，而 Flux 表示一个包含 N 个元素的流。</p>
<p>清单 1. 反应式控制器</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/book"</span><span class="token punctuation">)</span>
    Flux<span class="token operator">&lt;</span>Book<span class="token operator">></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>repository<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/book/{id}"</span><span class="token punctuation">)</span>
    Mono<span class="token operator">&lt;</span>Book<span class="token operator">></span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>repository<span class="token punctuation">.</span><span class="token function">findOne</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// Plumbing code omitted for brevity</span>
<span class="token punctuation">}</span></code></pre>
<p>这是针对 Spring Web 编程的注解。现在我们使用函数式 Web 框架来解决同一个问题。</p>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>Spring 5 的新函数式方法将请求委托给处理函数，这些函数接受一个服务器请求实例并返回一种反应式类型。清单 2 演示了这一过程，其中 listBook 和 getBook 方法类似于清单 1 中的功能。</p>
<p>清单 2. 清单 2.BookHandler 函数类</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookHandler</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>ServerResponse<span class="token operator">></span> <span class="token function">listBooks</span><span class="token punctuation">(</span>ServerRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> ServerResponse<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span>APPLICATION_JSON<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span>repository<span class="token punctuation">.</span><span class="token function">allPeople</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Book<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>ServerResponse<span class="token operator">></span> <span class="token function">getBook</span><span class="token punctuation">(</span>ServerRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> repository<span class="token punctuation">.</span><span class="token function">getBook</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">pathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>book <span class="token operator">-</span><span class="token operator">></span> ServerResponse<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span>APPLICATION_JSON<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span><span class="token function">fromObject</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">otherwiseIfEmpty</span><span class="token punctuation">(</span>ServerResponse<span class="token punctuation">.</span><span class="token function">notFound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// Plumbing code omitted for brevity</span>
<span class="token punctuation">}</span></code></pre>
<p>通过路由函数来匹配 HTTP 请求谓词与媒体类型，将客户端请求路由到处理函数。清单 3 展示了图书资源端点 URI 将调用委托给合适的处理函数：</p>
<p>清单 3. Router 函数</p>
<pre class=" language-java"><code class="language-java">BookHandler handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BookHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

RouterFunction<span class="token operator">&lt;</span>ServerResponse<span class="token operator">></span> personRoute <span class="token operator">=</span>
    <span class="token function">route</span><span class="token punctuation">(</span>
        <span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/books/{id}"</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token function">accept</span><span class="token punctuation">(</span>APPLICATION_JSON<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token operator">:</span><span class="token operator">:</span>getBook<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">andRoute</span><span class="token punctuation">(</span>
    <span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/books"</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token function">accept</span><span class="token punctuation">(</span>APPLICATION_JSON<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token operator">:</span><span class="token operator">:</span>listBooks<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这些示例背后的数据存储库也支持完整的反应式体验，该体验是通过 Spring Data 对反应式 Couchbase、Reactive MongoDB 和 Cassandra 的支持来实现的。</p>
<h1 id="使用-REST-端点执行反应式编程"><a href="#使用-REST-端点执行反应式编程" class="headerlink" title="使用 REST 端点执行反应式编程"></a>使用 REST 端点执行反应式编程</h1><p>新的编程模型脱离了传统的 Spring WebMVC 模型，引入了一些很不错的新特性。</p>
<p>举例来说，WebFlux 模块为 RestTemplate 提供了一种完全非阻塞、反应式的替代方案，名为 WebClient。清单 4 创建了一个 WebClient，并调用 books 端点来请求一本给定 id 为 1234 的图书。</p>
<p>清单 4. 通过 WebClient 调用 REST 端点</p>
<pre class=" language-java"><code class="language-java">Mono<span class="token operator">&lt;</span>Book<span class="token operator">></span> book <span class="token operator">=</span> WebClient<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"http://localhost:8080"</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">url</span><span class="token punctuation">(</span><span class="token string">"/books/{id}"</span><span class="token punctuation">,</span> <span class="token number">1234</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>APPLICATION_JSON<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">-</span><span class="token operator">></span> response<span class="token punctuation">.</span><span class="token function">bodyToMono</span><span class="token punctuation">(</span>Book<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h1 id="HTTP-2-支持"><a href="#HTTP-2-支持" class="headerlink" title="HTTP/2 支持"></a>HTTP/2 支持</h1><blockquote>
<p><strong>HTTP/2 幕后原理</strong>：要了解 HTTP/2 如何提高传输性能，减少延迟，并帮助提高应用程序吞吐量，从而提供经过改进的丰富 Web 体验。</p>
</blockquote>
<p>Spring Framework 5.0 将提供专门的 HTTP/2 特性支持，还支持人们期望出现在 JDK 9 中的新 HTTP 客户端。尽管 HTTP/2 的服务器推送功能已通过 Jetty servlet 引擎的 ServerPushFilter 类向 Spring 开发人员公开了很长一段时间，但如果发现 Spring 5 中开箱即用地提供了 HTTP/2 性能增强，Web 优化者们一定会为此欢呼雀跃。</p>
<p>Java EE Servlet 规范预计将于 2017 年第 4 季度发布，Servlet 4.0 支持将在 Spring 5.1 中提供。到那时，HTTP/2 特性将由 Tomcat 9.0、Jetty 9.3 和 Undertow 1.4 原生提供。</p>
<h1 id="Kotlin-和-Spring-WebFlux"><a href="#Kotlin-和-Spring-WebFlux" class="headerlink" title="Kotlin 和 Spring WebFlux"></a>Kotlin 和 Spring WebFlux</h1><p>Kotlin 是一种来自 JetBrains 的面向对象的语言，它支持函数式编程。它的主要优势之一是与 Java 有非常高的互操作性。通过引入对 Kotlin 的专门支持，Spring 在 V5 中全面吸纳了这一优势。它的函数式编程风格与 Spring WebFlux 模块完美匹配，它的新路由 DSL 利用了函数式 Web 框架以及干净且符合语言习惯的代码。可以像清单 5 中这样简单地表达端点路由：</p>
<p>清单 5. Kotlin 的用于定义端点的路由 DSL</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span>
fun <span class="token function">apiRouter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> router <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token function">accept</span><span class="token punctuation">(</span>APPLICATION_JSON<span class="token punctuation">)</span> and <span class="token string">"/api"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>nest <span class="token punctuation">{</span>
        <span class="token string">"/book"</span><span class="token punctuation">.</span>nest <span class="token punctuation">{</span>
            <span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> bookHandler<span class="token operator">:</span><span class="token operator">:</span>findAll<span class="token punctuation">)</span>
            <span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/{id}"</span><span class="token punctuation">,</span> bookHandler<span class="token operator">:</span><span class="token operator">:</span>findOne<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token string">"/video"</span><span class="token punctuation">.</span>nest <span class="token punctuation">{</span>
            <span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> videoHandler<span class="token operator">:</span><span class="token operator">:</span>findAll<span class="token punctuation">)</span>
            <span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/{genre}"</span><span class="token punctuation">,</span> videoHandler<span class="token operator">:</span><span class="token operator">:</span>findByGenre<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>使用 Kotlin 1.1.4+ 时，还添加了对 Kotlin 的不可变类的支持（通过带默认值的可选参数），以及对完全支持 null 的 API 的支持。</p>
<h1 id="使用-Lambda-表达式注册-bean"><a href="#使用-Lambda-表达式注册-bean" class="headerlink" title="使用 Lambda 表达式注册 bean"></a>使用 Lambda 表达式注册 bean</h1><p>作为传统 XML 和 JavaConfig 的替代方案，现在可以使用 lambda 表达式注册 Spring bean，使 bean 可以实际注册为提供者。清单 6 使用 lambda 表达式注册了一个 Book bean。</p>
<p>清单 6. 将 Bean 注册为提供者</p>
<pre class=" language-java"><code class="language-java">GenericApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span><span class="token function">registerBean</span><span class="token punctuation">(</span>Book<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> 
              <span class="token class-name">Book</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>Author<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h1 id="Spring-WebMVC-支持最新的-API"><a href="#Spring-WebMVC-支持最新的-API" class="headerlink" title="Spring WebMVC 支持最新的 API"></a>Spring WebMVC 支持最新的 API</h1><p>全新的 WebFlux 模块提供了许多新的、令人兴奋的功能，但 Spring 5 也迎合了愿意继续使用 Spring MVC 的开发人员的需求。Spring 5 中更新了模型-视图-控制器框架，以兼容 WebFlux 和最新版的 Jackson 2.9 和 Protobuf 3.0，甚至包括对新的 Java EE 8 JSON-Binding API 的支持。</p>
<p>除了 HTTP/2 特性的基础服务器实现之外，Spring WebMVC 还通过 MVC 控制器方法的一个参数来支持 Servlet 4.0 的 PushBuilder。最后，WebMVC 全面支持 Reactor 3.1 的 Flux 和 Mono 对象，以及 RxJava 1.3 和 2.1，它们被视为来自 MVC 控制器方法的返回值。这项支持的最终目的是支持 Spring Data 中的新的反应式 WebClient 和反应式存储库。</p>
<h1 id="使用-JUnit-5-执行条件和并发测试"><a href="#使用-JUnit-5-执行条件和并发测试" class="headerlink" title="使用 JUnit 5 执行条件和并发测试"></a>使用 JUnit 5 执行条件和并发测试</h1><blockquote>
<p><strong>JUnit 和 Spring 5</strong>：Spring 5 全面接纳了函数式范例，并支持 JUnit 5 及其新的函数式测试风格。还提供了对 JUnit 4 的向后兼容性，以确保不会破坏旧代码。</p>
</blockquote>
<p>Spring 5 的测试套件通过多种方式得到了增强，但最明显的是它对 JUnit 5 的支持。现在可以在您的单元测试中利用 Java 8 中提供的函数式编程特性。清单 7 演示了这一支持：</p>
<p>清单 7. 清单 7.JUnit 5 全面接纳了 Java 8 流和 lambda 表达式</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">void</span> <span class="token function">givenStreamOfInts_SumShouldBeMoreThanFive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assertTrue</span><span class="token punctuation">(</span>Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span>i <span class="token operator">-</span><span class="token operator">></span> i<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">110</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Total should be more than 100"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p><strong>迁移到 JUnit 5</strong>：如果您对升级到 JUnit 5 持观望态度，Steve Perry 的分两部分的深入剖析教程将说服您冒险尝试。</p>
</blockquote>
<p>Spring 5 继承了 JUnit 5 在 Spring TestContext Framework 内实现多个扩展 API 的灵活性。举例而言，开发人员可以使用 JUnit 5 的条件测试执行注解 @EnabledIf 和 @DisabledIf 来自动计算一个 SpEL (Spring Expression Language) 表达式，并适当地启用或禁用测试。借助这些注解，Spring 5 支持以前很难实现的复杂的条件测试方案。Spring TextContext Framework 现在能够并发执行测试。</p>
<h1 id="使用-Spring-WebFlux-执行集成测试"><a href="#使用-Spring-WebFlux-执行集成测试" class="headerlink" title="使用 Spring WebFlux 执行集成测试"></a>使用 Spring WebFlux 执行集成测试</h1><p>Spring Test 现在包含一个 WebTestClient，后者支持对 Spring WebFlux 服务器端点执行集成测试。WebTestClient 使用模拟请求和响应来避免耗尽服务器资源，并能直接绑定到 WebFlux 服务器基础架构。</p>
<p>WebTestClient 可绑定到真实的服务器，或者使用控制器或函数。在清单 8 中，WebTestClient 被绑定到 localhost：</p>
<p>清单 8. 绑定到 localhost 的 WebTestClient</p>
<pre class=" language-java"><code class="language-java">WebTestClient testClient <span class="token operator">=</span> WebTestClient
  <span class="token punctuation">.</span><span class="token function">bindToServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">baseUrl</span><span class="token punctuation">(</span><span class="token string">"http://localhost:8080"</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>在清单 9 中，测试了 RouterFunction：</p>
<p>清单 9. 将 WebTestClient 绑定到 RouterFunction</p>
<pre class=" language-java"><code class="language-java">RouterFunction bookRouter <span class="token operator">=</span> RouterFunctions<span class="token punctuation">.</span><span class="token function">route</span><span class="token punctuation">(</span>
  RequestPredicates<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/books"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  request <span class="token operator">-</span><span class="token operator">></span> ServerResponse<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

WebTestClient
  <span class="token punctuation">.</span><span class="token function">bindToRouterFunction</span><span class="token punctuation">(</span>bookRouter<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">uri</span><span class="token punctuation">(</span><span class="token string">"/books"</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">expectStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">expectBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h1 id="包清理和弃用"><a href="#包清理和弃用" class="headerlink" title="包清理和弃用"></a>包清理和弃用</h1><p>Spring 5 中止了对一些过时 API 的支持。遭此厄运的还有 Hibernate 3 和 4，为了支持 Hibernate 5，它们遭到了弃用。另外，对 Portlet、Velocity、JasperReports、XMLBeans、JDO 和 Guava 的支持也已中止。</p>
<p>包级别上的清理工作仍在继续：Spring 5 不再支持 beans.factory.access、jdbc.support.nativejdbc、mock.staticmock（来自 spring-aspects 模块）或 web.view.tiles2M。Tiles 3 现在是 Spring 的最低要求。</p>
<h1 id="对-Spring-核心和容器的一般更新"><a href="#对-Spring-核心和容器的一般更新" class="headerlink" title="对 Spring 核心和容器的一般更新"></a>对 Spring 核心和容器的一般更新</h1><p>Spring Framework 5 改进了扫描和识别组件的方法，使大型项目的性能得到提升。目前，扫描是在编译时执行的，而且向 META-INF/spring.components 文件中的索引文件添加了组件坐标。该索引是通过一个为项目定义的特定于平台的应用程序构建任务来生成的。</p>
<p>标有来自 javax 包的注解的组件会添加到索引中，任何带 @Index 注解的类或接口都会添加到索引中。Spring 的传统类路径扫描方式没有删除，而是保留为一种后备选择。有许多针对大型代码库的明显性能优势，而托管许多 Spring 项目的服务器也会缩短启动时间。</p>
<p>Spring 5 还添加了对 @Nullable 的支持，后者可用于指示可选的注入点。使用者现在必须准备接受 null 值。此外，还可以使用此注解来标记可以为 null 的参数、字段和返回值。@Nullable 主要用于 IntelliJ IDEA 等 IDE，但也可用于 Eclipse 和 FindBugs，它使得在编译时处理 null 值变得更方便，而无需在运行时发送 NullPointerExceptions。</p>
<p>Spring Logging 还提升了性能，自带开箱即用的 Commons Logging 桥接器。现在已通过资源抽象支持防御性编程，为 getFile 访问提供了 isFile 指示器。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>Spring 5 的首要特性是新的反应式编程模型，这代表着对提供可无缝扩展、基于 Spring 的响应式服务的重大保障。随着人们对 Spring 5 的采用，开发人员有望看到反应式编程将会成为使用 Java 语言的 Web 和企业应用程序开发的未来发展道路。</p>
<p>未来的 Spring Framework 版本将继续反映这一承诺，因为 Spring Security、Spring Data 和 Spring Integration 有望采用反应式编程的特征和优势。</p>
<p>总之，Spring 5 代表着一次大受 Spring 开发人员欢迎的范例转变，同时也为其他框架指出了一条发展之路。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题--Java基础--小米归纳</title>
    <url>/2019/03/21/%E9%9D%A2%E8%AF%95%E9%A2%98/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h1><p>面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java 是一个支持并发、基于类和面向对象的计算机编程语言。面向对象软件开发具有以下优点：</p>
<ul>
<li>代码开发模块化，更易维护和修改。</li>
<li>代码复用性强。</li>
<li>增强代码的可靠性和灵活性。</li>
<li>增加代码的可读性。</li>
</ul>
<h2 id="🦅-请说说面向对象的特征？"><a href="#🦅-请说说面向对象的特征？" class="headerlink" title="🦅 请说说面向对象的特征？"></a>🦅 请说说面向对象的特征？</h2><p>四点：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>、<strong>抽象</strong>。</p>
<ol>
<li><p>封装</p>
<p> 封装，给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 4 种修饰符： <code>default</code>、<code>public</code>、<code>private</code> 和 <code>protected</code> 。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</p>
<p> 下面列出了使用封装的一些好处：</p>
<ul>
<li>通过隐藏对象的属性来保护对象内部的状态。</li>
<li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</li>
<li>禁止对象之间的不良交互提高模块化。</li>
</ul>
</li>
<li><p>继承</p>
<p> 继承，给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</p>
</li>
<li><p>多态</p>
<p> 多态，是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作，可以应用到其他类型的值上面。</p>
</li>
<li><p>抽象</p>
<p> 抽象，是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。</p>
<p> Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</p>
</li>
</ol>
<h2 id="🦅-面向对象和面向过程的区别？"><a href="#🦅-面向对象和面向过程的区别？" class="headerlink" title="🦅 面向对象和面向过程的区别？"></a>🦅 面向对象和面向过程的区别？</h2><ul>
<li>面向过程<ul>
<li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。比如，单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发，性能是最重要的因素。</li>
<li>缺点：没有面向对象易维护、易复用、易扩展。</li>
</ul>
</li>
<li>面向对象<ul>
<li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</li>
<li>缺点：性能比面向过程低。</li>
<li><h2 id="🦅-重载和重写的区别？"><a href="#🦅-重载和重写的区别？" class="headerlink" title="🦅 重载和重写的区别？"></a>🦅 重载和重写的区别？</h2></li>
</ul>
</li>
</ul>
<ol>
<li><p>重写 override</p>
<ul>
<li>方法名、参数、返回值相同。</li>
<li>子类方法不能缩小父类方法的访问权限。</li>
<li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li>
<li>存在于父类和子类之间。</li>
<li>方法被定义为 final 不能被重写。</li>
</ul>
</li>
<li><p>重载 overload</p>
<ul>
<li>参数类型、个数、顺序至少有一个不相同。</li>
<li>不能重载只有返回值不同的方法名。</li>
<li>存在于父类和子类、同类中。</li>
</ul>
</li>
<li><p>对比图<br><img src="https://i.loli.net/2019/03/21/5c92f8ecb7f64.png" alt=""></p>
</li>
</ol>
<p>对比图</p>
<h2 id="🦅-Java-中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？"><a href="#🦅-Java-中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？" class="headerlink" title="🦅 Java 中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？"></a>🦅 Java 中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？</h2><ol>
<li><p>构造方法</p>
<p> 当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java 编译器会为这个类创建一个默认的构造方法。</p>
</li>
<li><p>构造方法重载</p>
<p> Java 中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。</p>
</li>
<li><p>拷贝构造方法</p>
<p> Java 不支持像 C++ 中那样的拷贝构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java 不会创建默认的拷贝构造方法。</p>
</li>
</ol>
<h1 id="JDK、JRE、JVM-分别是什么关系？"><a href="#JDK、JRE、JVM-分别是什么关系？" class="headerlink" title="JDK、JRE、JVM 分别是什么关系？"></a>JDK、JRE、JVM 分别是什么关系？</h1><h2 id="🦅-JDK"><a href="#🦅-JDK" class="headerlink" title="🦅 JDK"></a>🦅 JDK</h2><p>JDK 即为 Java 开发工具包，包含编写 Java 程序所必须的编译、运行等开发工具以及 JRE。开发工具如：</p>
<ul>
<li>用于编译 Java 程序的 javac 命令。</li>
<li>用于启动 JVM 运行 Java 程序的 Java 命令。</li>
<li>用于生成文档的 Javadoc 命令。</li>
<li>用于打包的 jar 命令等等。<blockquote>
<p>简单说，就是 JDK 包含 JRE 包含 JVM。</p>
</blockquote>
</li>
</ul>
<h2 id="🦅-JRE"><a href="#🦅-JRE" class="headerlink" title="🦅 JRE"></a>🦅 JRE</h2><p>JRE 即为 Java 运行环境，提供了运行 Java 应用程序所必须的软件环境，包含有 Java 虚拟机（JVM）和丰富的系统类库。系统类库即为 Java 提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。</p>
<blockquote>
<p>简单说，就是 JRE 包含 JVM。</p>
</blockquote>
<h2 id="🦅-JVM"><a href="#🦅-JVM" class="headerlink" title="🦅 JVM"></a>🦅 JVM</h2><p>JVM 即为 Java 虚拟机，提供了字节码文件(<code>.class</code>)的运行环境支持。</p>
<p><img src="https://i.loli.net/2019/03/21/5c92fad79ff05.png" alt=""></p>
<blockquote>
<p>JDK &gt; JRE &gt; JVM</p>
</blockquote>
<h2 id="🦅-为什么-Java-被称作是“平台无关的编程语言”？"><a href="#🦅-为什么-Java-被称作是“平台无关的编程语言”？" class="headerlink" title="🦅 为什么 Java 被称作是“平台无关的编程语言”？"></a>🦅 为什么 Java 被称作是“平台无关的编程语言”？</h2><p>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。</p>
<ul>
<li><p>Java 源文件( <code>.java</code> )被编译成能被 Java 虚拟机执行的字节码文件( <code>.class</code> )。</p>
</li>
<li><p>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<h2 id="🦅-JDK-各版本的新特性？"><a href="#🦅-JDK-各版本的新特性？" class="headerlink" title="🦅 JDK 各版本的新特性？"></a>🦅 JDK 各版本的新特性？</h2></li>
<li><p>JDK5 ~ JDK10 ，看 <a href="https://www.jianshu.com/p/37b52f1ebd4a" target="_blank" rel="noopener">https://www.jianshu.com/p/37b52f1ebd4a</a> 。</p>
</li>
<li><p>JDK11 ，看 <a href="https://www.jianshu.com/p/81b65eded96c" target="_blank" rel="noopener">https://www.jianshu.com/p/81b65eded96c</a> 。</p>
</li>
</ul>
<p>对于大多数面试官，肯定不会问你 JDK 各版本的新特性，更多的会问 JDK8 引入了什么重要的特性？一般上，关键的回答是Lambda 表达式和集合之流式操作，然后说说你在项目中怎么使用的。</p>
<h2 id="🦅-Java-和-C-的区别？"><a href="#🦅-Java-和-C-的区别？" class="headerlink" title="🦅 Java 和 C++ 的区别？"></a>🦅 Java 和 C++ 的区别？</h2><ul>
<li>都是面向对象的语言，都支持封装、继承和多态。</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全。</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>【重要】Java 有自动内存管理机制，不需要程序员手动释放无用内存。<h1 id="什么是字节码？采用字节码的最大好处是什么？"><a href="#什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么？"></a>什么是字节码？采用字节码的最大好处是什么？</h1><h2 id="🦅-什么是字节码？"><a href="#🦅-什么是字节码？" class="headerlink" title="🦅 什么是字节码？"></a>🦅 什么是字节码？</h2></li>
</ul>
<blockquote>
<p>这个问题，面试官可以衍生提问，Java 是编译执行的语言，还是解释执行的语言。</p>
</blockquote>
<p>Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。</p>
<p>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。<strong>这也就是解释了 Java 的编译与解释并存的特点</strong>。</p>
<pre><code>Java 源代码
=&gt; 编译器 =&gt; JVM 可执行的 Java 字节码(即虚拟指令)
=&gt; JVM =&gt; JVM 中解释器 =&gt; 机器可执行的二进制机器码 =&gt; 程序运行</code></pre><h2 id="🦅-采用字节码的好处？"><a href="#🦅-采用字节码的好处？" class="headerlink" title="🦅 采用字节码的好处？"></a>🦅 采用字节码的好处？</h2><p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<blockquote>
<p>解释型语言：解释型语言，是在运行的时候将程序翻译成机器语言。解释型语言的程序不需要在运行前编译，在运行程序的时候才翻译，专门的解释器负责在每个语句执行的时候解释程序代码。这样解释型语言每执行一次就要翻译一次，效率比较低。——百度百科</p>
<p>例如：Python、PHP 。</p>
</blockquote>
<h1 id="Java-中的几种基本数据类型是什么？各自占用多少字节？"><a href="#Java-中的几种基本数据类型是什么？各自占用多少字节？" class="headerlink" title="Java 中的几种基本数据类型是什么？各自占用多少字节？"></a>Java 中的几种基本数据类型是什么？各自占用多少字节？</h1><p>Java 支持的数据类型包括基本数据类型和引用类型。</p>
<p><strong>基本数据</strong>类型如下：</p>
<ul>
<li>整数值型：byte、short、int、long</li>
<li>字符型：char</li>
<li>浮点类型：float、double</li>
<li>布尔型：boolean</li>
<li>整数型：默认 int 型，小数默认是 double 型。Float 和 Long 类型的必须加后缀。比如：float f = 100f 。</li>
</ul>
<p><strong>引用类型</strong>声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。</p>
<ul>
<li><p>引用类型包括类、接口、数组等。</p>
</li>
<li><p>特别注意，String 是引用类型不是基本类型。</p>
<h2 id="🦅-什么是值传递和引用传递？"><a href="#🦅-什么是值传递和引用传递？" class="headerlink" title="🦅 什么是值传递和引用传递？"></a>🦅 什么是值传递和引用传递？</h2></li>
<li><p>值传递，是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。</p>
</li>
<li><p>引用传递，一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。</p>
</li>
</ul>
<p>一般认为，Java 内的传递都是值传递，Java 中实例对象的传递是引用传递。</p>
<h2 id="🦅-是否可以在-static-环境中访问非-static-变量？"><a href="#🦅-是否可以在-static-环境中访问非-static-变量？" class="headerlink" title="🦅 是否可以在 static 环境中访问非 static 变量？"></a>🦅 是否可以在 static 环境中访问非 static 变量？</h2><p><code>static</code> 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 <code>static</code> 变量进行初始化。</p>
<p>如果你的代码尝试不用实例来访问非 <code>static</code> 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<h2 id="🦅-char-型变量中能不能存贮一个中文汉字？为什么？"><a href="#🦅-char-型变量中能不能存贮一个中文汉字？为什么？" class="headerlink" title="🦅 char 型变量中能不能存贮一个中文汉字？为什么？"></a>🦅 char 型变量中能不能存贮一个中文汉字？为什么？</h2><ul>
<li>在 C 语言中，char 类型占 1 个字节，而汉字占 2 个字节，所以不能存储。</li>
<li>在 Java 语言中，char 类型占 2 个字节，而且 Java 默认采用 Unicode 编码，一个 Unicode 码是 16 位，所以一个 Unicode 码占两个字节，Java 中无论汉字还是英文字母，都是用 Unicode 编码来表示的。所以，在 Java 中，char 类型变量可以存储一个中文汉字。</li>
</ul>
<h1 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h1><p>Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。</p>
<ul>
<li><p>String ，是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。</p>
<blockquote>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。</p>
</blockquote>
</li>
<li><p>StringBuffer/StringBuilder 类，表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。</p>
<blockquote>
<p>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。</p>
<p>相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
</blockquote>
</li>
</ul>
<h2 id="🦅-对于三者使用的总结？"><a href="#🦅-对于三者使用的总结？" class="headerlink" title="🦅 对于三者使用的总结？"></a>🦅 对于三者使用的总结？</h2><ul>
<li><p>操作少量的数据 = String 。</p>
<blockquote>
<p>这个也是实际编码较为经常使用的方式。</p>
</blockquote>
</li>
<li><p>单线程操作字符串缓冲区下操作大量数据 = StringBuilder 。</p>
<blockquote>
<p>甚至有时，我们为了避免每个线程重复创建 StringBuilder 对象，会通过 ThreadLocal + StringBuilder 的方式，进行对 StringBuilder 的重用。具体可以参考 《StringBuilder 在高性能场景下的正确用法》 文章。</p>
</blockquote>
</li>
<li><p>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</p>
<blockquote>
<p>实际场景下，我们基本不太会出现，多线程操作同一个 StringBuffer 对象。</p>
</blockquote>
</li>
</ul>
<h2 id="🦅-String-s-new-String-quot-xyz-quot-会创建几个对象？"><a href="#🦅-String-s-new-String-quot-xyz-quot-会创建几个对象？" class="headerlink" title="🦅 String s = new String(&quot;xyz&quot;) 会创建几个对象？"></a>🦅 <code>String s = new String("xyz")</code> 会创建几个对象？</h2><ul>
<li>首先，在 String 池内找，找到 “xyz” 字符串，不创建 “xyz” 对应的 String 对象，否则创建一个对象。</li>
<li>然后，遇到 new 关键字，在内存上创建 String 对象，并将其返回给 s ，又一个对象。</li>
</ul>
<p>所以，总共是 1 个或者 2 个对象。</p>
<p>具体的，可以看看 <a href="https://blog.csdn.net/tzs_1041218129/article/details/69367423" target="_blank" rel="noopener">《关于String s = new String(“xyz”); 创建几个对象的问题》</a> 文章的测试代码。</p>
<h2 id="🦅-String-为什么是不可变的？"><a href="#🦅-String-为什么是不可变的？" class="headerlink" title="🦅 String 为什么是不可变的？"></a>🦅 String 为什么是不可变的？</h2><p>简单的来说，String 类中使用 <code>final</code> 关键字字符数组保存字符串。代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span></code></pre>
<ul>
<li>所以 String 对象是不可变的。</li>
</ul>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 <code>char[] value</code> ，但是没有用 <code>final</code> 关键字修饰。代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span></code></pre>
<ul>
<li>所以这两种对象都是可变的。<h2 id="🦅-StringTokenizer-是什么？"><a href="#🦅-StringTokenizer-是什么？" class="headerlink" title="🦅 StringTokenizer 是什么？"></a>🦅 StringTokenizer 是什么？</h2></li>
</ul>
<p>StringTokenizer ，是一个用来分割字符串的工具类。</p>
<p>示例代码如下：</p>
<pre class=" language-java"><code class="language-java">StringTokenizer st <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringTokenizer</span><span class="token punctuation">(</span>”Hello World”<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">hasMoreTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>输出如下：</p>
<pre class=" language-java"><code class="language-java">Hello
World</code></pre>
<h1 id="什么是自动拆装箱？"><a href="#什么是自动拆装箱？" class="headerlink" title="什么是自动拆装箱？"></a>什么是自动拆装箱？</h1><p>自动装箱和拆箱，就是基本类型和引用类型之间的转换。</p>
<h2 id="🦅-为什么要转换？"><a href="#🦅-为什么要转换？" class="headerlink" title="🦅 为什么要转换？"></a>🦅 为什么要转换？</h2><p>如果你在 Java5 下进行过编程的话，你一定不会陌生这一点，你不能直接地向集合( Collection )中放入原始类型值，因为集合只接收对象。</p>
<ul>
<li><p>通常这种情况下你的做法是，将这些原始类型的值转换成对象，然后将这些转换的对象放入集合中。使用 Integer、Double、Boolean 等这些类，我们可以将原始类型值转换成对应的对象，但是从某些程度可能使得代码不是那么简洁精炼。</p>
</li>
<li><p>为了让代码简练，Java5 引入了具有在原始类型和对象类型自动转换的装箱和拆箱机制。</p>
</li>
<li><p>但是自动装箱和拆箱并非完美，在使用时需要有一些注意事项，如果没有搞明白自动装箱和拆箱，可能会引起难以察觉的 Bug 。</p>
<h2 id="🦅-int-和-Integer-有什么区别？"><a href="#🦅-int-和-Integer-有什么区别？" class="headerlink" title="🦅 int 和 Integer 有什么区别？"></a>🦅 int 和 Integer 有什么区别？</h2></li>
<li><p><code>int</code> 是基本数据类型。</p>
</li>
<li><p><code>Integer</code> 是其包装类，注意是一个类。<br>当然，要注意下 Integer 的缓存策略，可以看看 <a href="http://www.importnew.com/18884.html" target="_blank" rel="noopener">《理解Java Integer 的缓存策略》</a> 文章。</p>
</li>
</ul>
<h1 id="equals-与-的区别？"><a href="#equals-与-的区别？" class="headerlink" title="equals 与 == 的区别？"></a>equals 与 == 的区别？</h1><ul>
<li><p>值类型（<code>int</code>,<code>char</code>,<code>long</code>,<code>boolean</code> 等）的话</p>
<ul>
<li>都是用 == 判断相等性。</li>
</ul>
</li>
<li><p>对象引用的话</p>
<ul>
<li>== 判断引用所指的对象是否是同一个。</li>
<li>equals 方法，是 Object 的成员函数，有些类会覆盖(override) 这个方法，用于判断对象的等价性。</li>
</ul>
<blockquote>
<p>例如 String 类，两个引用所指向的 String 都是 “abc” ，但可能出现他们实际对应的对象并不是同一个（和 JVM 实现方式有关），因此用 == 判断他们可能不相等，但用 equals 方法判断一定是相等的。</p>
</blockquote>
</li>
</ul>
<h2 id="🦅-如何在父类中为子类自动完成所有的-hashCode-和-equals-实现？这么做有何优劣？"><a href="#🦅-如何在父类中为子类自动完成所有的-hashCode-和-equals-实现？这么做有何优劣？" class="headerlink" title="🦅 如何在父类中为子类自动完成所有的 hashCode 和 equals 实现？这么做有何优劣？"></a>🦅 如何在父类中为子类自动完成所有的 hashCode 和 equals 实现？这么做有何优劣？</h2><p>父类的 equals ，一般情况下是无法满足子类的 equals 的需求。</p>
<ul>
<li>比如所有的对象都继承 Object ，默认使用的是 Object 的 equals 方法，在比较两个对象的时候，是看他们是否指向同一个地址。但是我们的需求是对象的某个属性相同，就相等了，而默认的 equals 方法满足不了当前的需求，所以我们要重写 equals 方法。</li>
<li>如果重写了 equals 方法，就必须重写 hashCode 方法，否则就会降低 Map 等集合的索引速度。</li>
</ul>
<h2 id="🦅-说一说你对-java-lang-Object-对象中-hashCode-和-equals-方法的理解。在什么场景下需要重新实现这两个方法"><a href="#🦅-说一说你对-java-lang-Object-对象中-hashCode-和-equals-方法的理解。在什么场景下需要重新实现这两个方法" class="headerlink" title="🦅 说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法?"></a>🦅 说一说你对 <code>java.lang.Object</code> 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法?</h2><p>这个问题，和上个 <a href="#🦅-如何在父类中为子类自动完成所有的-hashCode-和-equals-实现？这么做有何优劣？">「如何在父类中为子类自动完成所有的 hashCode 和 equals 实现？这么做有何优劣？」</a> 一样的答案。</p>
<h2 id="🦅-这样的-a-hashCode-有什么用，与-a-equals-b-有什么关系"><a href="#🦅-这样的-a-hashCode-有什么用，与-a-equals-b-有什么关系" class="headerlink" title="🦅 这样的 a.hashCode() 有什么用，与 a.equals(b) 有什么关系?"></a>🦅 这样的 a.hashCode() 有什么用，与 a.equals(b) 有什么关系?</h2><blockquote>
<p>这个问题，和上述问题，就是换个姿势，差不了太多。</p>
</blockquote>
<ol>
<li><p>equals 方法，用于比较对象的内容是否相等。</p>
<p> 当覆盖了 equals 方法时，比较对象是否相等将通过覆盖后的 equals 方法进行比较（判断对象的内容是否相等）。</p>
</li>
<li><p>hashCode 方法，大多在集合中用到。</p>
<p> 将对象放入到集合中时，首先判断要放入对象的 hashCode 值与集合中的任意一个元素的 hashCode 值是否相等，如果不相等直接将该对象放入集合中。</p>
<p> 如果 hashCode 值相等，然后再通过 equals 方法判断要放入对象与集合中的任意一个对象是否相等，如果 equals 判断不相等，直接将该元素放入到集合中，否则不放入。</p>
</li>
</ol>
<h2 id="🦅-有没有可能-2-个不相等的对象有相同的-hashCode？"><a href="#🦅-有没有可能-2-个不相等的对象有相同的-hashCode？" class="headerlink" title="🦅 有没有可能 2 个不相等的对象有相同的 hashCode？"></a>🦅 有没有可能 2 个不相等的对象有相同的 hashCode？</h2><p>可能会发生，这个被称为<strong>哈希碰撞</strong>。当然，相等的对象，即我们重写了 equals 方法，一定也要重写 hashCode 方法，否则将出现我们在 HashMap 中，相等的对象作为 key ，将找不到对应的 value 。</p>
<p>所以说，equals 和 hashCode 的关系会是：</p>
<ul>
<li>equals 不相等，hashCode 可能相等。</li>
<li>equals 相等，请重写 hashCode 方法，保证 hashCode 相等。<br>一般来说，hashCode 方法的重写，可以看看 <a href="https://segmentfault.com/a/1190000010799123" target="_blank" rel="noopener">《科普：为什么 String hashCode 方法选择数字31作为乘子》 </a>方法。</li>
</ul>
<h1 id="final、finally、finalize-的区别？"><a href="#final、finally、finalize-的区别？" class="headerlink" title="final、finally、finalize 的区别？"></a>final、finally、finalize 的区别？</h1><ol>
<li><p>final</p>
<p> <code>final</code> ，是修饰符关键字。</p>
<ul>
<li>如果一个类被声明为 <code>final</code> ，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 <code>abstract</code> 的，又被声明为 <code>final</code> 的。</li>
<li>将变量或方法声明为 <code>final</code> ，可以保证它们在使用中不被改变。被声明为 <code>final</code> 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为 <code>final</code> 的方法也同样只能使用，不能重写。<blockquote>
<p>另外，在早期的 Java 实现版本中，会将 <code>final</code> 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 <code>final</code> 方法进行这些优化了）。类中所有的<code>private</code> 方法都隐式地指定为 <code>final</code> 。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>finally</p>
<p> 在异常处理时提供 <code>finally</code> 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 <code>catch</code> 子句就会执行，然后控制就会进入 <code>finally</code> 块（如果有的话）。</p>
<p> 在以下 4 种特殊情况下，finally块不会被执行：</p>
<ul>
<li>在 <code>finally</code> 语句块中发生了异常。</li>
<li>在前面的代码中用了 <code>System.exit()</code> 退出程序。</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU 。</li>
</ul>
</li>
<li><p>finalize</p>
<p> finalize ，是方法名。</p>
<p> Java 允许使用 #finalize() 方法，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。</p>
<ul>
<li><p>它是在 Object 类中定义的，因此所有的类都继承了它。</p>
</li>
<li><p>子类覆盖 finalize() 方法，以整理系统资源或者执行其他清理工作。</p>
</li>
<li><p>finalize() 方法，是在垃圾收集器删除对象之前对这个对象调用的。</p>
<p>一般情况下，我们在业务中不会自己实现这个方法，更多是在一些框架中使用，例如 <a href="https://github.com/netty/netty/issues/4145" target="_blank" rel="noopener">《Netty Using finalize() to release ByteBufs》</a> 。</p>
</li>
</ul>
</li>
</ol>
<h2 id="🦅-String-类能被继承吗，为什么？"><a href="#🦅-String-类能被继承吗，为什么？" class="headerlink" title="🦅 String 类能被继承吗，为什么？"></a>🦅 String 类能被继承吗，为什么？</h2><p>不能，因为 String 是 <code>final</code> 修饰。</p>
<h1 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h1><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<ul>
<li>Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：接口中所有的方法隐含的都是抽象的，而抽象类则可以同时包含抽象和非抽象的方法。</li>
<li>类可以实现很多个接口，但是只能继承一个抽象类。类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li>
<li>抽象类可以在不提供接口方法实现的情况下实现接口。</li>
<li>Java 接口中声明的变量默认都是 <code>final</code> 的。抽象类可以包含非 <code>final</code> 的变量。</li>
<li>Java 接口中的成员函数默认是 <code>public</code> 的。抽象类的成员函数可以是 <code>private</code>，<code>protected</code> 或者是 <code>public</code> 。</li>
<li>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 <code>#main(String[] args)</code> 方法的话是可以被调用的。</li>
</ul>
<h2 id="🦅-继承和组合的区别在哪？"><a href="#🦅-继承和组合的区别在哪？" class="headerlink" title="🦅 继承和组合的区别在哪？"></a>🦅 继承和组合的区别在哪？</h2><ul>
<li>继承：指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。在 Java 中，此类关系通过关键字 extends 明确标识，在设计时一般没有争议性。</li>
<li>组合：组合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即 has-a 的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。<ul>
<li>比如，计算机与 CPU 、公司与员工的关系等。</li>
<li>表现在代码层面，和关联关系是一致的，只能从语义级别来区分。</li>
</ul>
</li>
</ul>
<p>因为组合能带来比继承更好的灵活性，所以有句话叫做“组合优于继承”。感兴趣的胖友，可以看看 <a href="https://www.zhihu.com/question/21862257" target="_blank" rel="noopener">《怎样理解“组合优于继承”以及“OO的反模块化”，在这些方面FP具体来说有什么优势？》</a> 文章。</p>
<h2 id="🦅-请详细讲述一下-RandomAccess-接口有什么作用？"><a href="#🦅-请详细讲述一下-RandomAccess-接口有什么作用？" class="headerlink" title="🦅 请详细讲述一下 RandomAccess 接口有什么作用？"></a>🦅 请详细讲述一下 RandomAccess 接口有什么作用？</h2><p>RandomAccess 用来当标记的，是一种<strong>标记</strong>接口，接口的非典型用法。意思是，随机访问任意下标元素都比较快。</p>
<p>用处，当要实现某些算法时，会判断当前类是否实现了 RandomAccess 接口，会根据结果选择不同的算法。</p>
<h1 id="讲讲类的实例化顺序？"><a href="#讲讲类的实例化顺序？" class="headerlink" title="讲讲类的实例化顺序？"></a>讲讲类的实例化顺序？</h1><p>初始化顺序如下：</p>
<ul>
<li>父类静态变量</li>
<li>父类静态代码块</li>
<li>子类静态变量、</li>
<li>子类静态代码块</li>
<li>父类非静态变量（父类实例成员变量）</li>
<li>父类构造函数</li>
<li>子类非静态变量（子类实例成员变量）</li>
<li>子类构造函数</li>
</ul>
<p>感兴趣的胖友，可以详细看看 <a href="https://blog.csdn.net/Vencc__/article/details/52222628" target="_blank" rel="noopener">《Java 类的实例化顺序》</a> 文章，提供的示例。</p>
<h1 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h1><p>简单的说，就是在一个类、接口或者方法的内部创建另一个类。这样理解的话，创建内部类的方法就很明确了。当然，详细的可以看看 <a href="https://blog.csdn.net/hikvision_java_gyh/article/details/8964155" target="_blank" rel="noopener">《Java 内部类总结（吐血之作）》</a>文章。</p>
<h2 id="🦅-内部类的作用是什么？"><a href="#🦅-内部类的作用是什么？" class="headerlink" title="🦅 内部类的作用是什么？"></a>🦅 内部类的作用是什么？</h2><p>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</p>
<h2 id="🦅-Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#🦅-Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="🦅 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>🦅 Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h2><p>可以继承其他类或实现其他接口，在 Java 集合的流式操作中，我们常常这么干。</p>
<h2 id="🦅-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#🦅-内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="🦅 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>🦅 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h2><p>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p>
<h1 id="什么是-Java-IO-？"><a href="#什么是-Java-IO-？" class="headerlink" title="什么是 Java IO ？"></a>什么是 Java IO ？</h1><p>Java IO 相关的类，在 <code>java.io</code> 包下，具体操作分成面向字节(Byte)和面向字符(Character)两种方式。如下图所示：<br><img src="https://i.loli.net/2019/03/21/5c930456bf8c0.png" alt=""><br>类图</p>
<h1 id="什么是-Java-序列化？"><a href="#什么是-Java-序列化？" class="headerlink" title="什么是 Java 序列化？"></a>什么是 Java 序列化？</h1><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。</p>
<ul>
<li>可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。</li>
<li>序列化是为了解决在对对象流进行读写操作时所引发的问题。</li>
</ul>
<p>反序列化的过程，则是和序列化相反的过程。</p>
<blockquote>
<p>另外，我们不能将序列化局限在 Java 对象转换成二进制数组，例如说，我们将一个 Java 对象，转换成 JSON 字符串，或者 XML 字符串，这也可以理解为是序列化。</p>
</blockquote>
<h2 id="🦅-如何实现-Java-序列化？"><a href="#🦅-如何实现-Java-序列化？" class="headerlink" title="🦅 如何实现 Java 序列化？"></a>🦅 如何实现 Java 序列化？</h2><blockquote>
<p>如下的方式，就是 Java 内置的序列化方案，实际场景下，我们可以自定义序列化的方案，例如说 Google Protobuf 。</p>
</blockquote>
<p>将需要被序列化的类，实现 Serializable 接口，该接口没有需要实现的方法，<code>implements Serializable</code> 只是为了标注该对象是可被序列化的。</p>
<ul>
<li>序列化<ul>
<li>然后，使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对象流)对象</li>
<li>接着，使用 ObjectOutputStream 对象的 <code>#writeObject(Object obj)</code> 方法，就可以将参数为 <code>obj</code> 的对象写出(即保存其状态)。</li>
</ul>
</li>
<li>反序列化<ul>
<li>要恢复的话则用输入流。</li>
</ul>
</li>
</ul>
<h2 id="🦅-Java-序列话中，如果有些字段不想进行序列化怎么办？"><a href="#🦅-Java-序列话中，如果有些字段不想进行序列化怎么办？" class="headerlink" title="🦅 Java 序列话中，如果有些字段不想进行序列化怎么办？"></a>🦅 Java 序列话中，如果有些字段不想进行序列化怎么办？</h2><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<ul>
<li>当对象被序列化时，阻止实例中那些用此关键字修饰的的变量序列化。</li>
<li>当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</li>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
</ul>
<h1 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h1><p>一般来说，有两种方式：</p>
<ul>
<li>1、实现 Cloneable 接口，并重写 Object 类中的 #clone() 方法。可以实现浅克隆，也可以实现深克隆。</li>
<li>2、实现 Serializable 接口，通过对象的序列化和反序列化实现克隆。可以实现真正的深克隆。<blockquote>
<p>艿艿：这个问题，也可以变种来问，什么是浅克隆和深克隆。</p>
</blockquote>
</li>
</ul>
<p>具体的代码实现，可以看看 <a href="https://blog.csdn.net/caomiao2006/article/details/52590622" target="_blank" rel="noopener">《Java 对象的浅克隆和深克隆》</a> 文章。</p>
<p>实际场景下，我们使用的克隆比较少，更多是对象之间的属性克隆。例如说，将 DO 的属性复制到 DTO 中，又或者将 DTO 的属性复制到 VO 中。此时，我们一般使用 BeanUtils 工具类。具体的使用，看看 <a href="https://www.cnblogs.com/tison/p/7840647.html" target="_blank" rel="noopener">《浅谈 BeanUtils 的拷贝，深度克隆》</a> 文章。</p>
<h1 id="error-和-exception-有什么区别？CheckedException-和-RuntimeException-有什么区别？"><a href="#error-和-exception-有什么区别？CheckedException-和-RuntimeException-有什么区别？" class="headerlink" title="error 和 exception 有什么区别？CheckedException 和 RuntimeException 有什么区别？"></a>error 和 exception 有什么区别？CheckedException 和 RuntimeException 有什么区别？</h1><p>Java 的异常体系，基于共同的祖先 <code>java.lang.Throwable</code> 类。如下图所示：</p>
<p>Throwable 类图<br><img src="https://i.loli.net/2019/03/21/5c9327469ec89.png" alt=""></p>
<ul>
<li>Error（错误），表示系统级的错误和程序不必处理的异常，是 Java 运行环境中的内部错误或者硬件问题。<ul>
<li>例如：内存资源不足等。</li>
<li>对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由 Java 虚拟机抛出的。</li>
</ul>
</li>
<li>Exception（异常），表示需要捕捉或者需要程序进行处理的异常，它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。Exception 又分为运行时异常，受检查异常。<ul>
<li>RuntimeException(运行时异常)，表示无法让程序恢复的异常，导致的原因通常是因为执行了错误的操作，建议终止逻辑，因此，编译器不检查这些异常。</li>
<li>CheckedException(受检查异常)，是表示程序可以处理的异常，也即表示程序可以修复（由程序自己接受异常并且做出处理），所以称之为受检查异常。</li>
</ul>
</li>
</ul>
<h2 id="🦅-异常的使用的注意地方？"><a href="#🦅-异常的使用的注意地方？" class="headerlink" title="🦅 异常的使用的注意地方？"></a>🦅 异常的使用的注意地方？</h2><p>神作《Effective Java》中对异常的使用给出了以下指导原则：</p>
<ul>
<li>不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常）。</li>
<li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常。<br>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）。</li>
<li>优先使用标准的异常。</li>
<li>每个方法抛出的异常都要有文档。</li>
<li>保持异常的原子性</li>
<li>不要在 <code>catch</code> 中忽略掉捕获到的异常。</li>
</ul>
<h2 id="🦅-Throwable-类常用方法？"><a href="#🦅-Throwable-类常用方法？" class="headerlink" title="🦅 Throwable 类常用方法？"></a>🦅 Throwable 类常用方法？</h2><ul>
<li><p><code>#getMessage()</code> 方法：返回异常发生时的详细信息。</p>
</li>
<li><p><code>#getCause()</code> 方法：获得导致当前 Throwable 异常的 Throwable 异常。</p>
</li>
<li><p><code>#getStackTrace()</code> 方法：获得 Throwable 对象封装的异常信息。</p>
<ul>
<li><code>#printStackTrace()</code> 方法：在控制台上打印。<h2 id="🦅-请列出-5-个运行时异常？"><a href="#🦅-请列出-5-个运行时异常？" class="headerlink" title="🦅 请列出 5 个运行时异常？"></a>🦅 请列出 5 个运行时异常？</h2></li>
</ul>
</li>
<li><p>NullPointerException</p>
</li>
<li><p>IndexOutOfBoundsException</p>
</li>
<li><p>ClassCastException</p>
</li>
<li><p>ArrayStoreException</p>
</li>
<li><p>BufferOverflowException</p>
</li>
</ul>
<h2 id="🦅-throw-与-throws-的区别-？"><a href="#🦅-throw-与-throws-的区别-？" class="headerlink" title="🦅 throw 与 throws 的区别 ？"></a>🦅 <code>throw</code> 与 <code>throws</code> 的区别 ？</h2><ul>
<li><code>throw</code> ，用于在程序中显式地抛出一个异常。</li>
<li><code>throws</code> ，用于指出在该方法中没有处理的异常。每个方法必须显式指明哪些异常没有处理，以便该方法的调用者可以预防可能发生的异常。最后，多个异常用逗号分隔。</li>
</ul>
<h2 id="🦅-异常处理中-finally-语句块的重要性"><a href="#🦅-异常处理中-finally-语句块的重要性" class="headerlink" title="🦅 异常处理中 finally 语句块的重要性?"></a>🦅 异常处理中 <code>finally</code> 语句块的重要性?</h2><p>不管程序是否发生了异常, <code>finally</code> 语句块都会被执行，甚至当没有 <code>catch</code> 声明但抛出了一个异常时, <code>finally</code> 语句块也会被执行。</p>
<p><code>finally</code> 语句块通常用于释放资源, 如 I/O 缓冲区, 数据库连接等等。</p>
<h2 id="🦅-异常被处理后异常对象会发生什么"><a href="#🦅-异常被处理后异常对象会发生什么" class="headerlink" title="🦅 异常被处理后异常对象会发生什么?"></a>🦅 异常被处理后异常对象会发生什么?</h2><p>异常对象会在下次 GC 执行时被回收。</p>
<h1 id="说说反射的用途及实现？"><a href="#说说反射的用途及实现？" class="headerlink" title="说说反射的用途及实现？"></a>说说反射的用途及实现？</h1><p>Java 反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时构造一个类的对象。</li>
<li>判断一个类所具有的成员变量和方法。</li>
<li>调用一个对象的方法。</li>
<li>生成动态代理。</li>
</ul>
<p>反射的应用很多，很多框架都有用到：</p>
<ul>
<li>Spring 框架的 IoC 基于反射创建对象和设置依赖属性。</li>
<li>Spring MVC 的请求调用对应方法，也是通过反射。</li>
<li>JDBC 的 Class#forName(String className) 方法，也是使用反射。</li>
</ul>
<p>不了解 Java 反射的同学，可以看看 《<a href="http://www.cnblogs.com/zhaopei/p/reflection.html" target="_blank" rel="noopener">什么是反射、反射可以做些什么》</a> 。</p>
<h2 id="🦅-反射中，Class-forName-和-ClassLoader-区别？"><a href="#🦅-反射中，Class-forName-和-ClassLoader-区别？" class="headerlink" title="🦅 反射中，Class.forName 和 ClassLoader 区别？"></a>🦅 反射中，Class.forName 和 ClassLoader 区别？</h2><p>这两者，都可用来对类进行加载。差别在于：</p>
<ul>
<li><code>Class#forName(...)</code> 方法，除了将类的 <code>.class</code> 文件加载到JVM 中之外，还会对类进行解释，执行类中的 <code>static</code> 块。</li>
<li><code>ClassLoader</code> 只干一件事情，就是将 <code>.class</code> 文件加载到 JVM 中，不会执行 <code>static</code> 中的内容，只有在 <code>newInstance</code> 才会去执行 <code>static</code> 块。</li>
</ul>
<blockquote>
<p><code>Class#forName(name, initialize, loader)</code> 方法，带参函数也可控制是否加载 <code>static</code> 块，并且只有调用了 <code>newInstance</code> 方法采用调用构造函数，创建类的对象。</p>
</blockquote>
<blockquote>
<p>详细的测试，可以看看 <a href="https://blog.csdn.net/qq_27093465/article/details/52262340" target="_blank" rel="noopener">《Java 反射中，Class.forName 和ClassLoader 的区别(代码说话)》</a> 文章。</p>
</blockquote>
<h2 id="🦅-UnsupportedOperationException-是什么？"><a href="#🦅-UnsupportedOperationException-是什么？" class="headerlink" title="🦅 UnsupportedOperationException 是什么？"></a>🦅 UnsupportedOperationException 是什么？</h2><p>UnsupportedOperationException ，是用于表明操作不支持的异常。</p>
<p>在 JDK 类中已被大量运用，在集合框架<code>java.util.Collections.UnmodifiableCollection</code> 将会在所有 add 和 remove 操作中抛出这个异常。</p>
<h1 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h1><p>直接看 <a href="https://www.jianshu.com/p/5cac4cb9be54" target="_blank" rel="noopener">《深入浅出 Java 注解》</a> 。</p>
<h1 id="什么时候用断言（-assert-）？"><a href="#什么时候用断言（-assert-）？" class="headerlink" title="什么时候用断言（ assert ）？"></a>什么时候用断言（ <code>assert</code> ）？</h1><p>断言，在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。</p>
<ul>
<li>一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。</li>
<li>断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为 false ，那么系统会报告一个AssertionError 错误。断言的使用如下面的代码所示：<pre class=" language-java"><code class="language-java"><span class="token keyword">assert</span><span class="token punctuation">(</span>a <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// throws an AssertionError if a &lt;= 0</span></code></pre>
</li>
<li>断言可以有两种形式：<ul>
<li>assert Expression1; 。</li>
<li>assert Expression1 : Expression2; 。</li>
<li>Expression1 应该总是产生一个布尔值。</li>
<li>Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。</li>
</ul>
</li>
<li>要在运行时启用断言，可以在启动 JVM 时使用 <code>-enableassertions</code> 或者 <code>-ea</code> 标记。要在运行时选择禁用断言，可以在启动 JVM 时使用 <code>-da</code> 或者 <code>-disableassertions</code> 标记。要在系统类中启用或禁用断言，可使用 <code>-esa</code> 或 <code>-dsa</code> 标记。还可以在包的基础上启用或者禁用断言。</li>
</ul>
<p>当然，实际场景下，我们会在 Spring 的源码中看到，它自己封装了 Assert 类，实现更方便的断言功能，并且，在生产环境下也启用。</p>
<p>另外，在单元测试中，也会使用自己封装的断言类，判断执行结果的正确与错误。</p>
<h1 id="Java-对象创建的方式？"><a href="#Java-对象创建的方式？" class="headerlink" title="Java 对象创建的方式？"></a>Java 对象创建的方式？</h1><ol>
<li>使用 new 关键字创建对象。</li>
<li>使用 Class 类的 newInstance 方法(反射机制)。</li>
<li>使用 Constructor 类的 newInstance 方法(反射机制)。</li>
<li>使用 clone 方法创建对象。</li>
<li>使用(反)序列化机制创建对象。</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 IdentityStore 安全地访问用户凭证</title>
    <url>/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%203%20%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>Java EE 8 Security API 入门，第 3 部分</p>
<blockquote>
<p><strong>关于本系列</strong></p>
<p>期盼已久的新 Java EE Security API (JSR 375) 推动 Java 企业安全性进入了云和微服务计算时代。本系列将展示新安全机制如何简化和标准化各种 Java EE 容器实现之间的安全处理，然后帮助您开始在受云支持的项目中使用它们。</p>
</blockquote>
<blockquote>
<p>此内容是该系列 4 部分中的第 3 部分： Java EE 8 Security API 入门</p>
<ul>
<li><a href="/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%201%20%E9%83%A8%E5%88%86/">第 1 部分: 针对云和微服务平台的 Java 企业安全性</a></li>
<li><a href="/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%202%20%E9%83%A8%E5%88%86/">第 2 部分: 通过 HttpAuthenticationMechanism 执行 Web 身份验证</a></li>
<li><a href="/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%203%20%E9%83%A8%E5%88%86/">第 3 部分: 通过 IdentityStore 安全地访问用户凭证</a></li>
<li><a href="http://localhost:4000/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%204%20%E9%83%A8%E5%88%86/" target="_blank" rel="noopener">第 4 部分: 通过 SecurityContext 询问调用方数据</a></li>
</ul>
</blockquote>
<p>本系列的第 1 篇文章概述了 <a href="https://jcp.org/en/jsr/detail?id=375" target="_blank" rel="noopener">Java EE Security API (JSR 375)</a>，的基本特性和组件，包括新的 IdentityStore 接口。在本文中，您将了解如何使用 IdentityStore 在您的 Java Web 应用程序中安全地存储和访问用户凭证数据。</p>
<p>新 IdentityStore 抽象是 Java EE Security API 规范版本中的 3 个重要特性之一。身份存储是一个数据库，用于存储用户身份数据，比如用户名、组成员关系，以及用于验证调用方凭证的其他信息。尽管 IdentityStore 旨在用于任何身份验证机制，但它特别适合与 Java EE 8 的 HttpAuthenticationMechanism（已在第 2 部分中介绍）集成。</p>
<p><a href="https://github.com/readlearncode/Java-EE-8-Sampler/tree/master/security-1-0" target="_blank" rel="noopener">获取代码</a></p>
<h1 id="安装-Soteria"><a href="#安装-Soteria" class="headerlink" title="安装 Soteria"></a>安装 Soteria</h1><p>我们将使用 Java EE 8 Security API 参考实现 Soteria 来探索 IdentityStore。您可以通过两种方式之一获取 Soteria。</p>
<h2 id="1-在-POM-中显式指定-Soteria"><a href="#1-在-POM-中显式指定-Soteria" class="headerlink" title="1.在 POM 中显式指定 Soteria"></a>1.在 POM 中显式指定 Soteria</h2><p>使用以下 Maven 坐标在 POM 中指定 Soteria：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.glassfish.soteria<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javax.security.enterprise<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
<h2 id="2-使用内置的-Java-EE-8-坐标"><a href="#2-使用内置的-Java-EE-8-坐标" class="headerlink" title="2.使用内置的 Java EE 8 坐标"></a>2.使用内置的 Java EE 8 坐标</h2><p>符合 Java EE 8 规范的服务器将拥有自己的新 Java EE 8 Security API 实现，否则它们会依靠 Sotoria 的实现。无论如何，您都只需要 Java EE 8 坐标：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>javax<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javaee-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
<p>与 IdentityStore 相关的接口、类和注解位于 javax.security.enterprise.identitystore 包中。</p>
<h1 id="IdentityStore-的工作原理"><a href="#IdentityStore-的工作原理" class="headerlink" title="IdentityStore 的工作原理"></a>IdentityStore 的工作原理</h1><p>类似于 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/jaas/JAASLMDevGuide.html" target="_blank" rel="noopener">JAAS LoginModule</a> 接口，IdentityStore 是一种抽象，用于与身份存储进行交互，并验证用户和检索组成员关系。IdentityStore 的设计非常适合 HttpAuthenticationMechanism，但您可以使用您希望使用的任何身份验证机制。您还可以选择是否使用容器，但在大多数情况下都推荐对 IdentityStore 机制使用容器。通过将 IdentityStore 与容器相结合，可以通过一种标准的可移植方式来控制身份存储。</p>
<h2 id="IdentityStoreHandler"><a href="#IdentityStoreHandler" class="headerlink" title="IdentityStoreHandler"></a>IdentityStoreHandler</h2><p>IdentityStore 的实例是通过 IdentityStoreHandler 进行管理的，后者提供了查询所有可用身份存储的机制。可通过 CDI 注入一个处理程序类型的实例，如清单 3 所示。在需要执行身份验证的任何地方，都将使用这个实例。（参阅第 1 部分，查看 Java EE Security API 中的 CDI 的概述。）</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Inject</span> <span class="token keyword">private</span> IdentityStoreHandler idStoreHandler<span class="token punctuation">;</span></code></pre>
<p>IdentityStoreHandler 接口有一个 validate() 方法，该方法接受一个凭证实例。此方法的实现通常会调用与一个或多个 IdentityStore 实现相关的 validate() 和 getCallerGroups() 方法，然后返回一个聚合结果。本教程后面会更详细地解释这个特性。</p>
<p>Java EE Security API 包含 IdentityStoreHandler 接口的默认实现，在大部分情况下，该实现应该就足够用了。也可以选择将默认实现替换为自定义实现。</p>
<p>IdentityStoreHandler 的默认实现向多个 IdentityStore 执行身份验证。它迭代一个存储列表，以 CredentialValidationResult 实例形式返回一个聚合结果。此对象可能非常简单，也可能非常复杂。在最简单的情况下，它会提供一个状态值：NOT_VALIDATED、INVALID 或 VALID。在许多情况下，您需要采用这些附加值的某种组合：</p>
<ul>
<li>CallerPrincipal，包含或不包含调用方的组</li>
<li>调用方的名称或 LDAP 专有名称 （DN)</li>
<li>来自身份存储的调用方的唯一标识符</li>
</ul>
<p>现在我们仅关注默认设置，但本文后面将通过实现 IdentityStore 接口来展示如何设置您自己的轻量级身份存储。</p>
<h1 id="内置身份存储"><a href="#内置身份存储" class="headerlink" title="内置身份存储"></a>内置身份存储</h1><p>Java EE Security API 包含针对 LDAP 和 RDBMS 的内置 IdentityStore 实现。像新 Security API 中的其他特性一样，这些特性很容易通过注解来调用。</p>
<ul>
<li><p>调用一个内置的 RDBMS 集成</p>
<blockquote>
<p>可通过绑定到 JNDI 的 DataSource 来访问外部数据库。您将使用 @DataBaseIdentityStoreDefinition 注解来激活一个外部数据库。激活外部数据库之后，您将通过向注解传递值来配置连接细节。</p>
</blockquote>
</li>
<li><p>调用一个内置的 LDAP 集成</p>
<blockquote>
<p>您将使用 @LdapIdentityStoreDefinition 注解来调用并配置一个 LDAP IdentityStore bean。调用这个 bean 后，可以传入所需的配置详细信息来连接到一个外部 LDAP 服务器。</p>
</blockquote>
</li>
</ul>
<p>请注意，这些实现是应用程序范围内的 CDI bean，而且基于 Java EE 7 中已有的 <a href="https://docs.oracle.com/javaee/7/api/javax/annotation/sql/DataSourceDefinition.html" target="_blank" rel="noopener">@DataStoreDefinition</a> 注解。</p>
<h2 id="如何配置一个内置的-RDBMS-身份存储"><a href="#如何配置一个内置的-RDBMS-身份存储" class="headerlink" title="如何配置一个内置的 RDBMS 身份存储"></a>如何配置一个内置的 RDBMS 身份存储</h2><p>最简单的内置身份存储是数据库存储，它是通过 @DataBaseIdentityStoreDefinition 注解进行配置的。清单 4 给出了一个内置数据库存储的样本配置。</p>
<pre class=" language-java"><code class="language-java"><span class="token number">1</span>
<span class="token annotation punctuation">@DatabaseIdentityStoreDefinition</span><span class="token punctuation">(</span> dataSourceLookup <span class="token operator">=</span> <span class="token string">"${'java:global/permissions_db'}"</span><span class="token punctuation">,</span> callerQuery <span class="token operator">=</span> <span class="token string">"#{'select password from caller where name = ?'}"</span><span class="token punctuation">,</span> groupsQuery <span class="token operator">=</span> <span class="token string">"select group_name from caller_groups where caller_name = ?"</span><span class="token punctuation">,</span> hashAlgorithm <span class="token operator">=</span> PasswordHash<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> priority <span class="token operator">=</span> <span class="token number">10</span> <span class="token punctuation">)</span> 
<span class="token annotation punctuation">@ApplicationScoped</span> 
<span class="token annotation punctuation">@Named</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationConfig</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre>
<p>如果您配置过数据库定义，那么您应该很熟悉清单 4 中的配置选项。您应该注意的一点是优先级设置为 10。此值在已经实现多个身份存储时使用。该值用于确定迭代顺序，稍后我会更详细地讨论它。</p>
<p>有 9 个可能的参数可用来配置您的数据库。您可以在 <a href="https://javaee.github.io/security-api/apidocs/javax/security/enterprise/identitystore/DatabaseIdentityStoreDefinition.html" target="_blank" rel="noopener">DatabaseIdentityStoreDefinition</a> 的 Javadoc 中了解它们。</p>
<h2 id="如何配置内置的-LDAP-身份存储"><a href="#如何配置内置的-LDAP-身份存储" class="headerlink" title="如何配置内置的 LDAP 身份存储"></a>如何配置内置的 LDAP 身份存储</h2><p>LDAP 配置拥有的配置选项比 RDBMS 选项多得多。如果您拥有使用 LDAP 配置语义的经验，则应该熟悉这些配置选项。清单 5 给出了配置 LDAP 身份存储的部分选项。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@LdapIdentityStoreDefinition</span><span class="token punctuation">(</span> url <span class="token operator">=</span> <span class="token string">"ldap://localhost:33389/"</span><span class="token punctuation">,</span> callerBaseDn <span class="token operator">=</span> <span class="token string">"ou=caller,dc=jsr375,dc=net"</span><span class="token punctuation">,</span> groupSearchBase <span class="token operator">=</span> <span class="token string">"ou=group,dc=jsr375,dc=net"</span> <span class="token punctuation">)</span> 
<span class="token annotation punctuation">@DeclareRoles</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"admin"</span><span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"demo"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> 
<span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">"/admin"</span><span class="token punctuation">)</span> 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdminServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre>
<p>参阅 <a href="https://javaee.github.io/javaee-spec/javadocs/javax/security/enterprise/identitystore/LdapIdentityStoreDefinition.html" target="_blank" rel="noopener">LdapIdentityStoreDefinition</a> Javadoc，查看配置 LDAP 身份存储的 24 个可能的参数。</p>
<p>#开发一个自定义身份存储<br>如果所有内置的身份存储都无法满足您的需求，可以使用 IdentityStore 接口来开发一个自定义解决方案。IdentityStore 接口包含 4 个方法，每个方法都拥有默认实现。清单 6 给出了每个方法的签名。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">default</span> CredentialValidationResult <span class="token function">validate</span><span class="token punctuation">(</span>Credential<span class="token punctuation">)</span> 
<span class="token keyword">default</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">getCallerGroups</span><span class="token punctuation">(</span>CredentialValidationResult<span class="token punctuation">)</span> 
<span class="token keyword">default</span> <span class="token keyword">int</span> <span class="token function">priority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token keyword">default</span> Set<span class="token operator">&lt;</span>ValidationType<span class="token operator">></span> <span class="token function">validationTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>IdentityStore 接口中的所有方法都标为 default，所以没有强制要求提供实现。默认情况下会调用两个关键方法，第三个方法在配置了多个身份存储时使用：</p>
<ul>
<li>validate() 确定给定的 Credential 是否有效，并返回一个 CredentialValidationResult。</li>
<li>getCallerGroups() 返回一个包含与调用方相关的组名称的集合，将它们聚合到 CredentialValidationResult 实例中已列出的组中。</li>
<li>getPriority() 在定义一个以上 IdentityStore 时使用。该值越低，优先级就越高。优先级相同会产生未定义的行为。</li>
<li>validationTypes() 返回一组 ValidationTypes，它们确定了已实现哪个/哪些方法（validate() 和/或 getCallerGroups()）。</li>
</ul>
<p>对 validate() 方法的调用可以确定给定的 Credential 是否有效，并返回一个 CredentialValidationResult。返回的 CredentialValidationResult 实例上的各种方法提供了调用方的 LDAP 专有名称 （DN)、唯一身份存储 ID、结果状态、身份存储 ID、Principal 和组成员关系。</p>
<h2 id="实现-validate-和-getCallerGroups"><a href="#实现-validate-和-getCallerGroups" class="headerlink" title="实现 validate() 和 getCallerGroups()"></a>实现 validate() 和 getCallerGroups()</h2><blockquote>
<p><em>备注</em> ：结果状态对确定 IdentityStoreHandler 在配置了一个以上 IdentityStoreHandler 时的行为至关重要；状态选项包括 NOT_VALIDATED、INVALID 或 VALID。</p>
</blockquote>
<p>validate() 和 getCallerGroups() 方法用于验证调用方的 Credential 或获取它们的组信息。数据存储实现可以使用其中一个方法或两个方法都使用。实际实现的方法是通过 validationTypes() 方法来声明的。</p>
<p>此特性使您能够灵活地指定一个身份存储来执行身份验证，而另一个身份存储负责执行授权。validationTypes() 方法返回一组 ValidationType，这些类型可能包含 VALIDATE 或/和 PROVIDE_GROUPS。VALIDATE 常量表明 validate() 方法已实现，PROVIDE_GROUPS 表明 getCallerGroups() 方法已实现。如果同时返回了二者，则两个方法都已实现。</p>
<h1 id="处理多个身份存储"><a href="#处理多个身份存储" class="headerlink" title="处理多个身份存储"></a>处理多个身份存储</h1><blockquote>
<p><em>备注</em> ：IdentityStore 不应该维护状态，也不应该拥有调用方身份验证流程的当前进度的任何信息。从逻辑上讲，通过身份存储来跟踪用户的身份验证状态是没有意义的。</p>
</blockquote>
<p>IdentityStoreHandler 在需要处理多个 IdentityStore 实现的场景中使用。它提供了一个名为 validate() 的方法，该方法拥有与 IdentityStore 实现上的同名方法相同的签名。这里的思路是允许将多个身份存储有效地作为单一 IdentityStore。</p>
<p>IdentityStoreHandler 上的 validate() 方法使用以下逻辑对身份存储进行查询：</p>
<ol>
<li>依据 validationTypes() 方法所声明的功能，调用身份存储的 validate() 方法。这些方法是按 getPriority() 方法所确定的顺序进行调用的。<ul>
<li>如果返回 VALID 状态结果，则不需要进一步询问任何身份存储。在这种情况下，逻辑跳转到第 2 步。</li>
<li>如果状态为 INVALID，则记住此状态供以后使用，而且 IdentityStoreHandler 会继续询问剩余的身份存储。</li>
</ul>
</li>
<li>如果仅返回了一个 INVALID 状态，则返回 INVALID；否则返回 NOT_VALIDATED。</li>
<li>如果返回了一个 VALID 结果且身份存储声明了 PROVIDE_GROUPS 验证类型，那么 IdentityStoreHandler 将会开始收集调用方组成员关系，这是通过将返回的调用方组聚合到 CredentialValidationResult 对象中来完成的。<ul>
<li>所有仅声明了 PROVIDE_GROUPS 验证类型的 IdentityStores 都通过调用 getCallerGroups() 方法来询问。返回的组名称列表与累积的组集合聚合在一起。</li>
</ul>
</li>
<li>询问所有 IdentityStores 后，会通过一个 VALID 状态和调用方组列表来构造一个 CredentialValidationResult，并返回该结果。</li>
</ol>
<h2 id="询问实践"><a href="#询问实践" class="headerlink" title="询问实践"></a>询问实践</h2><p>现在，让我们来看一个需要询问多个身份存储的场景。在此场景中，IdentityStore 1 连接到一个 RDBMS，而 IdentityStore 2 和 IdentityStore 3 连接到一个 LDAP 容器。</p>
<p>在图 1 中，身份存储处理程序按优先级顺序迭代 IdentityStore 实例，在每个实例上调用 validate() 方法，直到它找到一个返回 VALID 状态的 CredentialValidationResult。这发生在询问 IdentityStore 2 时。该处理程序停止这次迭代，开始第二次迭代来收集调用方的组。</p>
<p>图 1. IdentityStoreHandler 对身份存储的第一次询问<br>IdentityStoreHandler’s first interrogation of identity stores.<br><img src="https://www.ibm.com/developerworks/cn/java/j-javaee8-security-api-3/IdentityStorePass1.png" alt=""></p>
<p>图 2 表示第二次迭代。该处理程序在每个 IdentityStore 实例上调用 getCallerGroups() 方法，仅声明一个 PROVIDE_GROUPS 验证类型。</p>
<p>在此场景中，唯一符合该规范的身份存储是 IdentityStore 3。返回的调用方组与组名称集合相结合，后者通过在 IdentityStore 2 返回的 CredentialValidationResult 实例上调用 getCallerGroups() 来返回。</p>
<p>图 2. IdentityStoreHandler 对身份存储的第二次询问<br>IdentityStoreHandler’s second interrogation of identity stores.<br><img src="https://www.ibm.com/developerworks/cn/java/j-javaee8-security-api-3/IdentityStorePass2.png" alt=""></p>
<p>询问所有 IdentityStores 后，会通过一个 VALID 状态和调用方组列表来构造一个 CredentialValidationResult，并返回该结果。</p>
<p>这个简单示例演示了如何通过一个 IdentityStore 来验证调用方，以及如何根据一个组成员列表来构建另一个组成员列表。</p>
<h1 id="包含-cookie-的凭证"><a href="#包含-cookie-的凭证" class="headerlink" title="包含 cookie 的凭证"></a>包含 cookie 的凭证</h1><p>就像在第 2 部分中的 HttpAuthenticationMechanism 中所看到的那样，使用 cookie 开发自定义 IdentityStore 解决方案相当容易。RememberMeIdentityStore 类似于 IdentityStore 接口，但它的目的是供支持 @RememberMe 注解的拦截器绑定使用，而不是供身份验证机制使用。</p>
<p>RememberMeIdentityStore 被用于：</p>
<ul>
<li>为调用方生成一个“记住我”登录令牌。</li>
<li>记住与“记住我”登录令牌相关的调用方。</li>
<li>如果调用方返回，则验证登录令牌，而且无需额外的凭证即可重新验证调用方。</li>
</ul>
<p>validate() 方法接收传递的 RememberMeCredential 并验证它，而 generateLoginToken() 方法将一个令牌与给定的组和主体相关联。如果没有找到调用方的登录令牌，或者如果登录令牌已过期，则执行正常的身份验证。</p>
<h1 id="第-3-部分小结"><a href="#第-3-部分小结" class="headerlink" title="第 3 部分小结"></a>第 3 部分小结</h1><p>IdentityStore 接口为在 Java 企业应用程序中集成外部调用方验证和授权机制提供了人们期待已久的必要简化。IdentityStore 保证了跨容器和服务器的可移植性，使得与多个身份存储无缝通信变得很容易。</p>
<p>如果您不需要实现自定义身份存储，那么一个注解和一些连接细节就足以配置一个 LDAP 容器或 RDBMS 了。任何 Java EE 8 身份存储都将支持内置的 HttpAuthenticationMechanism，所以将 LDAP 登录信息与 Web 用户连接起来非常简单，只需一些注解即可。</p>
<p>敬请期待本教程系列的最后一篇文章，其中将介绍新的 SecurityContext 接口。</p>
<p>测试您的知识</p>
<ol>
<li>以下哪些选项用于配置内置的身份存储？（选择所有适合的选项。）<ol>
<li>@LdapIdentityStoreDefinition</li>
<li>@DatabaseIdentityStoreDefinition</li>
<li>@RdbmsIdentityStoreDefinition</li>
<li>@DataBaseIdentityStoreDefinition</li>
<li>@RememberMeIdentityStoreDefinition</li>
</ol>
</li>
<li>以下哪些 IdentityStore 接口方法拥有默认实现？<ol>
<li>只有 priority() 和 validationTypes()。</li>
<li>只有 priority()，而且在未设置时，默认优先级为 100。</li>
<li>只有 CredentialValidationResult()、priority() 和 validationTypes()。</li>
<li>所有 4 个接口方法都有默认实现。</li>
<li>所有接口方法都没有默认实现。</li>
</ol>
</li>
<li>给定多个 IdentityStore 实现，在对 validate() 方法的调用返回 VALID 时，IdentityStoreHandler 的默认行为是什么？<ol>
<li>它会继续询问剩余的身份存储，直到身份存储的第二轮迭代开始。</li>
<li>它会停止迭代，通过返回 CredentialValidationResult 对象来确认调用方的授权。</li>
<li>它会重新开始对身份存储进行迭代并调用 getCallerGroups() 方法。</li>
<li>它会在该身份存储上调用 getCallerGroups() 方法，构造并返回一个 CredentialValidationResult 对象。</li>
<li>上述选项都不是</li>
</ol>
</li>
<li>在 IdentityStore 实例上调用 getCallerGroups() 方法，会返回以下哪种类型？<ol>
<li>List<string></string></li>
<li>Set<string></string></li>
<li>Map&lt;Caller, String&gt;</li>
<li>Set<group></group></li>
<li>List<group></group></li>
</ol>
</li>
<li>以下哪些有关 RememberMeIdentityStore 的陈述是正确的？<ol>
<li>RememberMeIdentityStore 扩展了 IdentityStore。</li>
<li>它的目的是供支持 @RememberMe 注解的拦截器绑定使用。</li>
<li>它可用于重新验证调用方，而不需要提供额外的凭证。</li>
<li>它是 3 个内置的 IdentityStore 类型之一。</li>
<li>如果“记住我”登录令牌过期，则执行正常的身份验证。<br>核对您的答案：</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">问题</th>
<th align="center">答案</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">14</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">235</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java EE</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 HttpAuthenticationMechanism 执行 Web 身份验证</title>
    <url>/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%202%20%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>Java EE 8 Security API 入门，第 1 部分</p>
<blockquote>
<p><strong>关于本系列</strong></p>
<p>期盼已久的新 Java EE Security API (JSR 375) 推动 Java 企业安全性进入了云和微服务计算时代。本系列将展示新安全机制如何简化和标准化各种 Java EE 容器实现之间的安全处理，然后帮助您开始在受云支持的项目中使用它们。</p>
</blockquote>
<blockquote>
<p>此内容是该系列 4 部分中的第 1 部分： Java EE 8 Security API 入门</p>
<ul>
<li><a href="/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%201%20%E9%83%A8%E5%88%86/">第 1 部分: 针对云和微服务平台的 Java 企业安全性</a></li>
<li><a href="/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%202%20%E9%83%A8%E5%88%86/">第 2 部分: 通过 HttpAuthenticationMechanism 执行 Web 身份验证</a></li>
<li><a href="/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%203%20%E9%83%A8%E5%88%86/">第 3 部分: 通过 IdentityStore 安全地访问用户凭证</a></li>
<li><a href="http://localhost:4000/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%204%20%E9%83%A8%E5%88%86/" target="_blank" rel="noopener">第 4 部分: 通过 SecurityContext 询问调用方数据</a></li>
</ul>
</blockquote>
<p>本系列的第 1 篇文章概述了 <a href="https://jcp.org/en/jsr/detail?id=375" target="_blank" rel="noopener">Java EE Security API (JSR 375)</a>，包括对新 HttpAuthenticationMechanism、IdentityStore 和 SecurityContext 接口的大体介绍。本文是 3 篇深入剖析文章的第一篇，您将学习如何使用 HttpAuthenticationMechanism 在一个示例 Java Web 应用程序中设置和配置用户身份验证。</p>
<p>HttpAuthenticationMechanism 接口是 Java™ EE 的新 HTTP 身份验证机制的核心。它提供了 3 个内置的启用了 CDI（上下文和依赖注入）的实现，这些实现自动被实例化并提供给 CDI 容器使用。这些内置的实现支持 Servlet 4.0 指定的 3 种经典身份验证方法：基本 HTTP 身份验证、基于表单的身份验证和基于表单的自定义身份验证。</p>
<p>除了内置的身份验证方法之外，您还可以选择使用 HttpAuthenticationMechanism 来开发自定义身份验证。如果您需要支持特定的协议和身份验证令牌，可以选择此选项。一些 servlet 容器可能也提供了自定义 HttpAuthenticationMechanism 实现。</p>
<p>本文将结合实践来介绍如何使用 HttpAuthenticationMechanism 接口和它的 3 种内置实现。我还将展示如何编写您自定义的 HttpAuthenticationMechanism 身份验证机制。</p>
<p><a href="https://github.com/readlearncode/Java-EE-8-Sampler/tree/master/security-1-0" target="_blank" rel="noopener">获取代码</a></p>
<h1 id="安装-Soteria"><a href="#安装-Soteria" class="headerlink" title="安装 Soteria"></a>安装 Soteria</h1><p>我们将使用 Java EE 8 Security API 参考实现 <a href="https://github.com/javaee/security-soteria" target="_blank" rel="noopener">Soteria</a> 来探索可通过 HttpAuthenticationMechanism 访问的内置和自定义身份验证机制。您可以通过两种方式之一获取 Soteria。</p>
<ol>
<li>在 POM 中显式指定 Soteria</li>
</ol>
<p>使用以下 Maven 坐标在 POM 中指定 Soteria：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.glassfish.soteria<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javax.security.enterprise<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
<ol start="2">
<li>使用内置的 Java EE 8 坐标<br>符合 Java EE 8 规范的服务器将拥有自己的新 Java EE 8 Security API 实现，否则它们会依靠 Sotoria 的实现。无论如何，您都只需要 Java EE 8 坐标：</li>
</ol>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>javax<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javaee-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
<h1 id="内置身份验证机制"><a href="#内置身份验证机制" class="headerlink" title="内置身份验证机制"></a>内置身份验证机制</h1><p>内置 HTTP 身份验证机制支持为 <a href="https://javaee.github.io/servlet-spec/downloads/servlet-4.0/servlet-4_0_FINAL.pdf" target="_blank" rel="noopener">Servlet 4.0（13.6 小节）</a>指定的身份验证风格。在接下来的几节中，我将展示如何使用注解来启动这 3 种身份验证机制，以及如何在 Java Web 应用程序中设置和实现每种机制。</p>
<h2 id="BasicAuthenticationMechanismDefinition"><a href="#BasicAuthenticationMechanismDefinition" class="headerlink" title="@BasicAuthenticationMechanismDefinition"></a>@BasicAuthenticationMechanismDefinition</h2><p>@BasicAuthenticationMechanismDefinition 注解触发 Servlet 4.0（13.6.1 小节）所定义的 HTTP 基本身份验证。它拥有一个可选参数 realmName，该参数指定将通过 WWW-Authenticate 标头发送的范围名称。清单 3 展示了如何为范围名称 user-realm 触发 HTTP 基本身份验证。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@BasicAuthenticationMechanismDefinition</span><span class="token punctuation">(</span>realmName<span class="token operator">=</span><span class="token string">"user-realm"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@DeclareRoles</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"admin"</span><span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"demo"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@ServletSecurity</span><span class="token punctuation">(</span><span class="token annotation punctuation">@HttpConstraint</span><span class="token punctuation">(</span>rolesAllowed <span class="token operator">=</span> <span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span> … <span class="token punctuation">}</span></code></pre>
<h2 id="FormAuthenticationMechanismDefinition"><a href="#FormAuthenticationMechanismDefinition" class="headerlink" title="@FormAuthenticationMechanismDefinition"></a>@FormAuthenticationMechanismDefinition</h2><p>@FormAuthenticationMechanismDefinition 注解触发 Servlet 4.0 规范（13.6.3 小节）所定义的基于表单的身份验证。它有一个必须设置的配置选项。loginToContinue 选项接受一个已配置的 @LoginToContinue 注解，这使得应用程序能提供“登录并继续操作”的功能。您可以选择使用合理的默认设置，或者为此特性指定 4 种特征之一。</p>
<p>在清单 4 中，登录页指定为 URI /login-servlet。如果身份验证失败，则将操作流传递给 /login-servlet-fail。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FormAuthenticationMechanismDefinition</span><span class="token punctuation">(</span>
    loginToContinue <span class="token operator">=</span> <span class="token annotation punctuation">@LoginToContinue</span><span class="token punctuation">(</span>
           loginPage <span class="token operator">=</span> <span class="token string">"/login-servlet"</span><span class="token punctuation">,</span>
           errorPage <span class="token operator">=</span> <span class="token string">"/login-servlet-fail"</span>
           <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token annotation punctuation">@ApplicationScoped</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationConfig</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre>
<p>要设置到达登录页的方式，可以使用 useForwardToLogin 选项。要将此选项设置为“forward”或“redirect”，可以指定 true 或 false，默认设置为 true。也可以通过一个传递给该选项的 EL 表达式来设置该值：useForwardToLoginExpression。</p>
<p>@LoginToContinue 拥有合理的默认设置。登录页被设置为 /login，错误页被设置为 /login-error。</p>
<h2 id="CustomFormAuthenticationMechanismDefinition"><a href="#CustomFormAuthenticationMechanismDefinition" class="headerlink" title="@CustomFormAuthenticationMechanismDefinition"></a>@CustomFormAuthenticationMechanismDefinition</h2><p>@CustomFormAuthenticationMechanismDefinition 注解提供了配置一个自定义登录表单的选项。在清单 5 中，可以看到网站的登录页被标识为 login.do。登录页被设置为 loginPage 参数的一个值，传递给 @CustomFormAuthenticationMechanismDefinition 注解的 loginToContinue 参数。请注意，loginToContinue 是唯一的参数，而且它是可选的。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@CustomFormAuthenticationMechanismDefinition</span><span class="token punctuation">(</span>
   loginToContinue <span class="token operator">=</span> <span class="token annotation punctuation">@LoginToContinue</span><span class="token punctuation">(</span>
       loginPage<span class="token operator">=</span><span class="token string">"/login.do"</span>
   <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">"/admin"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@DeclareRoles</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"admin"</span><span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"demo"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@ServletSecurity</span><span class="token punctuation">(</span><span class="token annotation punctuation">@HttpConstraint</span><span class="token punctuation">(</span>rolesAllowed <span class="token operator">=</span> <span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdminServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre>
<p>login.do 登录页如清单 6 所示，而且是一个受登录后台 bean 支持的 JSF (JavaServer Pages) 页面，如清单 7 所示。</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name"><span class="token namespace">jsf:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span>Username<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">></span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">jsf:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">jsf:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#{loginBean.username}<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span>Password<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">></span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">jsf:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">jsf:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#{loginBean.password}<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>
       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Login<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">jsf:</span>action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#{loginBean.login}<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></code></pre>
<p>登录后台 bean 使用一个 SecurityContext 实例来执行身份验证，如清单 7 所示。如果成功，用户可以访问该资源；否则，操作流会被传递给错误的页面。在这种情况下，系统会将用户转发到 /login-error 上的默认登录 URI。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Named</span>
<span class="token annotation punctuation">@RequestScoped</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginBean</span> <span class="token punctuation">{</span>

   <span class="token annotation punctuation">@Inject</span>
   <span class="token keyword">private</span> SecurityContext securityContext<span class="token punctuation">;</span>

   <span class="token annotation punctuation">@Inject</span>
   <span class="token keyword">private</span> FacesContext facesContext<span class="token punctuation">;</span>

   <span class="token keyword">private</span> String username<span class="token punctuation">,</span> password<span class="token punctuation">;</span>

   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

       Credential credential <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UsernamePasswordCredential</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Password</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

       AuthenticationStatus status <span class="token operator">=</span> securityContext<span class="token punctuation">.</span><span class="token function">authenticate</span><span class="token punctuation">(</span>
           <span class="token function">getRequestFrom</span><span class="token punctuation">(</span>facesContext<span class="token punctuation">)</span><span class="token punctuation">,</span>
           <span class="token function">getResponseFrom</span><span class="token punctuation">(</span>facesContext<span class="token punctuation">)</span><span class="token punctuation">,</span>
           <span class="token function">withParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">credential</span><span class="token punctuation">(</span>credential<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

       <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>SEND_CONTINUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           facesContext<span class="token punctuation">.</span><span class="token function">responseComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>SEND_FAILURE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">addError</span><span class="token punctuation">(</span>facesContext<span class="token punctuation">,</span> <span class="token string">"Authentication failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>

   <span class="token punctuation">}</span>
   <span class="token comment" spellcheck="true">// Some methods omitted for brevity</span>
<span class="token punctuation">}</span></code></pre>
<h1 id="编写自定义-HttpAuthenticationMechanism"><a href="#编写自定义-HttpAuthenticationMechanism" class="headerlink" title="编写自定义 HttpAuthenticationMechanism"></a>编写自定义 HttpAuthenticationMechanism</h1><p>在许多情况下，您会发现这 3 种内置实现就足以满足您的需求。在某些情况下，您可能更喜欢编写自己的 HttpAuthenticationMechanism 接口实现。在本节，我将介绍编写一个自定义 HttpAuthenticationMechanism 接口的流程。</p>
<p>为了确保它可用于您的 Java 应用程序，您需要通过 @ApplicationScope 将 HttpAuthenticationMechanism 接口实现为一个 CDI bean。该接口定义了以下 3 个方法：</p>
<ul>
<li>validateRequest() 验证一个 HTTP 请求。</li>
<li>secureResponse() 获取 HTTP 响 应消息。</li>
<li>cleanSubject() 清除所提供的主体和凭证的主题。</li>
</ul>
<p>所有方法都接受相同的参数类型，它们是：HttpServletRequest、HttpServletResponse 和 HttpMessageContext。这些参数对应于容器所提供的 <a href="https://github.com/trajano/server-auth-modules" target="_blank" rel="noopener">JASPIC Server Auth Module</a> 接口上定义的相应方法。当在 Server Auth 上调用一个 JASPIC 方法时，它会委托给您的自定义 HttpAuthenticationMechanism 的相应方法。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ApplicationScoped</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomAuthenticationMechanism</span> <span class="token keyword">implements</span> <span class="token class-name">HttpAuthenticationMechanism</span> <span class="token punctuation">{</span>

   <span class="token annotation punctuation">@Inject</span>
   <span class="token keyword">private</span> IdentityStoreHandler idStoreHandler<span class="token punctuation">;</span>

   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> AuthenticationStatus <span class="token function">validateRequest</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">,</span> 
                                               HttpServletResponse res<span class="token punctuation">,</span> 
                                               HttpMessageContext msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment" spellcheck="true">// use idStoreHandler to authenticate and authorize access</span>
       <span class="token keyword">return</span> msg<span class="token punctuation">.</span><span class="token function">responseUnauthorized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// other responses available</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h1 id="HTTP-请求期间的方法执行"><a href="#HTTP-请求期间的方法执行" class="headerlink" title="HTTP 请求期间的方法执行"></a>HTTP 请求期间的方法执行</h1><p>在一个 HTTP 请求期间，会在固定的时刻调用 HttpAuthenticationMechanism 实现上的方法。图 1 展示了何时调用与 Filter 和 HttpServlet 实例上的方法相关的每个方法。</p>
<p>图 1. 方法调用顺序<br><img src="https://www.ibm.com/developerworks/cn/java/j-javaee8-security-api-2/MethodCallSequence.png" alt=""></p>
<p>validateRequest() 方法在 doFilter() 或 service() 方法之前调用，而且会响应在 HttpServletResponse 实例上调用的 authenticate()。此方法的目的是允许调用方执行身份验证。为了帮助完成此操作，该方法可以访问调用方的 HttpRequest 和 HttpResponse 实例。它可以使用这些实例来提取请求的身份验证信息。它还可以写入到 HTTP 响应中，以便将调用方重定向到 OAuth 提供程序。执行身份验证后，它可以使用 HttpMessageContext 实例来通知身份验证状态。</p>
<p>secureResponse() 方法在 doFilter() 或 service() 之后调用。它在一个 servlet 或过滤器生成的响应上提供后处理功能。加密是此方法的一种潜在用途。</p>
<p>cleanSubject() 方法在 HttpServletRequest 实例上调用 logout() 方法之后调用。此方法也可用于在发生注销事件后清除与用户相关的状态。</p>
<p>HttpAuthenticationMechanism 实例可以使用 HttpMessageContext 接口的一些方法来与调用它的 JASPIC ServerAuthModule 通信。</p>
<h1 id="自定义示例：使用-cookie-的身份验证"><a href="#自定义示例：使用-cookie-的身份验证" class="headerlink" title="自定义示例：使用 cookie 的身份验证"></a>自定义示例：使用 cookie 的身份验证</h1><p>前面已经提到过，您通常会编写一个自定义实现来提供内置选项所没有的功能。一个示例是在您的身份验证流中使用 cookie。</p>
<p>在类级别上，您可以使用可选的 @RememberMe 注解来有效地“记住”一次用户身份验证，并在每个请求中自动应用它。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RememberMe</span><span class="token punctuation">(</span>
       cookieMaxAgeSeconds <span class="token operator">=</span> <span class="token number">3600</span>
<span class="token punctuation">)</span>
<span class="token annotation punctuation">@ApplicationScoped</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomAuthenticationMechanism</span> <span class="token keyword">implements</span> <span class="token class-name">HttpAuthenticationMechanism</span> <span class="token punctuation">{</span> … <span class="token punctuation">}</span></code></pre>
<p>此注解有 8 个配置选项，所有这些选项都包含合理的默认值，所以您不需要手动实现它们：</p>
<ul>
<li>cookieMaxAgeSeconds 设置 “remember me” cookie 的寿命。</li>
<li>cookieMaxAgeSecondsExpression 是 cookieMaxAgeSeconds 的 EL 版本。</li>
<li>cookieSecureOnly 指定该 cookie 仅应通过安全方式 (HTTPS) 进行访问。</li>
<li>cookieSecureOnlyExpression 是 cookieSecureOnly 的 EL 版本。</li>
<li>cookieHttpOnly 表示该 cookie 应该仅通过 HTTP 请求进行发送。</li>
<li>cookieHttpOnlyExpression 是  cookieHttpOnly 的 EL 版本。</li>
<li>cookieName 设置 cookie 的名称。</li>
<li>isRememberMe 打开或关闭“remember me”。</li>
<li>isRememberMeExpression 是 isRememberMe 的 EL 版本。</li>
</ul>
<p>RememberMe 功能被实现为拦截器绑定。该容器将拦截对 validateRequest() 和 cleanSubject() 方法的调用。在一个包含 RememberMe cookie 的实现上调用 validateRequest() 方法时，会尝试验证调用方。如果成功，则会告知 HttpMessageConext 发生了一个登录事件；否则会删除该 cookie。拦截 cleanSubject() 方法会删除该 cookie 并完成注销请求。</p>
<h1 id="第-2-部分小结"><a href="#第-2-部分小结" class="headerlink" title="第 2 部分小结"></a>第 2 部分小结</h1><p>新 HttpAuthenticationMechanism 接口是 Java EE 8 中的 Web 身份验证的核心。它的内置身份验证机制支持 Servlet 4.0 中指定的 3 种经典身份验证方法，而且它也很容易针对自定义实现来扩展该接口。在本教程中，您学习了如何使用注解来调用和配置 HttpAuthenticationMechanism 的内置机制，以及如何为特殊用例编写自定义机制。您可以通过下面的测验问题来测试所学的知识。</p>
<p>本文是 3 篇介绍新 Java EE 8 Security API 的主要组件的深度剖析文章中的第一篇。接下来的两篇文章将结合实践来介绍 IdentityStore 和 SecurityContext API。</p>
<h1 id="测试您的知识"><a href="#测试您的知识" class="headerlink" title="测试您的知识"></a>测试您的知识</h1><ol>
<li>3 种默认的 HttpAuthenticationMechanism 实现是哪些？<ol>
<li>@BasicFormAuthenticationMechanismDefinition</li>
<li>@FormAuthenticationMechanismDefinition</li>
<li>@LoginFormAuthenticationMechanismDefinition</li>
<li>@CustomFormAuthenticationMechanismDefinition</li>
<li>@BasicAuthenticationMechanismDefinition</li>
</ol>
</li>
<li>以下哪两种注解会触发基于表单的身份验证？<ol>
<li>@BasicAuthenticationMechanismDefinition</li>
<li>@BasicFormAuthenticationMechanismDefinition</li>
<li>@FormAuthenticationMechanismDefinition</li>
<li>@FormBasedAuthenticationMechanismDefinition</li>
<li>@CustomFormAuthenticationMechanismDefinition</li>
</ol>
</li>
<li>以下哪两种配置是基本身份验证的有效配置？<ol>
<li>@BasicAuthenticationMechanismDefinition(realmName=”user-realm”)</li>
<li>@BasicAuthenticationMechanismDefinition(userRealm=”user-realm”)</li>
<li>@BasicAuthenticationMechanismDefinition(loginToContinue = @LoginToContinue)</li>
<li>@BasicAuthenticationMechanismDefinition</li>
<li>@BasicAuthenticationMechanismDefinition(realm=”user-realm”)</li>
</ol>
</li>
<li>以下哪三种配置是基于表单的身份验证的有效配置？<ol>
<li>@FormAuthenticationMechanismDefinition(loginToContinue = @LoginToContinue)</li>
<li>@FormAuthenticationMechanismDefinition</li>
<li>@FormBasedAuthenticationMechanismDefinition</li>
<li>@FormAuthenticationMechanismDefinition(loginToContinue = 1. @LoginToContinue(useForwardToLoginExpression = “${appConfigs.forward}”))</li>
<li>@FormBasedAuthenticationMechanismDefinition(loginToContinue = @LoginToContinue)</li>
</ol>
</li>
<li>在 HTTP 请求期间，应在 HttpAuthenticationMechanism、Filter 和 HttpServlet 实现上按何种顺序调用方法？<ol>
<li>doFilter()、validateRequest()、service()、secureResponse()</li>
<li>validateRequest()、doFilter()、secureResponse()、service()</li>
<li>validateRequest()、service()、doFilter()、secureResponse()</li>
<li>validateRequest()、doFilter()、service()、secureResponse()</li>
<li>service()、secureResponse()、doFilter()、validateRequest()</li>
</ol>
</li>
<li>您如何设置 RememberMe cookie 的最大寿命？<ol>
<li>@RememberMe(cookieMaxAge = (units = SECONDS, value = 3600)</li>
<li>@RememberMe(maxAgeSeconds = 3600)</li>
<li>@RememberMe(cookieMaxAgeSeconds = 3600)</li>
<li>@RememberMe(cookieMaxAgeMilliseconds = 3600000)</li>
<li>@RememberMe(cookieMaxAgeSeconds = “3600”)</li>
</ol>
</li>
</ol>
<p>核对您的答案：</p>
<table>
<thead>
<tr>
<th align="center">问题</th>
<th align="center">答案</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">235</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">35</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">14</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">124</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">3</td>
</tr>
</tbody></table>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java EE</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次VUE的SSR体验 --小米原创</title>
    <url>/2018/07/13/npm/vue/%E8%AE%B0%E4%B8%80%E6%AC%A1SSR%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><blockquote>
<p>nuxtjs是vue官网推荐的SSR框架</p>
</blockquote>
<pre class=" language-cmd"><code class="language-cmd"> vue init nuxt-community/starter-template <project-name></code></pre>
<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>Nuxt.js 的应用目录架构提供了良好的代码分层结构，适用于开发或大或小的应用。 当然，你也可以根据自己的偏好组织应用代码。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="资源目录"><a href="#资源目录" class="headerlink" title="资源目录"></a>资源目录</h3><p>资源目录 assets 用于组织未编译的静态资源如 LESS、SASS 或 JavaScript。</p>
<h3 id="组件目录"><a href="#组件目录" class="headerlink" title="组件目录"></a>组件目录</h3><p>组件目录 components 用于组织应用的 Vue.js 组件。Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不会像页面组件那样有 asyncData 方法的特性。</p>
<h3 id="布局目录"><a href="#布局目录" class="headerlink" title="布局目录"></a>布局目录</h3><p>布局目录 layouts 用于组织应用的布局组件。</p>
<p>该目录名为Nuxt.js保留的，不可更改。</p>
<h3 id="中间件目录"><a href="#中间件目录" class="headerlink" title="中间件目录"></a>中间件目录</h3><p>middleware 目录用于存放应用的中间件。</p>
<h3 id="页面目录"><a href="#页面目录" class="headerlink" title="页面目录"></a>页面目录</h3><p>页面目录 pages 用于组织应用的路由及视图。Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。</p>
<p>该目录名为Nuxt.js保留的，不可更改。</p>
<h3 id="插件目录"><a href="#插件目录" class="headerlink" title="插件目录"></a>插件目录</h3><p>插件目录 plugins 用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。</p>
<h3 id="静态文件目录"><a href="#静态文件目录" class="headerlink" title="静态文件目录"></a>静态文件目录</h3><p>静态文件目录 static 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。 服务器启动的时候，该目录下的文件会映射至应用的根路径 / 下。</p>
<p>举个例子: /static/robots.txt 映射至 /robots.txt</p>
<p>该目录名为Nuxt.js保留的，不可更改。</p>
<h3 id="Store-目录"><a href="#Store-目录" class="headerlink" title="Store 目录"></a>Store 目录</h3><p>store 目录用于组织应用的 Vuex 状态树 文件。 Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。</p>
<p>该目录名为Nuxt.js保留的，不可更改。</p>
<h3 id="nuxt-config-js-文件"><a href="#nuxt-config-js-文件" class="headerlink" title="nuxt.config.js 文件"></a>nuxt.config.js 文件</h3><p>nuxt.config.js 文件用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。</p>
<p>该文件名为Nuxt.js保留的，不可更改。</p>
<h3 id="package-json-文件"><a href="#package-json-文件" class="headerlink" title="package.json 文件"></a>package.json 文件</h3><p>package.json 文件用于描述应用的依赖关系和对外暴露的脚本接口。</p>
<p>该文件名为Nuxt.js保留的，不可更改。</p>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><table>
<thead>
<tr>
<th align="center">别名</th>
<th align="center">目录</th>
</tr>
</thead>
<tbody><tr>
<td align="center">~</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">~assets</td>
<td align="center">/assets</td>
</tr>
<tr>
<td align="center">~components</td>
<td align="center">/components</td>
</tr>
<tr>
<td align="center">~pages</td>
<td align="center">/pages</td>
</tr>
<tr>
<td align="center">~plugins</td>
<td align="center">/plugins</td>
</tr>
<tr>
<td align="center">~static</td>
<td align="center">/static</td>
</tr>
<tr>
<td align="center">~store</td>
<td align="center">/store</td>
</tr>
<tr>
<td align="center">## 文件别名：</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>|别名|    使用方法|    描述|<br>|:-:|:-:|<br>|<del>store|    const store = require(‘</del>store’)|    导入 vuex 状态树实例。|<br>|<del>router|    const router = require(‘</del>router’)    |导入 vue-router 实例。|</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><blockquote>
<p>Nuxt.js 默认的配置涵盖了大部分使用情形，可通过 nuxt.config.js 来覆盖默认的配置。</p>
</blockquote>
<h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><blockquote>
<p>Nuxt.js 允许你在自动生成的 vendor.bundle.js 文件中添加一些模块，以减少应用 bundle 的体积。如果你的应用依赖第三方模块，这个配置项是十分实用的。</p>
</blockquote>
<h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><blockquote>
<p>该配置项让你开启组件缓存策略以提升渲染性能。</p>
</blockquote>
<h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><blockquote>
<p>该配置项用于定义应用的全局（所有页面均需引用的）样式文件、模块或第三方库。</p>
</blockquote>
<h2 id="dev"><a href="#dev" class="headerlink" title="dev"></a>dev</h2><blockquote>
<p>该配置项用于配置 Nuxt.js 应用是开发还是生产模式。</p>
</blockquote>
<h2 id="env"><a href="#env" class="headerlink" title="env"></a>env</h2><blockquote>
<p>该配置项用于定义应用客户端和服务端的环境变量。</p>
</blockquote>
<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><blockquote>
<p>该配置项用于定义每个动态路由的参数，Nuxt.js 依据这些路由配置生成对应目录结构的静态文件。</p>
</blockquote>
<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><blockquote>
<p>该配置项用于配置应用默认的meta标签。</p>
</blockquote>
<h2 id="loading"><a href="#loading" class="headerlink" title="loading"></a>loading</h2><blockquote>
<p>该配置项用于个性化定制 Nuxt.js 使用的加载组件。</p>
</blockquote>
<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><blockquote>
<p>该配置项用于配置那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。</p>
</blockquote>
<h2 id="rootDir"><a href="#rootDir" class="headerlink" title="rootDir"></a>rootDir</h2><blockquote>
<p>该配置项用于配置 Nuxt.js 应用的根目录。</p>
</blockquote>
<h2 id="router"><a href="#router" class="headerlink" title="router"></a>router</h2><blockquote>
<p>该配置项可用于覆盖 Nuxt.js 默认的 vue-router 配置。</p>
</blockquote>
<h2 id="srcDir"><a href="#srcDir" class="headerlink" title="srcDir"></a>srcDir</h2><blockquote>
<p>该配置项用于配置应用的源码目录路径。</p>
</blockquote>
<h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><blockquote>
<p>该配置项用于个性化配置应用过渡效果属性的默认值。</p>
</blockquote>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>Nuxt.js 依据 pages 目录结构自动生成 vue-router 模块的路由配置。</p>
<h2 id="基础路由"><a href="#基础路由" class="headerlink" title="基础路由"></a>基础路由</h2><p>假设 pages 的目录结构如下：</p>
<pre><code>pages/
--| user/
-----| index.vue
-----| one.vue
--| index.vue</code></pre><p>那么，Nuxt.js 自动生成的路由配置如下：</p>
<pre><code>router: {
  routes: [
    {
      name: 'index',
      path: '/',
      component: 'pages/index.vue'
    },
    {
      name: 'user',
      path: '/user',
      component: 'pages/user/index.vue'
    },
    {
      name: 'user-one',
      path: '/user/one',
      component: 'pages/user/one.vue'
    }
  ]
}</code></pre><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>在 Nuxt.js 里面定义带参数的动态路由，需要创建对应的以下划线作为前缀的 Vue 文件 或 目录。</p>
<p>以下目录结构：</p>
<pre><code>pages/
--| _slug/
-----| comments.vue
-----| index.vue
--| users/
-----| _id.vue
--| index.vue</code></pre><p>Nuxt.js 生成对应的路由配置表为：</p>
<pre class=" language-js"><code class="language-js">router<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      name<span class="token punctuation">:</span> <span class="token string">'index'</span><span class="token punctuation">,</span>
      path<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
      component<span class="token punctuation">:</span> <span class="token string">'pages/index.vue'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      name<span class="token punctuation">:</span> <span class="token string">'users-id'</span><span class="token punctuation">,</span>
      path<span class="token punctuation">:</span> <span class="token string">'/users/:id?'</span><span class="token punctuation">,</span>
      component<span class="token punctuation">:</span> <span class="token string">'pages/users/_id.vue'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      name<span class="token punctuation">:</span> <span class="token string">'slug'</span><span class="token punctuation">,</span>
      path<span class="token punctuation">:</span> <span class="token string">'/:slug'</span><span class="token punctuation">,</span>
      component<span class="token punctuation">:</span> <span class="token string">'pages/_slug/index.vue'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      name<span class="token punctuation">:</span> <span class="token string">'slug-comments'</span><span class="token punctuation">,</span>
      path<span class="token punctuation">:</span> <span class="token string">'/:slug/comments'</span><span class="token punctuation">,</span>
      component<span class="token punctuation">:</span> <span class="token string">'pages/_slug/comments.vue'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre>
<p>你会发现名称为 users-id 的路由路径带有 :id? 参数，表示该路由是可选的。如果你想将它设置为必选的路由，需要在 users/_id 目录内创建一个 index.vue 文件。</p>
<h3 id="路由参数校验"><a href="#路由参数校验" class="headerlink" title="路由参数校验"></a>路由参数校验</h3><p>Nuxt.js 可以让你在动态路由组件中定义参数校验方法。</p>
<p>举个例子： pages/users/_id.vue</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  validate <span class="token punctuation">(</span><span class="token punctuation">{</span> params <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Must be a number</span>
    <span class="token keyword">return</span> <span class="token regex">/^\d+$/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>如果校验方法返回的值不为 true， Nuxt.js 将自动加载显示 404 错误页面。</p>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>你可以通过 vue-router 的子路由创建 Nuxt.js 应用的嵌套路由。</p>
<p>创建内嵌子路由，你需要添加一个 Vue 文件，同时添加一个与该文件同名的目录用来存放子视图组件。</p>
<p>别忘了在父级 Vue 文件内增加 <nuxt-child> 用于显示子视图内容。</nuxt-child></p>
<p>假设文件结构如：</p>
<pre><code>pages/
--| users/
-----| _id.vue
-----| index.vue
--| users.vue</code></pre><p>Nuxt.js 自动生成的路由配置如下：</p>
<pre class=" language-js"><code class="language-js">router<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      path<span class="token punctuation">:</span> <span class="token string">'/users'</span><span class="token punctuation">,</span>
      component<span class="token punctuation">:</span> <span class="token string">'pages/users.vue'</span><span class="token punctuation">,</span>
      children<span class="token punctuation">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
          path<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
          component<span class="token punctuation">:</span> <span class="token string">'pages/users/index.vue'</span><span class="token punctuation">,</span>
          name<span class="token punctuation">:</span> <span class="token string">'users'</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
          path<span class="token punctuation">:</span> <span class="token string">':id'</span><span class="token punctuation">,</span>
          component<span class="token punctuation">:</span> <span class="token string">'pages/users/_id.vue'</span><span class="token punctuation">,</span>
          name<span class="token punctuation">:</span> <span class="token string">'users-id'</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="动态嵌套路由"><a href="#动态嵌套路由" class="headerlink" title="动态嵌套路由"></a>动态嵌套路由</h2><p>这个应用场景比较少见，但是 Nuxt.js 仍然支持：在动态路由下配置动态子路由。</p>
<p>假设文件结构如下：</p>
<pre><code>pages/
--| _category/
-----| _subCategory/
--------| _id.vue
--------| index.vue
-----| _subCategory.vue
-----| index.vue
--| _category.vue
--| index.vue</code></pre><p>Nuxt.js 自动生成的路由配置如下：</p>
<pre class=" language-js"><code class="language-js">router<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  routes<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      path<span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
      component<span class="token punctuation">:</span> <span class="token string">'pages/index.vue'</span><span class="token punctuation">,</span>
      name<span class="token punctuation">:</span> <span class="token string">'index'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      path<span class="token punctuation">:</span> <span class="token string">'/:category'</span><span class="token punctuation">,</span>
      component<span class="token punctuation">:</span> <span class="token string">'pages/_category.vue'</span><span class="token punctuation">,</span>
      children<span class="token punctuation">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
          path<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
          component<span class="token punctuation">:</span> <span class="token string">'pages/_category/index.vue'</span><span class="token punctuation">,</span>
          name<span class="token punctuation">:</span> <span class="token string">'category'</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
          path<span class="token punctuation">:</span> <span class="token string">':subCategory'</span><span class="token punctuation">,</span>
          component<span class="token punctuation">:</span> <span class="token string">'pages/_category/_subCategory.vue'</span><span class="token punctuation">,</span>
          children<span class="token punctuation">:</span> <span class="token punctuation">[</span>
            <span class="token punctuation">{</span>
              path<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
              component<span class="token punctuation">:</span> <span class="token string">'pages/_category/_subCategory/index.vue'</span><span class="token punctuation">,</span>
              name<span class="token punctuation">:</span> <span class="token string">'category-subCategory'</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token punctuation">{</span>
              path<span class="token punctuation">:</span> <span class="token string">':id'</span><span class="token punctuation">,</span>
              component<span class="token punctuation">:</span> <span class="token string">'pages/_category/_subCategory/_id.vue'</span><span class="token punctuation">,</span>
              name<span class="token punctuation">:</span> <span class="token string">'category-subCategory-id'</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="过渡动效"><a href="#过渡动效" class="headerlink" title="过渡动效"></a>过渡动效</h2><p>Nuxt.js 使用 Vue.js 的<transition>组件来实现路由切换时的过渡动效。</transition></p>
<h3 id="全局过渡动效设置"><a href="#全局过渡动效设置" class="headerlink" title="全局过渡动效设置"></a>全局过渡动效设置</h3><p>Nuxt.js 默认使用的过渡效果名称为 page</p>
<p>如果想让每一个页面的切换都有淡出 (fade) 效果，我们需要创建一个所有路由共用的 CSS 文件。所以我们可以在 assets/ 目录下创建这个文件：</p>
<p>在全局样式文件 assets/main.css 里添加一下样式：</p>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.page-enter-active</span>, <span class="token class">.page-leave-active</span> </span><span class="token punctuation">{</span>
  <span class="token property">transition</span><span class="token punctuation">:</span> opacity <span class="token number">.5</span>s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.page-enter</span>, <span class="token class">.page-leave-active</span> </span><span class="token punctuation">{</span>
  <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>然后添加到 nuxt.config.js 文件中：</p>
<pre class=" language-js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  css<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token string">'assets/main.css'</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="页面过渡动效设置"><a href="#页面过渡动效设置" class="headerlink" title="页面过渡动效设置"></a>页面过渡动效设置</h3><p>如果想给某个页面自定义过渡特效的话，只要在该页面组件中配置 transition 字段即可：</p>
<p>在全局样式 assets/main.css 中添加一下内容：</p>
<pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.test-enter-active</span>, <span class="token class">.test-leave-active</span> </span><span class="token punctuation">{</span>
  <span class="token property">transition</span><span class="token punctuation">:</span> opacity <span class="token number">.5</span>s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector"><span class="token class">.test-enter</span>, <span class="token class">.test-leave-active</span> </span><span class="token punctuation">{</span>
  <span class="token property">opacity</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>然后我们将页面组件中的 transition 属性的值设置为 test 即可：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  transition<span class="token punctuation">:</span> <span class="token string">'test'</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前。</p>
<p>每一个中间件应放置在 middleware/ 目录。文件名的名称将成为中间件名称(middleware/auth.js将成为 auth 中间件)。</p>
<p>一个中间件接收 context 作为第一个参数：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  context<span class="token punctuation">.</span>userAgent <span class="token operator">=</span> context<span class="token punctuation">.</span>isServer <span class="token operator">?</span> context<span class="token punctuation">.</span>req<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'user-agent'</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> navigator<span class="token punctuation">.</span>userAgent
<span class="token punctuation">}</span></code></pre>
<p>中间件执行流程顺序：</p>
<ul>
<li>nuxt.config.js</li>
<li>匹配布局</li>
<li>匹配页面</li>
<li>中间件可以异步执行,只需要返回一个 Promise 或使用第2个 callback 作为第一个参数：</li>
</ul>
<pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> axios <span class="token keyword">from</span> <span class="token string">'axios'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> route <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'http://my-stats-api.com'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    url<span class="token punctuation">:</span> route<span class="token punctuation">.</span>fullPath
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>然后在你的 nuxt.config.js 、 layouts 或者 pages 中使用中间件:</p>
<pre class=" language-js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  router<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    middleware<span class="token punctuation">:</span> <span class="token string">'stats'</span>
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span></code></pre>
<p>stats 中间件将在每个路由改变时被调用。</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>本章节的内容阐述了如何在 Nuxt.js 应用中为指定的路由配置数据和视图，包括应用模板、页面、布局和HTML头部等内容。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>你可以定制化 Nuxt.js 默认的应用模板。</p>
<p>定制化默认的 html 模板，只需要在应用根目录下创建一个 app.html 的文件。</p>
<p>默认模板为：</p>
<pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">{{</span> <span class="token attr-name">HTML_ATTRS</span> <span class="token attr-name">}}</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    {{ HEAD }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">{{</span> <span class="token attr-name">BODY_ATTRS</span> <span class="token attr-name">}}</span><span class="token punctuation">></span></span>
    {{ APP }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<p>举个例子，你可以修改模板添加 IE 的条件表达式：</p>
<pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>
<span class="token comment" spellcheck="true">&lt;!--[if IE 9]>&lt;html lang="en-US" class="lt-ie9 ie9" {{ HTML_ATTRS }}>&lt;![endif]--></span>
<span class="token comment" spellcheck="true">&lt;!--[if (gt IE 9)|!(IE)]>&lt;!--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">{{</span> <span class="token attr-name">HTML_ATTRS</span> <span class="token attr-name">}}</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--&lt;![endif]--></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    {{ HEAD }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">{{</span> <span class="token attr-name">BODY_ATTRS</span> <span class="token attr-name">}}</span><span class="token punctuation">></span></span>
    {{ APP }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>Nuxt.js 允许你扩展默认的布局，或在 layout 目录下创建自定义的布局。</p>
<h3 id="默认布局"><a href="#默认布局" class="headerlink" title="默认布局"></a>默认布局</h3><p>可通过添加 layouts/default.vue 文件来扩展应用的默认布局。</p>
<p>别忘了在布局文件中添加 <nuxt> 组件用于显示页面的主体内容。</nuxt></p>
<p>默认布局的源码如下：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nuxt</span><span class="token punctuation">/></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span></code></pre>
<h3 id="错误页面"><a href="#错误页面" class="headerlink" title="错误页面"></a>错误页面</h3><p>你可以通过编辑 layouts/error.vue 文件来定制化错误页面.</p>
<p>这个布局文件不需要包含 <nuxt> 标签。你可以把这个布局文件当成是显示应用错误（404，500等）的组件。</nuxt></p>
<p>默认的错误页面源码在 这里.</p>
<p>举一个个性化错误页面的例子 layouts/error.vue:</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>error.statusCode <span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span> 404<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>页面不存在<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>应用发生错误异常<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nuxt-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>首 页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nuxt-link</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'error'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  layout<span class="token punctuation">:</span> <span class="token string">'blog'</span> <span class="token comment" spellcheck="true">// 你可以为错误页面指定自定义的布局</span>
<span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre>
<h3 id="个性化布局"><a href="#个性化布局" class="headerlink" title="个性化布局"></a>个性化布局</h3><p>layouts 根目录下的所有文件都属于个性化布局文件，可以在页面组件中利用 layout 属性来引用。</p>
<p>请确保在布局文件里面增加 <code>&lt;nuxt/&gt;</code> 组件用于显示页面非布局内容。</p>
<p>举个例子 layouts/blog.vue:</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>这里是博客导航<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nuxt</span><span class="token punctuation">/></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span></code></pre>
<p>在 pages/posts.vue 里， 可以指定页面组件使用 blog 布局。</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  layout<span class="token punctuation">:</span> <span class="token string">'blog'</span>
<span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre>
<h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><p>页面组件实际上是 Vue 组件，只不过 Nuxt.js 为这些组件添加了一些特殊的配置项（对应 Nuxt.js 提供的功能特性）以便你能快速开发通用应用。</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello {{ name }}!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  asyncData <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// called every time before loading the component</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'World'</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  fetch <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// The fetch method is used to fill the store before rendering the page</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  head <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Set Meta Tags for this Page</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment" spellcheck="true">// and more functionality to discover</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">
<span class="token selector"><span class="token class">.red</span> </span><span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre>
<p>Nuxt.js 为页面提供的特殊配置项：</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">asyncData</td>
<td align="center">最重要的一个键, 支持 异步数据处理，另外该方法的第一个参数为当前页面组件的 上下文对象。</td>
</tr>
<tr>
<td align="center">fetch</td>
<td align="center">与 asyncData 方法类似，用于在渲染页面之前获取数据填充应用的状态树（store）。不同的是 fetch 方法不会设置组件的数据。</td>
</tr>
<tr>
<td align="center">head</td>
<td align="center">配置当前页面的 Meta 标签, 详情参考 页面头部配置API。</td>
</tr>
<tr>
<td align="center">layout</td>
<td align="center">指定当前页面使用的布局（layouts 根目录下的布局文件）。</td>
</tr>
<tr>
<td align="center">transition</td>
<td align="center">指定页面切换的过渡动效, 详情请参考 页面过渡动效。</td>
</tr>
<tr>
<td align="center">scrollToTop</td>
<td align="center">布尔值，默认: false。 用于判定渲染页面前是否需要将当前页面滚动至顶部。这个配置用于 嵌套路由的应用场景。</td>
</tr>
<tr>
<td align="center">validate</td>
<td align="center">校验方法用于校验 动态路由的参数。</td>
</tr>
<tr>
<td align="center">middleware</td>
<td align="center">指定页面的中间件，中间件会在页面渲染之前被调用</td>
</tr>
</tbody></table>
<h2 id="HTML-头部"><a href="#HTML-头部" class="headerlink" title="HTML 头部"></a>HTML 头部</h2><p>Nuxt.js 使用了 vue-meta 更新应用的 头部标签(Head) and html 属性。</p>
<p>Nuxt.js 使用以下参数配置 vue-meta:</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
  keyName<span class="token operator">:</span> 'head'<span class="token punctuation">,</span> // 设置 meta 信息的组件对象的字段，vue-meta 会根据这 key 值获取 meta 信息
  attribute<span class="token operator">:</span> 'n-head'<span class="token punctuation">,</span> // vue-meta 在监听标签时所添加的属性名
  ssrAttribute<span class="token operator">:</span> 'n-head-ssr'<span class="token punctuation">,</span> // 让 vue-meta 获知 meta 信息已完成服务端渲染的属性名
  tagIDKeyName<span class="token operator">:</span> 'hid' // 让 vue-meta 用来决定是否覆盖还是追加 tag 的属性名
<span class="token punctuation">}</span></code></pre>
<h3 id="默认-Meta-标签"><a href="#默认-Meta-标签" class="headerlink" title="默认 Meta 标签"></a>默认 Meta 标签</h3><p>Nuxt.js 允许你在 nuxt.config.js 里定义应用所需的所有默认 meta 标签，在 head 字段里配置就可以了：</p>
<p>一个使用自定义 viewport 和 谷歌字体 的配置示例：</p>
<pre class=" language-json"><code class="language-json">head<span class="token operator">:</span> <span class="token punctuation">{</span>
  meta<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> charset<span class="token operator">:</span> 'utf<span class="token number">-8</span>' <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> name<span class="token operator">:</span> 'viewport'<span class="token punctuation">,</span> content<span class="token operator">:</span> 'width=device-width<span class="token punctuation">,</span> initial-scale=<span class="token number">1</span>' <span class="token punctuation">}</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  link<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> rel<span class="token operator">:</span> 'stylesheet'<span class="token punctuation">,</span> href<span class="token operator">:</span> 'https<span class="token operator">:</span>//fonts.googleapis.com/css?family=Roboto' <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="个性化特定页面的-Meta-标签"><a href="#个性化特定页面的-Meta-标签" class="headerlink" title="个性化特定页面的 Meta 标签"></a>个性化特定页面的 Meta 标签</h3><blockquote>
<p>注意：为了避免子组件中的meta标签不能正确覆盖父组件中相同的标签而产生重复的现象，建议利用 hid 键为meta标签配一个唯一的标识编号。请阅读关于 vue-meta 的更多信息。</p>
</blockquote>
<h1 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h1><h2 id="资源文件-1"><a href="#资源文件-1" class="headerlink" title="资源文件"></a>资源文件</h2><p>默认情况下 <code>Nuxt</code> 使用 <code>vue-loader</code>、<code>file-loader</code> 以及 <code>url-loader</code> 这几个 <code>Webpack</code> 加载器来处理文件的加载和引用。对于不需要通过 <code>Webpack</code> 处理的静态资源文件，可以放置在 <code>static</code> 目录中。</p>
<h2 id="Webpack-构建"><a href="#Webpack-构建" class="headerlink" title="Webpack 构建"></a>Webpack 构建</h2><p>默认情况下, vue-loader自动使用 <code>css-loader</code> 和Vue模板编译器来编译处理vue文件中的样式和模板。在此编译过程中，所有的资源URL例如 <code>&lt;img src="..."&gt;</code>、 <code>background: url(...)</code> 和 CSS中的 <code>@import</code> 均会被解析成模块通过 <code>require</code> 引用。</p>
<p>举个例子, 假设我们有以下文件目录结构：</p>
<pre><code>-| assets/
----| image.png
-| pages/
----| index.vue</code></pre><p>如果我们在CSS代码中使用 <code>url('~assets/image.png')</code>, 那么编译后它将被转换成 <code>require('~assets/image.png')</code>。</p>
<p>又或者如果我们在 <code>pages/index.vue</code> 中使用以下代码引用图片资源：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>~assets/image.png<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span></code></pre>
<p>那么编译后会被转换成：</p>
<pre class=" language-js"><code class="language-js"><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> attrs<span class="token punctuation">:</span> <span class="token punctuation">{</span> src<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'~assets/image.png'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p><code>.png</code> 并非 <code>JavaScript</code> 文件, 因此 <code>Nuxt.js</code> 通过配置<code>Webpack</code>使用<code>file-loader</code> 和 <code>url-loader</code> 这两个加载器来处理此类引用。</p>
<p>这样做的好处有：</p>
<p><code>file-loader</code> 能让你指定从什么地方拷贝资源文件以及发布后放到哪个目录去，并能让你使用版本哈希码来重命名发布后的文件来实现增量更新和更好的缓存策略。<br><code>url-loader</code> 能根据你指定的文件大小阈值，来判断一个文件是转换成内联的base-64码（如果该文件尺寸小于该阈值）还是使用file-loader来降级处理。小文件base-64化能有效减少HTTP请求数。<br>实际上, Nuxt.js 默认的加载器配置如下：</p>
<pre class=" language-js"><code class="language-js"><span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    test<span class="token punctuation">:</span> <span class="token regex">/\.(png|jpe?g|gif|svg)$/</span><span class="token punctuation">,</span>
    loader<span class="token punctuation">:</span> <span class="token string">'url-loader'</span><span class="token punctuation">,</span>
    query<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      limit<span class="token punctuation">:</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 1KB</span>
      name<span class="token punctuation">:</span> <span class="token string">'img/[name].[hash:7].[ext]'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    test<span class="token punctuation">:</span> <span class="token regex">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span><span class="token punctuation">,</span>
    loader<span class="token punctuation">:</span> <span class="token string">'url-loader'</span><span class="token punctuation">,</span>
    query<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      limit<span class="token punctuation">:</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 1 KB</span>
      name<span class="token punctuation">:</span> <span class="token string">'fonts/[name].[hash:7].[ext]'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span></code></pre>
<p>也即文件（图片或字体）的尺寸小于1K的时候，它将会被转换成 Base-64 data URL 来内联引用；否则它将被拷贝至指定的子目录（在 .nuxt 目录下），并被重命名（加上7位的哈希码作为版本标识）以实现更好的缓存策略。</p>
<p>当用 nuxt 命令运行我们的应用时，pages/index.vue 中的模板代码：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>~assets/image.png<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span></code></pre>
<p>将被编译生成：</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/_nuxt/img/image.0c61159.png<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre>
<h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><p>如果你的静态资源文件需要 Webpack 做构建编译处理，可以放到 <code>assets</code> 目录，否则可以放到 <code>static</code> 目录中去。</p>
<p>Nuxt 服务器启动的时候，该目录下的文件会映射至应用的根路径 <code>/</code> 下，像 <code>robots.txt</code> 或 <code>sitemap.xml</code> 这种类型的文件就很适合放到 <code>static</code> 目录中。</p>
<p>你可以在代码中使用根路径 <code>/</code> 结合资源相对路径来引用静态资源：</p>
<pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 引用 static 目录下的图片 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/my-image.png<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>

<span class="token comment" spellcheck="true">&lt;!-- 引用 assets 目录下经过 webpack 构建处理后的图片 --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/assets/my-image-2.png<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre>
<p>为完待续—-</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Vue</tag>
        <tag>SSR</tag>
        <tag>nuxtjs</tag>
      </tags>
  </entry>
  <entry>
    <title>针对云和微服务平台的 Java 企业安全性</title>
    <url>/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%201%20%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>Java EE 8 Security API 入门，第 1 部分</p>
<blockquote>
<p><strong>关于本系列</strong></p>
<p>期盼已久的新 Java EE Security API (JSR 375) 推动 Java 企业安全性进入了云和微服务计算时代。本系列将展示新安全机制如何简化和标准化各种 Java EE 容器实现之间的安全处理，然后帮助您开始在受云支持的项目中使用它们。</p>
</blockquote>
<blockquote>
<p>此内容是该系列 4 部分中的第 1 部分： Java EE 8 Security API 入门</p>
<ul>
<li><a href="/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%201%20%E9%83%A8%E5%88%86/">第 1 部分: 针对云和微服务平台的 Java 企业安全性</a></li>
<li><a href="/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%202%20%E9%83%A8%E5%88%86/">第 2 部分: 通过 HttpAuthenticationMechanism 执行 Web 身份验证</a></li>
<li><a href="/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%203%20%E9%83%A8%E5%88%86/">第 3 部分: 通过 IdentityStore 安全地访问用户凭证</a></li>
<li><a href="http://localhost:4000/2019/02/06/Java/javaEE/Java%20EE%208%20Security%20API%20%E5%85%A5%E9%97%A8%EF%BC%8C%E7%AC%AC%204%20%E9%83%A8%E5%88%86/" target="_blank" rel="noopener">第 4 部分: 通过 SecurityContext 询问调用方数据</a></li>
</ul>
</blockquote>
<p>经验丰富的 Java™ 开发人员都知道，Java 从不缺乏 Java 安全机制。各种安全机制选项包括 <a href="https://jcp.org/aboutJava/communityprocess/mrel/jsr115/index3.html" target="_blank" rel="noopener">Java Authorization for Container Contracts 规范</a> (JACC)、<a href="https://jcp.org/aboutJava/communityprocess/mrel/jsr196/index2.html" target="_blank" rel="noopener">Java Authentication Service Provider Interface for Containers</a> (JASPIC)，以及大量特定于第三方容器的安全 API 和配置管理解决方案。</p>
<p>我们面对的麻烦不是缺少选项，而是缺少一种企业标准。没有标准，就无法激励供应商一致地实现身份验证等核心特性，并针对上下文和依赖注入 (CDI) 及 Expression Language (EL) 等新技术来升级专用解决方案，或者时刻跟上云和微服务架构的安全发展趋势。</p>
<p>本系列将介绍新的 Java EE Security API，首先将概述该 API 及其 3 个主要接口：HttpAuthenticationMechanism、IdentityStore 和 SecurityContext。</p>
<p><a href="https://github.com/readlearncode/Java-EE-8-Sampler/tree/master/security-1-0" target="_blank" rel="noopener">获取代码</a></p>
<h1 id="一个针对-Java-EE-安全性的新标准"><a href="#一个针对-Java-EE-安全性的新标准" class="headerlink" title="一个针对 Java EE 安全性的新标准"></a>一个针对 Java EE 安全性的新标准</h1><p>开发 Java EE 安全规范的运动源自 2014 年 Java EE 8 调查中的社区反馈。简化和标准化 Java 企业安全是许多调查对象的优先选项。JSR 375 专家小组在组建之后确定了以下问题：</p>
<ul>
<li>组成 Java EE 的各种 EJB 和 servlet 容器定义了类似的安全相关 API，但采用了稍微不同的语法。例如，一个检查用户角色的 servlet 会调用 HttpServletRequest.isUserInRole(String role)，而一个 EJB 会调用 EJBContext.isCallerInRole(String roleName)。</li>
<li>诸如 JACC 之类的现有安全机制很难实现，而且 JASPIC 可能很难正确使用。</li>
<li>现有机制没有充分利用现代 Java EE 编程的特性，比如上下文和依赖注入 (CDI)。</li>
<li>没有一种可在容器间移植的方式来控制如何在后端执行身份验证。</li>
<li>对于身份存储的管理或角色和权限的配置，没有标准的支持。</li>
<li>对于自定义身份验证规则的部署，也没有标准的支持。</li>
</ul>
<p>这些是 JSR 375 打算解决的主要问题。同时，该规范通过定义可移植的 API 在容器之间执行身份验证、身份存储、角色和权限及授权，希望使开发人员能够自行管理和控制安全性。</p>
<p>Java EE Security API 的美妙之处在于，它提供了一种配置身份存储和身份验证机制的备选方法，但没有取代现有安全机制。Java EE Security API 使开发人员能够以一致、可移植的方式在 Java EE Web 应用程序中启用安全性 — 无论是否使用特定于供应商的或专用的解决方案。</p>
<h1 id="Java-EE-Security-API-中包含的特性"><a href="#Java-EE-Security-API-中包含的特性" class="headerlink" title="Java EE Security API 中包含的特性"></a>Java EE Security API 中包含的特性</h1><p>Java EE Security API V1.0 包含原始建议草案的一个子集，专注于与云原生应用程序相关的技术。这些特性包括：</p>
<ul>
<li>一个用于身份验证的 API</li>
<li>一个身份存储 API</li>
<li>一个安全上下文 API</li>
</ul>
<p>这些特性通过新的标准化术语一起引入到所有 Java EE 安全实现中。Java EE Security 规范的下一个版本中即将包含的剩余特性包括：</p>
<ul>
<li>一个密码混淆 API</li>
<li>一个角色/权限分配 API</li>
<li>一个授权拦截器 API</li>
</ul>
<h1 id="安全的-Web-身份验证"><a href="#安全的-Web-身份验证" class="headerlink" title="安全的 Web 身份验证"></a>安全的 Web 身份验证</h1><p>Java EE 平台已为 Web 应用程序用户的身份验证指定了两种机制：<a href="https://jcp.org/en/jsr/detail?id=369" target="_blank" rel="noopener">Servlet 4.0</a> (JSR 369) 提供了一种声明性机制，适合一般应用程序配置。为了满足执行更可靠身份验证的需求，<a href="https://jcp.org/aboutJava/communityprocess/mrel/jsr196/index2.html" target="_blank" rel="noopener">JASPIC</a> 定义了一个名为 ServerAuthModule 的服务提供程序接口，该接口支持开发身份验证模块来处理任何凭证类型。此外，<a href="https://docs.oracle.com/cd/E19226-01/820-7695/gizel/index.html" target="_blank" rel="noopener">Servlet Container Profile</a> 指定了 JASPIC 应如何与 servlet 容器相集成。</p>
<p>这两种机制都很有意义很有效，但对 Web 应用程序开发人员而言，每种机制都有其局限性。</p>
<p>servlet 容器机制被限定为仅支持 Servlet 4.0 定义的小范围的凭证类型，而且它无法支持与调用方的复杂交互。它也无法让应用程序确定调用方是否已针对预期身份存储进行了身份验证。</p>
<p>相反，JASPIC 非常强大，可塑性很强，但使用起来也非常复杂。对 AuthModule 进行编码并针对 Web 容器来调整它，以便将它用于身份验证，这可能很复杂。除此之外，JASPIC 没有声明性配置，没有明确的方法来覆盖通过编程方式注册的 AuthModule。</p>
<p>Java EE Security API 通过新接口 HttpAuthenticationMechanism 解决了这些问题中的一部分。这个新接口实际上是 JASPIC ServerAuthModule 接口的一个简化的 servlet 容器变体，它在减少现有机制的局限性的同时充分利用了现有机制。</p>
<p>HttpAuthenticationMechanism 实例是一个 CDI bean，由容器负责使其可用于注入。应用程序或 servlet 容器可以提供 HttpAuthenticationMechanism 接口的更多实现。请注意，HttpAuthenticationMechanism 仅指定用于 servlet 容器。</p>
<h1 id="对-Servlet-4-0-身份验证的支持"><a href="#对-Servlet-4-0-身份验证的支持" class="headerlink" title="对 Servlet 4.0 身份验证的支持"></a>对 Servlet 4.0 身份验证的支持</h1><p>一个 Java EE 容器必须为 Servlet 4.0 规范中定义的 3 种身份验证机制提供 HttpAuthenticationMechanism 实现。这 3 种实现是：</p>
<ul>
<li>基本 HTTP 身份验证（13.6.1 小节）</li>
<li>基于表单的身份验证（13.6.3 小节）</li>
<li>自定义表单身份验证（13.6.3.1 小节）</li>
</ul>
<p>每种实现都由与其相关的注解的存在而触发：</p>
<ul>
<li>@BasicAuthenticationMechanismDefinition</li>
<li>@FormAuthenticationMechanismDefinition</li>
<li>@CustomFormAuthenticationMechanismDefinition</li>
</ul>
<p>遇到其中一个注解时，容器会实例化关联机制的一个实例并立即提供该实例。</p>
<p>在新规范中，不再需要在 web.xml 文件中的 <code>&lt;login-config&gt;</code> 元素之间指定身份验证机制，而 Servlet 4.0 需要这么做。实际上，如果存在这些 web.xml 配置，同时还存在一个基于 HttpAuthenticationMechanism 的注解，部署流程可能会失败，或者至少会忽略这些配置。</p>
<p>让我们看看可以如何使用每种机制的一些示例。</p>
<h2 id="基本-HTTP-身份验证"><a href="#基本-HTTP-身份验证" class="headerlink" title="基本 HTTP 身份验证"></a>基本 HTTP 身份验证</h2><p>@BasicAuthenticationMechanismDefinition 注解触发 Servlet 4.0 所定义的基本 HTTP 身份验证。清单 1 给出了一个示例。唯一的配置参数是可选的，而且允许指定一个范围。</p>
<blockquote>
<p><strong>范围是什么？</strong></p>
<p>一种服务器资源可划分为不同的受保护空间。在本例中，每个空间都有自己的身份验证模式和授权数据库，并包含由相同策略控制的用户和组。这个由用户和组构成的数据库就称为一个范围。</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@BasicAuthenticationMechanismDefinition</span><span class="token punctuation">(</span>realmName<span class="token operator">=</span><span class="token string">"${'user-realm'}"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@DeclareRoles</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"admin"</span><span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"demo"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@ServletSecurity</span><span class="token punctuation">(</span><span class="token annotation punctuation">@HttpConstraint</span><span class="token punctuation">(</span>rolesAllowed <span class="token operator">=</span> <span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span> … <span class="token punctuation">}</span></code></pre>
<h2 id="基于表单的身份验证"><a href="#基于表单的身份验证" class="headerlink" title="基于表单的身份验证"></a>基于表单的身份验证</h2><p>@FormAuthenticationMechanismDefinition 注解用于基于表单的身份验证。它有一个必要参数 loginToContinue，该参数用于配置 Web 应用程序的登录页、错误页，以及重定向或转发特征。在清单 2 中，可以看到登录页使用了一个 URI 定义，useForwardToLoginExpression 是使用一个 Expression Language (EL) 表达式来配置的。不需要向 @LoginToContinue 注解传递任何参数，因为该实现已提供了合理的默认参数。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FormAuthenticationMechanismDefinition</span><span class="token punctuation">(</span>
   loginToContinue <span class="token operator">=</span> <span class="token annotation punctuation">@LoginToContinue</span><span class="token punctuation">(</span>
       loginPage<span class="token operator">=</span><span class="token string">"/login-servlet"</span><span class="token punctuation">,</span>
       errorPage<span class="token operator">=</span><span class="token string">"/error"</span><span class="token punctuation">,</span>
       useForwardToLoginExpression<span class="token operator">=</span><span class="token string">"${appConfig.forward}"</span>
   <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token annotation punctuation">@ApplicationScoped</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationConfig</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre>
<h2 id="自定义表单身份验证"><a href="#自定义表单身份验证" class="headerlink" title="自定义表单身份验证"></a>自定义表单身份验证</h2><p>@CustomFormAuthenticationMechanismDefinition 注解触发内置的自定义表单身份验证。清单 3 给出了一个示例。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@CustomFormAuthenticationMechanismDefinition</span><span class="token punctuation">(</span>
   loginToContinue <span class="token operator">=</span> <span class="token annotation punctuation">@LoginToContinue</span><span class="token punctuation">(</span>
       loginPage<span class="token operator">=</span><span class="token string">"/login.do"</span>
   <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">"/admin"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@DeclareRoles</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"admin"</span><span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"demo"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@ServletSecurity</span><span class="token punctuation">(</span><span class="token annotation punctuation">@HttpConstraint</span><span class="token punctuation">(</span>rolesAllowed <span class="token operator">=</span> <span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdminServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre>
<p>自定义表单身份验证旨在与 JavaServer Pages (JSF) 和相关的 Java EE 技术更加一致。login.do 页被呈现出来，然后通过登录页的支持性 bean 输入并处理用户名和密码。</p>
<h1 id="IdentityStore-API"><a href="#IdentityStore-API" class="headerlink" title="IdentityStore API"></a>IdentityStore API</h1><p><em>身份存储</em>是一个数据库，用于存储用户身份数据，比如用户名、组成员关系，以及用于验证凭证的信息。Java EE Security API 提供了一个名为 IdentityStore 的身份存储抽象。类似于 JAAS LoginModule 接口，IdentityStore 用于与身份存储交互，以便验证用户和检索组成员关系。</p>
<p>正如规范中所写，IdentityStore 的意图是供 HttpAuthenticationMechanism 实现使用，但这不是必须的。IdentityStore 可以独立存在，并被其他任何身份验证机制使用。但是，通过结合使用 IdentityStore 和 HttpAuthenticationMechanism，应用程序能以一种便携的标准方式来控制其用于身份验证的身份存储，建议将此方式用于大多数用例场景。</p>
<p>IdentityStore API 包含一个 IdentityStoreHandler 接口，HttpAuthenticationMechanism 必须委托给该接口才能验证用户凭证。然后，IdentityStoreHandler 调用 IdentityStore 实例。Identity 存储实现不会被直接使用，而是通过专用处理函数来交互。</p>
<p>IdentityStoreHandler 可以针对多个 IdentityStore 来执行身份验证，并以 CredentialValidationResult 实例的形式返回一个聚合结果。这个对象可以做的事情只是传递证书是否有效，或者它可能是一个包含以下任何信息的丰富对象：</p>
<ul>
<li><a href="https://javaee.github.io/security-api/apidocs/javax/security/enterprise/CallerPrincipal.html" target="_blank" rel="noopener">CallerPrincipal</a></li>
<li>主体所属的组的集合</li>
<li>调用方的名称或 LDAP 可识别的名称</li>
<li>来自身份存储的调用方唯一标识符</li>
</ul>
<p>按每个 IdentityStore 实现的优先级确定的顺序来查询身份存储。存储列表被解析了两次：第一次用于身份验证，然后用于授权。</p>
<p>作为开发人员，您可以通过实现 IdentityStore 接口来实现自己的轻量型身份存储，也可以使用用于 LDAP 和 RDBMS 的内置 IdentityStore 之一来实现。这些 IdentityStore 通过向合适的注解（@LdapIdentityStoreDefinition 或 @DataBaseIdentityStoreDefinition）传递配置细节来实现初始化。</p>
<h2 id="配置内置-IdentityStore"><a href="#配置内置-IdentityStore" class="headerlink" title="配置内置 IdentityStore"></a>配置内置 IdentityStore</h2><p>最简单的身份存储是数据库存储。它通过 @DataBaseIdentityStoreDefinition 注解来配置，如清单 4 所示。两个内置的数据库注解基于 Java EE 7 中已提供的 <a href="https://docs.oracle.com/javaee/7/api/javax/annotation/sql/DataSourceDefinition.html" target="_blank" rel="noopener">@DataStoreDefinition</a> 注解。</p>
<p>如下代码展示了如何配置一个数据库身份存储。这些配置选项是一目了然的，如果您配置过数据库定义，应该很熟悉它们。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@DatabaseIdentityStoreDefinition</span><span class="token punctuation">(</span>
   dataSourceLookup <span class="token operator">=</span> <span class="token string">"${'java:global/permissions_db'}"</span><span class="token punctuation">,</span>
   callerQuery <span class="token operator">=</span> <span class="token string">"#{'select password from caller where name = ?'}"</span><span class="token punctuation">,</span>
   groupsQuery <span class="token operator">=</span> <span class="token string">"select group_name from caller_groups where caller_name = ?"</span><span class="token punctuation">,</span>
   hashAlgorithm <span class="token operator">=</span> PasswordHash<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>
   priority <span class="token operator">=</span> <span class="token number">10</span>
<span class="token punctuation">)</span>
<span class="token annotation punctuation">@ApplicationScoped</span>
<span class="token annotation punctuation">@Named</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationConfig</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre>
<p>请注意，以上代码中将优先级设置为 10。此设置在找到多个身份存储时使用，用于确定相对于其他存储的迭代顺序。数字越小，优先级越高。</p>
<p>LDAP 配置很简单，如下代码所示。如果您拥有使用 LDAP 配置语义的经验，将会发现这里的选项很熟悉。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@LdapIdentityStoreDefinition</span><span class="token punctuation">(</span>
   url <span class="token operator">=</span> <span class="token string">"ldap://localhost:33389/"</span><span class="token punctuation">,</span>
   callerBaseDn <span class="token operator">=</span> <span class="token string">"ou=caller,dc=jsr375,dc=net"</span><span class="token punctuation">,</span>
   groupSearchBase <span class="token operator">=</span> <span class="token string">"ou=group,dc=jsr375,dc=net"</span>
<span class="token punctuation">)</span>
<span class="token annotation punctuation">@DeclareRoles</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"admin"</span><span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"demo"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">"/admin"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdminServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre>
<h2 id="自定义-IdentityStore"><a href="#自定义-IdentityStore" class="headerlink" title="自定义 IdentityStore"></a>自定义 IdentityStore</h2><p>设计您自己的轻量型身份存储非常简单。您需要实现 IdentityStore 接口，而且至少需要 validate() 方法。该接口上有 4 个方法，所有方法都具有默认的方法实现。有效的身份存储至少需要 validate() 方法。该方法接受一个 Credential 实例并返回一个 CredentialValidationResults 实例。</p>
<p>在如下代码中，validate() 方法接收一个包含要验证的登录凭证的 UsernamePasswordCredential 实例。然后，它返回一个 CredentialValidationResults 实例。如果简单的配置逻辑得到了成功的身份验证，则会为此对象配置用户名和用户所属的组集合。如果身份验证失败，那么 CredentialValidationResults 实例将会仅包含状态标志 INVALID。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ApplicationScoped</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LiteWeightIdentityStore</span> <span class="token keyword">implements</span> <span class="token class-name">IdentityStore</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span> CredentialValidationResult <span class="token function">validate</span><span class="token punctuation">(</span>UsernamePasswordCredential userCredential<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>userCredential<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span> <span class="token string">"pwd1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CredentialValidationResult</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span> 
               <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> INVALID_RESULT<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>请注意，该实现由 @ApplicationScope 注解。 这是必需的，因为 IdentityStoreHandler 包含对 CDI 容器所管理的所有 IdentityStore bean 实例的引用。@ApplicationScope 注解可以确保该实例是一个 CDI 管理的 bean，可用于整个应用程序。</p>
<p>要使用您的轻量型身份存储，可以将 IdentityStoreHandler 注入到一个自定义 HttpAuthenticationMechanism 中，如下代码所示。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ApplicationScoped</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LiteAuthenticationMechanism</span> <span class="token keyword">implements</span> <span class="token class-name">HttpAuthenticationMechanism</span> <span class="token punctuation">{</span>
   <span class="token annotation punctuation">@Inject</span>
   <span class="token keyword">private</span> IdentityStoreHandler idStoreHandler<span class="token punctuation">;</span>
   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> AuthenticationStatus <span class="token function">validateRequest</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">,</span> 
                                               HttpServletResponse res<span class="token punctuation">,</span> 
                                               HttpMessageContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       CredentialValidationResult result <span class="token operator">=</span> idStoreHandler<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span>
               <span class="token keyword">new</span> <span class="token class-name">UsernamePasswordCredential</span><span class="token punctuation">(</span>
                       req<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> req<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> VALID<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">return</span> context<span class="token punctuation">.</span><span class="token function">notifyContainerAboutLogin</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
           <span class="token keyword">return</span> context<span class="token punctuation">.</span><span class="token function">responseUnauthorized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h1 id="SecurityContext-API"><a href="#SecurityContext-API" class="headerlink" title="SecurityContext API"></a>SecurityContext API</h1><p>IdentityStore 和 HttpAuthenticationMechanism 相结合，提供了非常强大的用户身份验证和授权功能，但声明性模型本身并不够。编程性安全使 Web 应用程序能执行必要的检查，以授权或拒绝对应用程序资源的访问，SecurityContext API 提供了这一功能。</p>
<p>目前，Java EE 容器采用了不一致的方式来实现安全上下文对象。例如，servlet 容器提供一个 HttpServletRequest 实例，可以在该实例上调用 getUserPrincipal() 方法来获取表示用户身份的 UserPrincipal。然后，EJB 容器提供一个具有不同名称的 EJBContext 实例，在该实例上调用同名的方法。类似地，如果您想测试用户是否属于某个角色，必须在 HttpServletRequest 实例上调用 isUserRole() 方法，然后在 EJBContext 实例上调用 isCallerInRole()。</p>
<blockquote>
<p><strong>安全上下文是什么？</strong></p>
<p>在 Java 企业应用程序中，安全上下文提供与当前验证的用户有关联的安全相关信息的访问能力。SecurityContext API 的目的是在所有 servlet 和 EJB 容器中实现对应用程序的安全上下文的一致访问。</p>
</blockquote>
<p>新 SecurityContext 在所有 Java EE 容器中提供了一种获取身份验证和授权信息的一致机制。新 Java EE Security 规范要求至少在 servlet 和 EJB 容器中提供 SecurityContext。服务器供应商也可以在其他容器中提供它。</p>
<h2 id="SecurityContext-接口的方法"><a href="#SecurityContext-接口的方法" class="headerlink" title="SecurityContext 接口的方法"></a>SecurityContext 接口的方法</h2><p>SecurityContext 接口为编程性安全提供了一个入口点，而且是一种可注入的类型。它有 5 个方法，所有方法都没有默认实现。下面列出了这些方法和它们的用途：</p>
<ul>
<li><code>Principal getCallerPrincipal()</code>; 返回表示当前验证的用户名的特定于平台的主体，或者，如果当前调用方未经验证，则返回 null。</li>
<li><code>&lt;T extends Principal&gt; Set&lt;T&gt; getPrincipalsByType(Class&lt;T&gt; pType)</code>; 返回来自经过验证的调用方的主题中所有给定类型的主体；如果既未找到 pType 类型，当前用户也未经验证，则返回一个空集合。</li>
<li><code>boolean isCallerInRole(String role)</code>; 确定调用方是否包含在指定的角色中；如果用户未经授权，则返回 false。</li>
<li><code>boolean hasAccessToWebResource(String resource, String... methods)</code>; 确定调用方是否有权通过所提供的方法访问给定 Web 资源。</li>
<li><code>AuthenticationStatus authenticate(HttpServletRequest req, HttpServletResponse res, AuthenticationParameters param)</code>;：告知容器，它应该开始或继续执行与调用方的基于 HTTP 的身份验证对话。由于依赖于 HttpServletRequest 和 HttpServletResponse 实例，此方法仅适用于 servlet 容器。\</li>
</ul>
<p>最后，我们将快速查看如何使用这些方法之一来检查用户对 Web 资源的访问。</p>
<h1 id="使用-SecurityContext：一个示例"><a href="#使用-SecurityContext：一个示例" class="headerlink" title="使用 SecurityContext：一个示例"></a>使用 SecurityContext：一个示例</h1><p>如下代码展示了如何使用 hasAccessToWebResource() 方法来测试调用方使用指定的 HTTP 方法对给定 Web 资源的访问。在本例中，SecurityContext 实例被注入到 servlet 中，并用在 doGet() 方法中，后一个方法中测试了调用方对位于 URI /secretServlet 的 servlet 的 GET 方法的访问。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@DeclareRoles</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"admin"</span><span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"demo"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">"/hasAccessServlet"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HasAccessServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>

   <span class="token annotation punctuation">@Inject</span>
   <span class="token keyword">private</span> SecurityContext securityContext<span class="token punctuation">;</span>
   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">,</span> HttpServletResponse res<span class="token punctuation">)</span> 
            <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>
       <span class="token keyword">boolean</span> hasAccess <span class="token operator">=</span> securityContext<span class="token punctuation">.</span><span class="token function">hasAccessToWebResource</span><span class="token punctuation">(</span><span class="token string">"/secretServlet"</span><span class="token punctuation">,</span> <span class="token string">"GET"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>hasAccess<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           req<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span><span class="token string">"/secretServlet"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
           req<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span><span class="token string">"/logout"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h1 id="第-1-部分小结"><a href="#第-1-部分小结" class="headerlink" title="第 1 部分小结"></a>第 1 部分小结</h1><p>新 Java EE Security API 成功地结合使用了现有身份验证和授权机制的强大功能，以及开发人员期望从现代 Java EE 特性和技术获得的轻松开发能力。</p>
<p>尽管此 API 的原动力源自对以一致、可移植方式来解决安全相关问题的需求，但许多改进即将推出。在未来的版本中，JSR 375 专家小组打算集成 API 来实现密码混淆、角色和权限分类，以及授权拦截 — 规范的 v1.0 中未包含的所有特性。</p>
<p>专家小组还希望集成密钥管理和加密等特性，这些特性对于云原生和微服务应用程序中的常见用例至关重要。2016 年的 <a href="https://blogs.oracle.com/theaquarium/java-ee-8-community-survey-results-and-next-steps" target="_blank" rel="noopener">Java EE 社区调查</a>还表明，在希望包含在 Java EE 8 中的特性中，OAuth2 和 OpenID 的重要性排第三。尽管由于时间限制，v1.0 中无法包含这些特性，但在即将推出的版本中，将会提供包含这些特性的充分理由和动机。</p>
<p>您已大致了解了新 Java EE Security API 的基本特性和组件，可以通过下面的快速测验测试一下您学到的知识。下一篇文章将深入剖析 HttpAuthenticationMechanism 接口和它的 3 种支持 Servlet 4.0 的身份验证机制。</p>
<h1 id="测试您的了解情况"><a href="#测试您的了解情况" class="headerlink" title="测试您的了解情况"></a>测试您的了解情况</h1><ol>
<li><p>3 种默认的 HttpAuthenticationMechanism 实现是哪些？</p>
<blockquote>
<p>a. @BasicFormAuthenticationMechanismDefinition</p>
<p>b. @FormAuthenticationMechanismDefinition</p>
<p>c. @LoginFormAuthenticationMechanismDefinition</p>
<p>d. @CustomFormAuthenticationMechanismDefinition</p>
<p>e. @BasicAuthenticationMechanismDefinition</p>
</blockquote>
</li>
<li><p>以下哪两个注解将会触发内置的 LDAP 和 RDBMS 身份存储？</p>
<blockquote>
<p>a. @LdapIdentityStore</p>
<p>b. @DataBaseIdentityStore</p>
<p>c. @DataBaseIdentityStoreDefinition</p>
<p>d. @LdapIdentityStoreDefinition</p>
<p>e. @RdbmsBaseIdentityStoreDefinition</p>
</blockquote>
</li>
<li><p>以下哪句陈述是正确的？</p>
<blockquote>
<p>a. IdentityStore 只能被 HttpAuthenticationMechanism 的实现使用。</p>
<p>b. IdentityStore 能被任何内置或定制的安全选项使用。</p>
<p>c. IdentityStore 只能通过注入的 IdentityStoreHandler 实现进行访问。</p>
<p>d. IdentityStore 不能被 HttpAuthenticationMechanism 的实现使用。</p>
</blockquote>
</li>
<li><p>SecurityContext 的目标是什么？</p>
<blockquote>
<p>a. 在 servlet 和 EJB 容器之间提供对安全上下文的一致访问。</p>
<p>b. 仅向 EJB 容器提供对安全上下文的一致访问。</p>
<p>c. 在所有容器之间提供对安全上下文的一致访问。</p>
<p>d. 向 servlet 容器提供对安全上下文的一致访问。</p>
<p>e. 在 EJB 容器之间提供对安全上下文的一致访问。</p>
</blockquote>
</li>
<li><p>为什么 HttpAuthenticationMechanism 实现必须是 @ApplicationScoped？</p>
<blockquote>
<p>a. 为了确保它是一个 CDI 管理的 bean，而且可用于整个应用程序。</p>
<p>b. 以便 HttpAuthenticationMechanism 能在所有应用程序级别上使用。</p>
<p>c. 以便每个用户有一个对应的 HttpAuthenticationMechanism 实例。</p>
<p>d. JsonAdapter。</p>
<p>e. 这是一句错误的陈述。</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="针对云和微服务平台的-Java-企业安全性：测验答案"><a href="#针对云和微服务平台的-Java-企业安全性：测验答案" class="headerlink" title="针对云和微服务平台的 Java 企业安全性：测验答案"></a>针对云和微服务平台的 Java 企业安全性：测验答案</h1><ol>
<li><p>3 种默认的 HttpAuthenticationMechanism 实现是哪些？</p>
<blockquote>
<p>a. @BasicFormAuthenticationMechanismDefinition</p>
<p>b. @FormAuthenticationMechanismDefinition</p>
<p>c. @LoginFormAuthenticationMechanismDefinition</p>
<p>d. @CustomFormAuthenticationMechanismDefinition</p>
<p>e. @BasicAuthenticationMechanismDefinition</p>
</blockquote>
<blockquote>
<p>答案：b、c、e</p>
</blockquote>
</li>
<li><p>以下哪两个注解将会触发内置的 LDAP 和 RDBMS 身份存储？</p>
<blockquote>
<p>a. @LdapIdentityStore</p>
<p>b. @DataBaseIdentityStore</p>
<p>c. @DataBaseIdentityStoreDefinition</p>
<p>d. @LdapIdentityStoreDefinition</p>
<p>e. @RdbmsBaseIdentityStoreDefinition</p>
</blockquote>
<blockquote>
<p>答案：c、d</p>
</blockquote>
</li>
<li><p>以下哪句陈述是正确的？</p>
<blockquote>
<p>a. IdentityStore 只能被 HttpAuthenticationMechanism 的实现使用。</p>
<p>b. IdentityStore 能被任何内置或定制的安全选项使用。</p>
<p>c. IdentityStore 只能通过注入的 IdentityStoreHandler 实现进行访问。</p>
<p>d. IdentityStore 不能被 HttpAuthenticationMechanism 的实现使用。</p>
</blockquote>
</li>
</ol>
<pre><code>&gt; 答案：b、c</code></pre><ol>
<li><p>SecurityContext 的目标是什么？</p>
<blockquote>
<p>a. 在 servlet 和 EJB 容器之间提供对安全上下文的一致访问。</p>
<p>b. 仅向 EJB 容器提供对安全上下文的一致访问。</p>
<p>c. 在所有容器之间提供对安全上下文的一致访问。</p>
<p>d. 向 servlet 容器提供对安全上下文的一致访问。</p>
<p>e. 在 EJB 容器之间提供对安全上下文的一致访问。</p>
</blockquote>
<blockquote>
<p>答案：a、c</p>
</blockquote>
</li>
<li><p>为什么 HttpAuthenticationMechanism 实现必须是 @ApplicationScoped？</p>
<blockquote>
<p>a. 为了确保它是一个 CDI 管理的 bean，而且可用于整个应用程序。</p>
<p>b. 以便 HttpAuthenticationMechanism 能在所有应用程序级别上使用。</p>
<p>c. 以便每个用户有一个对应的 HttpAuthenticationMechanism 实例。</p>
<p>d. JsonAdapter。</p>
<p>e. 这是一句错误的陈述。</p>
</blockquote>
<blockquote>
<p>答案：a</p>
</blockquote>
</li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java EE</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream 使用指南</title>
    <url>/2020/10/20/Java/jdk8/steam/</url>
    <content><![CDATA[<h1 id="为什么需要-Stream"><a href="#为什么需要-Stream" class="headerlink" title="为什么需要 Stream"></a>为什么需要 Stream</h1><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p>
<h2 id="什么是聚合操作"><a href="#什么是聚合操作" class="headerlink" title="什么是聚合操作"></a>什么是聚合操作</h2><p>在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如：</p>
<ul>
<li>客户每月平均消费金额</li>
<li>最昂贵的在售商品</li>
<li>本周完成的有效订单（排除了无效的）</li>
<li>取十个数据样本作为首页推荐</li>
</ul>
<p>这类的操作。</p>
<p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Transaction<span class="token operator">></span> groceryTransactions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Arraylist</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>Transaction t<span class="token operator">:</span> transactions<span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Transaction<span class="token punctuation">.</span>GROCERY<span class="token punctuation">)</span><span class="token punctuation">{</span>
 groceryTransactions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>groceryTransactions<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Transaction t1<span class="token punctuation">,</span> Transaction t2<span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token keyword">return</span> t2<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> transactionIds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>Transaction t<span class="token operator">:</span> groceryTransactions<span class="token punctuation">)</span><span class="token punctuation">{</span>
 transactionsIds<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> transactionsIds <span class="token operator">=</span> transactions<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">filter</span><span class="token punctuation">(</span>t <span class="token operator">-</span><span class="token operator">></span> t<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Transaction<span class="token punctuation">.</span>GROCERY<span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">sorted</span><span class="token punctuation">(</span><span class="token function">comparing</span><span class="token punctuation">(</span>Transaction<span class="token operator">:</span><span class="token operator">:</span>getValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">map</span><span class="token punctuation">(</span>Transaction<span class="token operator">:</span><span class="token operator">:</span>getId<span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h1 id="Stream-总览"><a href="#Stream-总览" class="headerlink" title="Stream 总览"></a>Stream 总览</h1><h2 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h2><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p>
<p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p>
<p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p>
<ol>
<li>1.0-1.4 中的 java.lang.Thread</li>
<li>5.0 中的 java.util.concurrent</li>
<li>6.0 中的 Phasers 等</li>
<li>7.0 中的 Fork/Join 框架</li>
<li>8.0 中的 Lambda</li>
</ol>
<p>Stream 的另外一大特点是，数据源本身可以是无限的。</p>
<h2 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h2><p>当我们使用一个流的时候，通常包括三个基本步骤：</p>
<p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。</p>
<p>图 1. 流管道 (Stream Pipeline) 的构成<br><img src="https://i.loli.net/2018/08/28/5b856aea41c10.png" alt="图 1. 流管道 (Stream Pipeline) 的构成"></p>
<p>有多种方式生成 Stream Source：</p>
<ul>
<li>从 Collection 和数组<ul>
<li>Collection.stream()</li>
<li>Collection.parallelStream()</li>
<li>Arrays.stream(T array) or Stream.of()</li>
</ul>
</li>
<li>从 BufferedReader<ul>
<li>java.io.BufferedReader.lines()</li>
</ul>
</li>
<li>静态工厂<ul>
<li>java.util.stream.IntStream.range()</li>
<li>java.nio.file.Files.walk()</li>
</ul>
</li>
<li>自己构建<ul>
<li>java.util.Spliterator</li>
</ul>
</li>
<li>其它  <ul>
<li>Random.ints()</li>
<li>BitSet.stream()</li>
<li>Pattern.splitAsStream(java.lang.CharSequence)</li>
<li>JarFile.stream()</li>
</ul>
</li>
</ul>
<p>流的操作类型分为两种：</p>
<ul>
<li><p><code>Intermediate</code>：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p>
</li>
<li><p><code>Terminal</code>：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p>
</li>
</ul>
<p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p>
<p>还有一种操作被称为 <code>short-circuiting</code>。用以指：</p>
<ul>
<li>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</li>
<li>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</li>
</ul>
<p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> sum <span class="token operator">=</span> widgets<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>w <span class="token operator">-</span><span class="token operator">></span> w<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> RED<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span>w <span class="token operator">-</span><span class="token operator">></span> w<span class="token punctuation">.</span><span class="token function">getWeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal 操作，对符合条件的全部小物件作重量求和。</p>
<h1 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h1><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。</p>
<h2 id="流的构造与转换"><a href="#流的构造与转换" class="headerlink" title="流的构造与转换"></a>流的构造与转换</h2><p>下面提供最常见的几种构造 Stream 的样例。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. Individual values</span>
Stream stream <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 2. Arrays</span>
String <span class="token punctuation">[</span><span class="token punctuation">]</span> strArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
stream <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>strArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
stream <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>strArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 3. Collections</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>strArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
stream <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：</p>
<p>IntStream、LongStream、DoubleStream。当然我们也可以用 Stream<integer>、Stream<long> &gt;、Stream<double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</double></long></integer></p>
<p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。</p>
<pre class=" language-java"><code class="language-java">IntStream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
IntStream<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
IntStream<span class="token punctuation">.</span><span class="token function">rangeClosed</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. Array</span>
String<span class="token punctuation">[</span><span class="token punctuation">]</span> strArray1 <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 2. Collection</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> list1 <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> list2 <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toCollection</span><span class="token punctuation">(</span>ArrayList<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Set set1 <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Stack stack1 <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toCollection</span><span class="token punctuation">(</span>Stack<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 3. String</span>
String str <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。</p>
<h2 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h2><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。</p>
<ul>
<li><p><code>Intermediate</code>：<br>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p>
</li>
<li><p><code>Terminal</code>：<br>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p>
</li>
<li><p><code>Short-circuiting</code>：<br>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p>
</li>
</ul>
<p>我们下面看一下 Stream 的比较典型用法。</p>
<h3 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h3><p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> output <span class="token operator">=</span> wordList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这段代码把所有的单词转换为大写。</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> nums <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> squareNums <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token function">map</span><span class="token punctuation">(</span>n <span class="token operator">-</span><span class="token operator">></span> n <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。</p>
<p>从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p>
<pre class=" language-java"><code class="language-java">Stream<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> inputStream <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>
 Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>
 <span class="token punctuation">)</span><span class="token punctuation">;</span>
Stream<span class="token operator">&lt;</span>Integer<span class="token operator">></span> outputStream <span class="token operator">=</span> inputStream<span class="token punctuation">.</span>
<span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>childList<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> childList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p>
<pre class=" language-java"><code class="language-java">Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> sixNums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> evens <span class="token operator">=</span>
Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>sixNums<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>n <span class="token operator">-</span><span class="token operator">></span> n<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>Integer<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> output <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">flatMap</span><span class="token punctuation">(</span>line <span class="token operator">-</span><span class="token operator">></span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>REGEXP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">filter</span><span class="token punctuation">(</span>word <span class="token operator">-</span><span class="token operator">></span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Java 8</span>
roster<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">></span> p<span class="token punctuation">.</span><span class="token function">getGender</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Person<span class="token punctuation">.</span>Sex<span class="token punctuation">.</span>MALE<span class="token punctuation">)</span>
 <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Pre-Java 8</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>Person p <span class="token operator">:</span> roster<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getGender</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Person<span class="token punctuation">.</span>Sex<span class="token punctuation">.</span>MALE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p>
<p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。</p>
<p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：</p>
<pre class=" language-java"><code class="language-java">stream<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>element <span class="token operator">-</span><span class="token operator">></span> <span class="token function">doOneThing</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stream<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>element <span class="token operator">-</span><span class="token operator">></span> <span class="token function">doAnotherThing</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。</p>
<pre class=" language-java"><code class="language-java">Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">)</span>
 <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> e<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span>
 <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Filtered value: "</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span>
 <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Mapped value: "</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p>
<h3 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h3><p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。</p>
<p>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。</p>
<pre class=" language-java"><code class="language-java">String strA <span class="token operator">=</span> <span class="token string">" abcd "</span><span class="token punctuation">,</span> strB <span class="token operator">=</span> null<span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span>strA<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">print</span><span class="token punctuation">(</span>strB<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getLength</span><span class="token punctuation">(</span>strA<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getLength</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">getLength</span><span class="token punctuation">(</span>strB<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment" spellcheck="true">// Java 8</span>
 Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">// Pre-Java 8</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>text <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getLength</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment" spellcheck="true">// Java 8</span>
<span class="token keyword">return</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>length<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true">// Pre-Java 8</span>
<span class="token comment" spellcheck="true">// return if (text != null) ? text.length() : -1;</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p>
<p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于</p>
<p>Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或</p>
<p>Integer sum = integers.reduce(0, Integer::sum);</p>
<p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 字符串连接，concat = "ABCD"</span>
String concat <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> String<span class="token operator">:</span><span class="token operator">:</span>concat<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 求最小值，minValue = -3.0</span>
<span class="token keyword">double</span> minValue <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> Double<span class="token operator">:</span><span class="token operator">:</span>min<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// 求和，sumValue = 10, 有起始值</span>
<span class="token keyword">int</span> sumValue <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token operator">:</span><span class="token operator">:</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 求和，sumValue = 10, 无起始值</span>
sumValue <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>Integer<span class="token operator">:</span><span class="token operator">:</span>sum<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 过滤，字符串连接，concat = "ace"</span>
concat <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">,</span> <span class="token string">"e"</span><span class="token punctuation">,</span> <span class="token string">"F"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">filter</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> x<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token string">"Z"</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> String<span class="token operator">:</span><span class="token operator">:</span>concat<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。</p>
<h3 id="limit-skip"><a href="#limit-skip" class="headerlink" title="limit/skip"></a>limit/skip</h3><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLimitAndSkip</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 List<span class="token operator">&lt;</span>Person<span class="token operator">></span> persons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
 persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> personList2 <span class="token operator">=</span> persons<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token function">map</span><span class="token punctuation">(</span>Person<span class="token operator">:</span><span class="token operator">:</span>getName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>personList2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span> <span class="token keyword">int</span> no<span class="token punctuation">;</span>
 <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
 <span class="token keyword">public</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token keyword">int</span> no<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>no <span class="token operator">=</span> no<span class="token punctuation">;</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> name<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>输出结果为：</p>
<pre><code>name1
name2
name3
name4
name5
name6
name7
name8
name9
name10
[name4, name5, name6, name7, name8, name9, name10]</code></pre><p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。</p>
<p>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Person<span class="token operator">></span> persons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
 persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
List<span class="token operator">&lt;</span>Person<span class="token operator">></span> personList2 <span class="token operator">=</span> persons<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> 
p1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>personList2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为：</p>
<pre><code>name2
name1
name3
name2
name4
name3
name5
name4
[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27]</code></pre><p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。</p>
<p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。</p>
<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Person<span class="token operator">></span> persons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
 persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
List<span class="token operator">&lt;</span>Person<span class="token operator">></span> personList2 <span class="token operator">=</span> persons<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> p1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>personList2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>结果会简单很多：</p>
<pre><code>name2
name1
[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a]</code></pre><p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。</p>
<h3 id="min-max-distinct"><a href="#min-max-distinct" class="headerlink" title="min/max/distinct"></a>min/max/distinct</h3><p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。</p>
<pre class=" language-java"><code class="language-java">BufferedReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"c:\\SUService.log"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> longest <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">mapToInt</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>length<span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">getAsInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>longest<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>下面的例子则使用 distinct 来找出不重复的单词。</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> words <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">flatMap</span><span class="token punctuation">(</span>line <span class="token operator">-</span><span class="token operator">></span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">filter</span><span class="token punctuation">(</span>word <span class="token operator">-</span><span class="token operator">></span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toLowerCase<span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><p>Stream 有三个 match 方法，从语义上说：</p>
<ul>
<li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li>
<li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li>
<li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true<br>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。</li>
</ul>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Person<span class="token operator">></span> persons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> isAllAdult <span class="token operator">=</span> persons<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">allMatch</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">></span> p<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"All are adult? "</span> <span class="token operator">+</span> isAllAdult<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> isThereAnyChild <span class="token operator">=</span> persons<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">anyMatch</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">></span> p<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Any child? "</span> <span class="token operator">+</span> isThereAnyChild<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>输出结果：</p>
<pre><code>All are adult? false
Any child? true</code></pre><h2 id="进阶：自己生成流"><a href="#进阶：自己生成流" class="headerlink" title="进阶：自己生成流"></a>进阶：自己生成流</h2><h3 id="Stream-generate"><a href="#Stream-generate" class="headerlink" title="Stream.generate"></a>Stream.generate</h3><p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。</p>
<pre class=" language-java"><code class="language-java">Random seed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Supplier<span class="token operator">&lt;</span>Integer<span class="token operator">></span> random <span class="token operator">=</span> seed<span class="token operator">:</span><span class="token operator">:</span>nextInt<span class="token punctuation">;</span>
Stream<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span>random<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//Another way</span>
IntStream<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。</p>
<pre class=" language-java"><code class="language-java">Stream<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PersonSupplier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
<span class="token function">forEach</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> p<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">PersonSupplier</span> <span class="token keyword">implements</span> <span class="token class-name">Supplier</span><span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token punctuation">{</span>
 <span class="token keyword">private</span> <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">private</span> Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token annotation punctuation">@Override</span>
 <span class="token keyword">public</span> Person <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>index<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"StormTestUser"</span> <span class="token operator">+</span> index<span class="token punctuation">,</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>输出结果：</p>
<pre><code>StormTestUser1, 9
StormTestUser2, 12
StormTestUser3, 88
StormTestUser4, 51
StormTestUser5, 22
StormTestUser6, 28
StormTestUser7, 81
StormTestUser8, 51
StormTestUser9, 4
StormTestUser10, 76</code></pre><h3 id="Stream-iterate"><a href="#Stream-iterate" class="headerlink" title="Stream.iterate"></a>Stream.iterate</h3><p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。</p>
<pre class=" language-java"><code class="language-java">Stream<span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span><span class="token operator">></span> n <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">forEach</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>输出结果：</p>
<pre><code>0 3 6 9 12 15 18 21 24 27</code></pre><p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p>
<h2 id="进阶：用-Collectors-来进行-reduction-操作"><a href="#进阶：用-Collectors-来进行-reduction-操作" class="headerlink" title="进阶：用 Collectors 来进行 reduction 操作"></a>进阶：用 Collectors 来进行 reduction 操作</h2><p>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。</p>
<h3 id="groupingBy-partitioningBy"><a href="#groupingBy-partitioningBy" class="headerlink" title="groupingBy/partitioningBy"></a>groupingBy/partitioningBy</h3><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Person<span class="token operator">>></span> personGroups <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PersonSupplier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>Person<span class="token operator">:</span><span class="token operator">:</span>getAge<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Iterator it <span class="token operator">=</span> personGroups<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Person<span class="token operator">>></span> persons <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token punctuation">)</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Age "</span> <span class="token operator">+</span> persons<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" = "</span> <span class="token operator">+</span> persons<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出：</p>
<pre><code>Age 0 = 2
Age 1 = 2
Age 5 = 2
Age 8 = 1
Age 9 = 1
Age 11 = 2
……</code></pre><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>Boolean<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Person<span class="token operator">>></span> children <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PersonSupplier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
 <span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">partitioningBy</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">></span> p<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Children number: "</span> <span class="token operator">+</span> children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Adult number: "</span> <span class="token operator">+</span> children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>输出结果：</p>
<pre><code>Children number: 23 
Adult number: 77</code></pre><p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>总之，Stream 的特性可以归纳为：</p>
<ul>
<li>不是数据结构<ul>
<li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li>
<li>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li>
</ul>
</li>
<li>所有 Stream 的操作必须以 lambda 表达式为参数</li>
<li>不支持索引访问<ul>
<li>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li>
</ul>
</li>
<li>很容易生成数组或者 List</li>
<li>惰性化<ul>
<li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li>
<li>Intermediate 操作永远是惰性化的。</li>
</ul>
</li>
<li>并行能力<ul>
<li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li>
</ul>
</li>
<li>可以是无限的<ul>
<li>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK8</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>通过实例理解 JDK8 的 CompletableFuture</title>
    <url>/2020/10/20/Java/jdk8/%E9%80%9A%E8%BF%87%E5%AE%9E%E4%BE%8B%E7%90%86%E8%A7%A3%20JDK8%20%E7%9A%84%20CompletableFuture/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 5 并发库主要关注于异步任务的处理，它采用了这样一种模式，producer 线程创建任务并且利用阻塞队列将其传递给任务的 consumer。这种模型在 Java 7 和 8 中进一步发展，并且开始支持另外一种风格的任务执行，那就是将任务的数据集分解为子集，每个子集都可以由独立且同质的子任务来负责处理。</p>
<p>这种风格的基础库也就是 fork/join 框架，它允许程序员规定数据集该如何进行分割，并且支持将子任务提交到默认的标准线程池中，也就是 “通用的”ForkJoinPool。Java 8 中，fork/join 并行功能借助并行流的机制变得更加具有可用性。但是，不是所有的问题都适合这种风格的并行处理：所处理的元素必须是独立的，数据集要足够大，并且在并行加速方面，每个元素的处理成本要足够高，这样才能补偿建立 fork/join 框架所消耗的成本。CompletableFuture 类则是 Java 8 在并行流方面的创新。</p>
<h1 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h1><h2 id="异步计算"><a href="#异步计算" class="headerlink" title="异步计算"></a>异步计算</h2><p>所谓异步调用其实就是实现一个可无需等待被调用函数的返回值而让操作继续运行的方法。在 Java 语言中，简单的讲就是另启一个线程来完成调用中的部分计算，使调用继续运行或返回，而不需要等待计算结果。但调用者仍需要取线程的计算结果。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数比较通用的解释是，它是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外一方调用的，用于对该事件或条件进行响应。</p>
<p>回调函数的机制：</p>
<ol>
<li><p>定义一个回调函数；</p>
</li>
<li><p>提供函数实现的一方在初始化时候，将回调函数的函数指针注册给调用者；</p>
</li>
<li><p>当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。</p>
</li>
</ol>
<p>回调函数通常与原始调用者处于同一层次，如图 1 所示：</p>
<p>图 1 回调函数示例图<br><img src="https://www.ibm.com/developerworks/cn/java/j-cf-of-jdk8/image001.png" alt=""></p>
<h2 id="Future-接口介绍"><a href="#Future-接口介绍" class="headerlink" title="Future 接口介绍"></a>Future 接口介绍</h2><p>JDK5 新增了 Future 接口，用于描述一个异步计算的结果。虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式呢？即当计算结果完成及时通知监听者。</p>
<p>有一些开源框架实现了我们的设想，例如 Netty 的 ChannelFuture 类扩展了 Future 接口，通过提供 addListener 方法实现支持回调方式的异步编程。Netty 中所有的 I/O 操作都是异步的, 这意味着任何的 I/O 调用都将立即返回，而不保证这些被请求的 I/O 操作在调用结束的时候已经完成。取而代之地，你会得到一个返回的 ChannelFuture 实例，这个实例将给你一些关于 I/O 操作结果或者状态的信息。当一个 I/O 操作开始的时候，一个新的 Future 对象就会被创建。在开始的时候，新的 Future 是未完成的状态－－它既非成功、失败，也非被取消，因为 I/O 操作还没有结束。如果 I/O 操作以成功、失败或者被取消中的任何一种状态结束了，那么这个 Future 将会被标记为已完成，并包含更多详细的信息（例如：失败的原因）。请注意，即使是失败和被取消的状态，也是属于已完成的状态。阻塞方式的示例代码如代码 1 所示。</p>
<p>代码 1 阻塞方式示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Start the connection attempt.</span>
ChannelFuture Future <span class="token operator">=</span> bootstrap<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Wait until the connection is closed or the connection attempt fails.</span>
Future<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCloseFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">awaitUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Shut down thread pools to exit.</span>
bootstrap<span class="token punctuation">.</span><span class="token function">releaseExternalResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>上面代码使用的是 awaitUninterruptibly 方法，源代码如代码 2 所示。</p>
<p>代码 2 awaitUninterruptibly 源代码</p>
<pre class=" language-java"><code class="language-java"><span class="token function">publicChannelFutureawaitUninterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 循环等待到完成</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">checkDeadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            waiters<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 不允许中断</span>
            interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            waiters<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>代码 3 异步非阻塞方式示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Start the connection attempt.</span>
ChannelFuture Future <span class="token operator">=</span> bootstrap<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Future<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelFutureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span><span class="token keyword">final</span> ChannelFuture Future<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> Exception
        <span class="token punctuation">{</span>           
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Shut down thread pools to exit. </span>
bootstrap<span class="token punctuation">.</span><span class="token function">releaseExternalResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>可以明显的看出，在异步模式下，上面这段代码没有阻塞，在执行 connect 操作后直接执行到 printTime(“异步时间：”)，随后 connect 完成，Future 的监听函数输出 connect 操作完成。</p>
<p>非阻塞则是添加监听类 ChannelFutureListener，通过覆盖 ChannelFutureListener 的 operationComplete 执行业务逻辑。</p>
<p>代码 4 异步非阻塞方式示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">final</span> ChannelFutureListener listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>listener <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"listener"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
    booleannotifyNow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        notifyNow <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstListener <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//listener 链表头</span>
        firstListener <span class="token operator">=</span> listener<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>otherListeners <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        otherListeners <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>ChannelFutureListener<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 添加到 listener 链表中，以便操作完成后遍历操作</span>
        otherListeners<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>notifyNow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 通知 listener 进行处理</span>
        <span class="token function">notifyListener</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这部分代码的逻辑很简单，就是注册回调函数，当操作完成后自动调用回调函数，就达到了异步的效果。</p>
<h2 id="CompletableFuture-类介绍"><a href="#CompletableFuture-类介绍" class="headerlink" title="CompletableFuture 类介绍"></a>CompletableFuture 类介绍</h2><p>Java 8 中, 新增加了一个包含 50 个方法左右的类 –CompletableFuture，它提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合 CompletableFuture 的方法。</p>
<p>对于阻塞或者轮询方式，依然可以通过 CompletableFuture 类的 CompletionStage 和 Future 接口方式支持。</p>
<p>CompletableFuture 类声明了 CompletionStage 接口，CompletionStage 接口实际上提供了同步或异步运行计算的舞台，所以我们可以通过实现多个 CompletionStage 命令，并且将这些命令串联在一起的方式实现多个命令之间的触发。</p>
<p>我们可以通过 CompletableFuture.supplyAsync(this::sendMsg); 这么一行代码创建一个简单的异步计算。在这行代码中，supplyAsync 支持异步地执行我们指定的方法，这个例子中的异步执行方法是 sendMsg。当然，我们也可以使用 Executor 执行异步程序，默认是 ForkJoinPool.commonPool()。</p>
<p>我们也可以在异步计算结束之后指定回调函数，例如 CompletableFuture.supplyAsync(this::sendMsg) .thenAccept(this::notify); 这行代码中的 thenAccept 被用于增加回调函数，在我们的示例中 notify 就成了异步计算的消费者，它会处理计算结果。</p>
<h1 id="CompletableFuture-类使用示例"><a href="#CompletableFuture-类使用示例" class="headerlink" title="CompletableFuture 类使用示例"></a>CompletableFuture 类使用示例</h1><p>接下来我们通过 20 个示例看看 CompletableFuture 类具体怎么用。</p>
<h2 id="创建完整的-CompletableFuture"><a href="#创建完整的-CompletableFuture" class="headerlink" title="创建完整的 CompletableFuture"></a>创建完整的 CompletableFuture</h2><p>代码 5 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">completedFutureExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span>cf <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertTrue</span><span class="token punctuation">(</span>cf<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">,</span> cf<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>以上代码一般来说被用于启动异步计算，getNow(null) 返回计算结果或者 null。</p>
<h2 id="运行简单的异步场景"><a href="#运行简单的异步场景" class="headerlink" title="运行简单的异步场景"></a>运行简单的异步场景</h2><p>代码 6 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">runAsyncExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    CompletableFuture<span class="token operator">&lt;</span>Void<span class="token operator">></span>cf <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token function">assertTrue</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">randomSleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertFalse</span><span class="token punctuation">(</span>cf<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleepEnough</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertTrue</span><span class="token punctuation">(</span>cf<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>以上代码的关键点有两点：</p>
<ol>
<li>CompletableFuture 是异步执行方式；</li>
<li>使用 ForkJoinPool 实现异步执行，这种方式使用了 daemon 线程执行 Runnable 任务。</li>
</ol>
<h2 id="同步执行动作示例"><a href="#同步执行动作示例" class="headerlink" title="同步执行动作示例"></a>同步执行动作示例</h2><p>代码 7 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">thenApplyExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span>cf <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">assertFalse</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    returns<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"MESSAGE"</span><span class="token punctuation">,</span> cf<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>以上代码在异步计算正常完成的前提下将执行动作（此处为转换成大写字母）。</p>
<h2 id="异步执行动作示例"><a href="#异步执行动作示例" class="headerlink" title="异步执行动作示例"></a>异步执行动作示例</h2><p>相较前一个示例的同步方式，以下代码实现了异步方式，仅仅是在上面的代码里的多个方法增加 “Async” 这样的关键字。</p>
<p>代码 8 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">thenApplyAsyncExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span>cf <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApplyAsync</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">assertTrue</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">randomSleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    returns<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertNull</span><span class="token punctuation">(</span>cf<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"MESSAGE"</span><span class="token punctuation">,</span> cf<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="使用固定的线程池完成异步执行动作示例"><a href="#使用固定的线程池完成异步执行动作示例" class="headerlink" title="使用固定的线程池完成异步执行动作示例"></a>使用固定的线程池完成异步执行动作示例</h2><p>我们可以通过使用线程池方式来管理异步动作申请，以下代码基于固定的线程池，也是做一个大写字母转换动作，代码如代码 9 所示。</p>
<p>代码 9 示例代码</p>
<pre class=" language-java"><code class="language-java">staticExecutorService executor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Thread <span class="token function">newThread</span><span class="token punctuation">(</span>Runnable runnable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> <span class="token string">"custom-executor-"</span> <span class="token operator">+</span> count<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">thenApplyAsyncWithExecutorExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span>cf <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApplyAsync</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token function">assertTrue</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"custom-executor-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">assertFalse</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">randomSleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            returns<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> executor<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assertNull</span><span class="token punctuation">(</span>cf<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"MESSAGE"</span><span class="token punctuation">,</span> cf<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="作为消费者消费计算结果示例"><a href="#作为消费者消费计算结果示例" class="headerlink" title="作为消费者消费计算结果示例"></a>作为消费者消费计算结果示例</h2><p>假设我们本次计算只需要前一次的计算结果，而不需要返回本次计算结果，那就有点类似于生产者（前一次计算）- 消费者（本次计算）模式了，示例代码如代码 10 所示。</p>
<p>代码 10 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">thenAcceptExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    StringBuilder result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token string">"thenAccept message"</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">thenAccept</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span>result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token string">"Result was empty"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>消费者是同步执行的，所以不需要在 CompletableFuture 里对结果进行合并。</p>
<h2 id="异步消费示例"><a href="#异步消费示例" class="headerlink" title="异步消费示例"></a>异步消费示例</h2><p>相较于前一个示例的同步方式，我们也对应有异步方式，代码如代码 11 所示。</p>
<p>代码 11 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">thenAcceptAsyncExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    StringBuilder result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CompletableFuture<span class="token operator">&lt;</span>Void<span class="token operator">></span>cf <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token string">"thenAcceptAsync message"</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">thenAcceptAsync</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span>result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cf<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token string">"Result was empty"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="计算过程中的异常示例"><a href="#计算过程中的异常示例" class="headerlink" title="计算过程中的异常示例"></a>计算过程中的异常示例</h2><p>接下来介绍异步操作过程中的异常情况处理。下面这个示例中我们会在字符转换异步请求中刻意延迟 1 秒钟，然后才会提交到 ForkJoinPool 里面去执行。</p>
<p>代码 12 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">completeExceptionallyExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span>cf <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApplyAsync</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">,</span>
        CompletableFuture<span class="token punctuation">.</span><span class="token function">delayedExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span>exceptionHandler <span class="token operator">=</span> cf<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> th<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>th <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"message upon cancel"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cf<span class="token punctuation">.</span><span class="token function">completeExceptionally</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"completed exceptionally"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token string">"Was not completed exceptionally"</span><span class="token punctuation">,</span> cf<span class="token punctuation">.</span><span class="token function">isCompletedExceptionally</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        cf<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">"Should have thrown an exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>CompletionException ex<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// just for testing</span>
            <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"completed exceptionally"</span><span class="token punctuation">,</span> ex<span class="token punctuation">.</span><span class="token function">getCause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
     <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"message upon cancel"</span><span class="token punctuation">,</span> exceptionHandler<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>示例代码中，首先我们创建一个 CompletableFuture（计算完毕），然后调用 thenApplyAsync 返回一个新的 CompletableFuture，接着通过使用 delayedExecutor(timeout, timeUnit) 方法延迟 1 秒钟执行。然后我们创建一个 handler（exceptionHandler），它会处理异常，返回另一个字符串 “message upon cancel”。接下来进入 join() 方法，执行大写转换操作，并且抛出 CompletionException 异常。</p>
<h2 id="取消计算任务"><a href="#取消计算任务" class="headerlink" title="取消计算任务"></a>取消计算任务</h2><p>与前面一个异常处理的示例类似，我们可以通过调用 cancel(boolean mayInterruptIfRunning) 方法取消计算任务。此外，cancel() 方法与 completeExceptionally(new CancellationException()) 等价。</p>
<p>代码 13 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cancelExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    CompletableFuture cf <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApplyAsync</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">,</span>
    CompletableFuture<span class="token punctuation">.</span><span class="token function">delayedExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CompletableFuture cf2 <span class="token operator">=</span> cf<span class="token punctuation">.</span><span class="token function">exceptionally</span><span class="token punctuation">(</span>throwable <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"canceled message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token string">"Was not canceled"</span><span class="token punctuation">,</span> cf<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token string">"Was not completed exceptionally"</span><span class="token punctuation">,</span> cf<span class="token punctuation">.</span><span class="token function">isCompletedExceptionally</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"canceled message"</span><span class="token punctuation">,</span> cf2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="一个-CompletableFuture-VS-两个异步计算"><a href="#一个-CompletableFuture-VS-两个异步计算" class="headerlink" title="一个 CompletableFuture VS 两个异步计算"></a>一个 CompletableFuture VS 两个异步计算</h2><p>我们可以创建一个 CompletableFuture 接收两个异步计算的结果，下面代码首先创建了一个 String 对象，接下来分别创建了两个 CompletableFuture 对象 cf1 和 cf2，cf2 通过调用 applyToEither 方法实现我们的需求。</p>
<p>代码 14 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">applyToEitherExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String original <span class="token operator">=</span> <span class="token string">"Message"</span><span class="token punctuation">;</span>
    CompletableFuture cf1 <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">thenApplyAsync</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token function">delayedUpperCase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CompletableFuture cf2 <span class="token operator">=</span> cf1<span class="token punctuation">.</span><span class="token function">applyToEither</span><span class="token punctuation">(</span>
    CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApplyAsync</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token function">delayedLowerCase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    s <span class="token operator">-</span><span class="token operator">></span> s <span class="token operator">+</span> <span class="token string">"from applyToEither"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertTrue</span><span class="token punctuation">(</span>cf2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">"from applyToEither"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>如果我们想要使用消费者替换代码 14 的方法方式用于处理异步计算结果，代码如代码 15 所示。</p>
<p>代码 15 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">acceptEitherExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String original <span class="token operator">=</span> <span class="token string">"Message"</span><span class="token punctuation">;</span>
    StringBuilder result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CompletableFuture cf <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">thenApplyAsync</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token function">delayedUpperCase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">acceptEither</span><span class="token punctuation">(</span>CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApplyAsync</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token function">delayedLowerCase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    s <span class="token operator">-</span><span class="token operator">></span> result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"acceptEither"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cf<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token string">"Result was empty"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">"acceptEither"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="运行两个阶段后执行"><a href="#运行两个阶段后执行" class="headerlink" title="运行两个阶段后执行"></a>运行两个阶段后执行</h2><p>下面这个示例程序两个阶段执行完毕后返回结果，首先将字符转为大写，然后将字符转为小写，在两个计算阶段都结束之后触发 CompletableFuture。</p>
<p>代码 16 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">runAfterBothExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String original <span class="token operator">=</span> <span class="token string">"Message"</span><span class="token punctuation">;</span>
    StringBuilder result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">runAfterBoth</span><span class="token punctuation">(</span>
    CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toLowerCase<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token string">"Result was empty"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>也可以通过以下方式处理异步计算结果，</p>
<p>代码 17 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">thenAcceptBothExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String original <span class="token operator">=</span> <span class="token string">"Message"</span><span class="token punctuation">;</span>
    StringBuilder result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAcceptBoth</span><span class="token punctuation">(</span>
    CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toLowerCase<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1 <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"MESSAGEmessage"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="整合两个计算结果"><a href="#整合两个计算结果" class="headerlink" title="整合两个计算结果"></a>整合两个计算结果</h2><p>我们可以通过 thenCombine() 方法整合两个异步计算的结果，注意，以下代码的整个程序过程是同步的，getNow() 方法最终会输出整合后的结果，也就是说大写字符和小写字符的串联值。</p>
<p>代码 18 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">thenCombineExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String original <span class="token operator">=</span> <span class="token string">"Message"</span><span class="token punctuation">;</span>
    CompletableFuture cf <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token function">delayedUpperCase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">thenCombine</span><span class="token punctuation">(</span>CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token function">delayedLowerCase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1 <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"MESSAGEmessage"</span><span class="token punctuation">,</span> cf<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>上面这个示例是按照同步方式执行两个方法后再合成字符串，以下代码采用异步方式同步执行两个方法，由于异步方式情况下不能够确定哪一个方法最终执行完毕，所以我们需要调用 join() 方法等待后一个方法结束后再合成字符串，这一点和线程的 join() 方法是一致的，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到 join() 方法了，即 join() 的作用是：”等待该线程终止”。</p>
<p>代码 19 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">thenCombineAsyncExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String original <span class="token operator">=</span> <span class="token string">"Message"</span><span class="token punctuation">;</span>
    CompletableFuture cf <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">thenApplyAsync</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token function">delayedUpperCase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">thenCombine</span><span class="token punctuation">(</span>CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApplyAsync</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token function">delayedLowerCase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"MESSAGEmessage"</span><span class="token punctuation">,</span> cf<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> s1 <span class="token operator">+</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>除了 thenCombine() 方法以外，还有另外一种方法 - thenCompose()，这个方法也会实现两个方法执行后的返回结果的连接。</p>
<p>代码 20 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">thenComposeExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    String original <span class="token operator">=</span> <span class="token string">"Message"</span><span class="token punctuation">;</span>
    CompletableFuture cf <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token function">delayedUpperCase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">thenCompose</span><span class="token punctuation">(</span>upper <span class="token operator">-</span><span class="token operator">></span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token function">delayedLowerCase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> upper <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"MESSAGEmessage"</span><span class="token punctuation">,</span> cf<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="anyOf-方法"><a href="#anyOf-方法" class="headerlink" title="anyOf() 方法"></a>anyOf() 方法</h2><p>以下代码模拟了如何在几个计算过程中任意一个完成后创建 CompletableFuture，在这个例子中，我们创建了几个计算过程，然后转换字符串到大写字符。由于这些 CompletableFuture 是同步执行的（下面这个例子使用的是 thenApply() 方法，而不是 thenApplyAsync() 方法），使用 anyOf() 方法后返回的任何一个值都会立即触发 CompletableFuture。然后我们使用 whenComplete(BiConsumer&lt;? super Object, ? super Throwable&gt; action) 方法处理结果。</p>
<p>代码 21 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">anyOfExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    StringBuilder result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    List messages <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    List<span class="token operator">&lt;</span>CompletableFuture<span class="token operator">></span> futures <span class="token operator">=</span> messages<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>msg <span class="token operator">-</span><span class="token operator">></span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token function">delayedUpperCase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CompletableFuture<span class="token punctuation">.</span><span class="token function">anyOf</span><span class="token punctuation">(</span>futures<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">[</span>futures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> th<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>th <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token function">isUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token string">"Result was empty"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="当所有的-CompletableFuture-完成后创建-CompletableFuture"><a href="#当所有的-CompletableFuture-完成后创建-CompletableFuture" class="headerlink" title="当所有的 CompletableFuture 完成后创建 CompletableFuture"></a>当所有的 CompletableFuture 完成后创建 CompletableFuture</h2><p>代码 22 所示我们会以同步方式执行多个异步计算过程，在所有计算过程都完成后，创建一个 CompletableFuture。</p>
<p>代码 22 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">allOfExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    StringBuilder result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    List messages <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    List<span class="token operator">&lt;</span>CompletableFuture<span class="token operator">></span> futures <span class="token operator">=</span> messages<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>msg <span class="token operator">-</span><span class="token operator">></span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token function">delayedUpperCase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CompletableFuture<span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>futures<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">[</span>futures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> th<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
        futures<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>cf <span class="token operator">-</span><span class="token operator">></span> <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token function">isUpperCase</span><span class="token punctuation">(</span>cf<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token string">"Result was empty"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>相较于前一个同步示例，我们也可以异步执行，如代码 23 所示。</p>
<p>代码 23 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">allOfAsyncExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    StringBuilder result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    List messages <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    List<span class="token operator">&lt;</span>CompletableFuture<span class="token operator">></span> futures <span class="token operator">=</span> messages<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>msg <span class="token operator">-</span><span class="token operator">></span> CompletableFuture<span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApplyAsync</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token function">delayedUpperCase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CompletableFuture allOf <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>futures<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">[</span>futures<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> th<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
    futures<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>cf <span class="token operator">-</span><span class="token operator">></span> <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token function">isUpperCase</span><span class="token punctuation">(</span>cf<span class="token punctuation">.</span><span class="token function">getNow</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    allOf<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token string">"Result was empty"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><p>以下代码完成的操作包括：</p>
<ol>
<li>首先异步地通过调用 cars() 方法获取 Car 对象，返回一个 CompletionStage<list> 实例。Cars() 方法可以在内部使用调用远端服务器上的 REST 服务等类似场景。</list></li>
<li>然后和其他的 CompletionStage<list> 组合，通过调用 rating(manufacturerId) 方法异步地返回 CompletionStage 实例。</list></li>
<li>当所有的 Car 对象都被填充了 rating 后，调用 allOf() 方法获取最终值。</li>
<li>调用 whenComplete() 方法打印最终的评分（rating）。</li>
</ol>
<p>代码 24 示例代码</p>
<pre class=" language-java"><code class="language-java"><span class="token function">cars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenCompose</span><span class="token punctuation">(</span>cars <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>CompletionStage<span class="token operator">></span> updatedCars <span class="token operator">=</span> cars<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>car <span class="token operator">-</span><span class="token operator">></span> <span class="token function">rating</span><span class="token punctuation">(</span>car<span class="token punctuation">.</span>manufacturerId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>r <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
    car<span class="token punctuation">.</span><span class="token function">setRating</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> car<span class="token punctuation">;</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    CompletableFuture done <span class="token operator">=</span> CompletableFuture
    <span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>updatedCars<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">[</span>updatedCars<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> done<span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>v <span class="token operator">-</span><span class="token operator">></span> updatedCars<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>CompletionStage<span class="token operator">:</span><span class="token operator">:</span>toCompletableFuture<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>CompletableFuture<span class="token operator">:</span><span class="token operator">:</span>join<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cars<span class="token punctuation">,</span> th<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>th <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cars<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>th<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toCompletableFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>Completable 类为我们提供了丰富的异步计算调用方式，我们可以通过上述基本操作描述及 20 个示例程序进一步了解如果使用 CompletableFuture 类实现我们的需求，期待 JDK10 会有持续更新。</p>
<h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><p>参考 developerWorks 上的 Java 8 文章，了解更多 Java 8 知识。</p>
<p>参考书籍 Java 8 in Action Raoul-Gabriel Urma</p>
<p>参考书籍 Mastering Lambdas: Java Programming in a Multicore World Maurice Naftalin</p>
<p>参考文章 <a href="http://codingjunkie.net/completable-futures-part1/" target="_blank" rel="noopener">Java 8 CompletableFutures</a>，这篇文章从基础介绍了 CompletableFuture 类的使用方式。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java</category>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK8</tag>
      </tags>
  </entry>
  <entry>
    <title>Blogger Api -- 小米规整</title>
    <url>/2018/09/14/%E6%94%B6%E9%9B%86/api/blogger%20Api/</url>
    <content><![CDATA[<h1 id="Blogger-API-Getting-Started"><a href="#Blogger-API-Getting-Started" class="headerlink" title="Blogger API: Getting Started"></a>Blogger API: Getting Started</h1><p>This document explains how to get started using the Blogger API.</p>
<h2 id="Before-you-start"><a href="#Before-you-start" class="headerlink" title="Before you start"></a>Before you start</h2><h3 id="Get-a-Google-Account"><a href="#Get-a-Google-Account" class="headerlink" title="Get a Google Account"></a>Get a Google Account</h3><p>Make sure that you have a Google Account set up. We recommend that you use a separate Google Account for development and testing purposes to protect yourself from accidental data loss. If you already have a test account, then you’re all set; you can visit the Blogger user interface to set up, edit, or view your test data.</p>
<h3 id="Get-familiar-with-Blogger"><a href="#Get-familiar-with-Blogger" class="headerlink" title="Get familiar with Blogger"></a>Get familiar with Blogger</h3><p>If you’re unfamiliar with Blogger concepts, read this document and experiment with the user interface before starting to code. This document assumes that you’re familiar with Blogger, with web programming concepts, and with web data formats.</p>
<h3 id="Learn-about-authorizing-requests-and-identifying-your-application"><a href="#Learn-about-authorizing-requests-and-identifying-your-application" class="headerlink" title="Learn about authorizing requests and identifying your application"></a>Learn about authorizing requests and identifying your application</h3><p>When your application requests private data, the request must be authorized by an authenticated user who has access to that data.</p>
<p>When your application requests public data, the request doesn’t need to be authorized, but does need to be accompanied by an identifier, such as an API key.</p>
<p>For information about how to authorize requests and use API keys, see Authorizing requests and identifying your application in the Using the API document.</p>
<h2 id="Blogger-API-background"><a href="#Blogger-API-background" class="headerlink" title="Blogger API background"></a>Blogger API background</h2><h3 id="Blogger-concepts"><a href="#Blogger-concepts" class="headerlink" title="Blogger concepts"></a>Blogger concepts</h3><p>Blogger is built on five basic concepts:</p>
<ul>
<li><strong>Blogs</strong>: The root concept of the API. A blog has posts and pages. This is the container for blog meta-information like blog name and Description.</li>
<li><strong>Posts</strong>: A blog post is the publishable item that the blog author has created. This information is meant to be timely, reflecting what the authors want to publish to the world now. It is understood that as time passes, blog posts content ages and becomes less relevent.</li>
<li><strong>Comments</strong>: A comment is the place where people other than the blog post author react to what the author has written. Everything from bricks to bouquets.</li>
<li><strong>Pages</strong>: A page is a place for static content, such as biographical information, or the ways to contact the user. This is generally timeless information that doesn’t change very often.</li>
<li><strong>Users</strong>: A user is someone who interacts with Blogger, be they acting as an Author, an Administrator, or just a Reader. For public blogs, readers may be anonymous, but on private blogs a reader must be identified by Blogger.</li>
</ul>
<h3 id="Blogger-API-data-model"><a href="#Blogger-API-data-model" class="headerlink" title="Blogger API data model"></a>Blogger API data model</h3><p>A resource is an individual data entity with a unique identifier. The Blogger JSON API operates on five types of resources:</p>
<ul>
<li><strong>Blogs resource</strong>: Represents a blog.</li>
<li><strong>Posts resource</strong>: Represents a post; each posts resource is a child of a blogs resource.</li>
<li><strong>Comments resource</strong>: Represents a comment on a specific post; each comments resource is a child of a posts resource.</li>
<li><strong>Pages resource</strong>: Represents a static page; each pages resource is a child of a blogs resource.</li>
<li><strong>Users resource</strong>: Represents a non-anonymous user. This is used to identify the Author of a page, post, or comment.</li>
</ul>
<p><img src="http://ot0en8caw.bkt.clouddn.com/20180421124224.png" alt="The blogs resource has two children resource types, pages and posts. A posts resource may have comments resource children."></p>
<p>Overview of the relationships between resources</p>
<p>The Blogger API data model is based on groups of resources, called collections:</p>
<p><strong>Blogs collection</strong></p>
<blockquote>
<p>A blogs collection consists of all the blogs a user has access rights to. You can list blogs by user, or retrieve a single blog by ID.</p>
</blockquote>
<p><strong>Posts collection</strong></p>
<blockquote>
<p>A Posts collection consists of all the posts resources within a specific blogs resource.</p>
</blockquote>
<p><strong>Comments collection</strong></p>
<blockquote>
<p>A comments collection consists of all the comments resources within a specific posts resource.</p>
</blockquote>
<p><strong>Pages collection</strong></p>
<blockquote>
<p>A pages collection consists of all the pages resources within a specific blogs resource.</p>
</blockquote>
<p><strong>Users Collection</strong></p>
<blockquote>
<p>A users collection consists of all the users resources on Blogger, and thus cannot be listed. A user can retrieve their own users resource (but nobody else’s) by ID, or by using the identifier self.</p>
</blockquote>
<h3 id="Blogger-API-operations"><a href="#Blogger-API-operations" class="headerlink" title="Blogger API operations"></a>Blogger API operations</h3><p>You can invoke a number of different methods on collections and resources in the Blogger API, as described in the following table.</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
<th>REST HTTP mappings</th>
</tr>
</thead>
<tbody><tr>
<td>list</td>
<td>Lists all resources within a collection.</td>
<td>GET on a collection URI.</td>
</tr>
<tr>
<td>get</td>
<td>Gets a specific resource.</td>
<td>GET on a resource URI.</td>
</tr>
<tr>
<td>getByUrl</td>
<td>Gets a resource, looking it up by URL.</td>
<td>GET with the URL passed in as a parameter.</td>
</tr>
<tr>
<td>getByPath</td>
<td>Gets a resource by looking it up by its path.</td>
<td>GET with the Path passed in as a parameter.</td>
</tr>
<tr>
<td>listByUser</td>
<td>Lists resources owned by a User.</td>
<td>GET on a user owned collection.</td>
</tr>
<tr>
<td>search</td>
<td>Search for resources, based on a query parameter.</td>
<td>GET on a Search URL, with the query passed in as a parameter.</td>
</tr>
<tr>
<td>insert</td>
<td>Create a resource in a collection.</td>
<td>POST on a collection URI.</td>
</tr>
<tr>
<td>delete</td>
<td>Deletes a resource.</td>
<td>DELETE on a resource URI.</td>
</tr>
<tr>
<td>patch</td>
<td>Update a resource, using Patch semantics.</td>
<td>PATCH on a resource URI.</td>
</tr>
<tr>
<td>update</td>
<td>Update a resource.</td>
<td>PUT on a resource URI.</td>
</tr>
</tbody></table>
<p>The table below shows which methods are supported by each resource type. All list and get operations on private blogs require authentication.</p>
<table>
<thead>
<tr>
<th>Resource Type</th>
<th>list</th>
<th>get</th>
<th>getByUrl</th>
<th>getByPath</th>
<th>listByUser</th>
<th>search</th>
<th>insert</th>
<th>delete</th>
<th>patch</th>
<th>update</th>
</tr>
</thead>
<tbody><tr>
<td>Blogs</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>Posts</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Comments</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>Pages</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>Users</td>
<td>no</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
</tbody></table>
<h2 id="Calling-styles"><a href="#Calling-styles" class="headerlink" title="Calling styles"></a>Calling styles</h2><p>There are several ways to invoke the API:</p>
<ul>
<li>Using REST directly or from JavaScript (no server-side code required)</li>
<li>Using the client libraries.</li>
</ul>
<h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>REST is a style of software architecture that provides a convenient and consistent approach to requesting and modifying data.</p>
<p>The term REST is short for “Representational State Transfer.” In the context of Google APIs, it refers to using HTTP verbs to retrieve and modify representations of data stored by Google.</p>
<p>In a RESTful system, resources are stored in a data store; a client sends a request that the server perform a particular action (such as creating, retrieving, updating, or deleting a resource), and the server performs the action and sends a response, often in the form of a representation of the specified resource.</p>
<p>In Google’s RESTful APIs, the client specifies an action using an HTTP verb such as POST, GET, PUT, or DELETE. It specifies a resource by a globally-unique URI of the following form:</p>
<pre><code>https://www.googleapis.com/apiName/apiVersion/resourcePath?parameters</code></pre><p>Because all API resources have unique HTTP-accessible URIs, REST enables data caching and is optimized to work with the web’s distributed infrastructure.</p>
<p>You may find the method definitions in the HTTP 1.1 standards documentation useful; they include specifications for GET, POST, PUT, and DELETE.</p>
<h3 id="REST-in-the-Blogger-API"><a href="#REST-in-the-Blogger-API" class="headerlink" title="REST in the Blogger API"></a>REST in the Blogger API</h3><p>The supported Blogger operations map directly to REST HTTP verbs, as described in Blogger API operations.</p>
<p>The specific format for Blogger API URIs are:</p>
<pre><code>https://www.googleapis.com/blogger/v3/users/userId
https://www.googleapis.com/blogger/v3/users/self
https://www.googleapis.com/blogger/v3/users/userId/blogs
https://www.googleapis.com/blogger/v3/users/self/blogs
https://www.googleapis.com/blogger/v3/blogs/blogId
https://www.googleapis.com/blogger/v3/blogs/byurl
https://www.googleapis.com/blogger/v3/blogs/blogId/posts
https://www.googleapis.com/blogger/v3/blogs/blogId/posts/bypath
https://www.googleapis.com/blogger/v3/blogs/blogId/posts/search
https://www.googleapis.com/blogger/v3/blogs/blogId/posts/postId
https://www.googleapis.com/blogger/v3/blogs/blogId/posts/postId/comments
https://www.googleapis.com/blogger/v3/blogs/blogId/posts/postId/comments/commentId
https://www.googleapis.com/blogger/v3/blogs/blogId/pages
https://www.googleapis.com/blogger/v3/blogs/blogId/pages/pageId</code></pre><p>The full explanation of URIs used and the results for each supported operation in the API is summarized in the Blogger API Reference document.</p>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>List the blogs that the authenticated user has access rights to:</p>
<pre><code>GET https://www.googleapis.com/blogger/v3/users/self/blogs?key=YOUR-API-KEY</code></pre><p>Get the posts on the code.blogger.com blog, which has blog ID 3213900:</p>
<pre><code>GET https://www.googleapis.com/blogger/v3/blogs/3213900?key=YOUR-API-KEY</code></pre><h3 id="REST-from-JavaScript"><a href="#REST-from-JavaScript" class="headerlink" title="REST from JavaScript"></a>REST from JavaScript</h3><p>You can invoke the Blogger API from JavaScript, using the callback query parameter and by providing a callback function. When the browser loads the script, the callback function is executed and the response is provided to the callback function. This approach allows you to write rich applications that display Blogger data without requiring server side code.</p>
<p>The following example retrieves a post from the code.blogger.com blog, after you replace YOUR-API-KEY with your API key.</p>
<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Blogger API Example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="content"&gt;&lt;/div&gt;
    &lt;script&gt;
      function handleResponse(response) {
        document.getElementById("content").innerHTML += "&lt;h1&gt;" + response.title + "&lt;/h1&gt;" + response.content;
      }
    &lt;/script&gt;
    &lt;script
    src="https://www.googleapis.com/blogger/v3/blogs/3213900/posts/8398240586497962757?callback=handleResponse&amp;key=YOUR-API-KEY"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><h2 id="Data-format"><a href="#Data-format" class="headerlink" title="Data format"></a>Data format</h2><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON (JavaScript Object Notation) is a common, language-independent data format that provides a simple text representation of arbitrary data structures. For more information, see json.org.</p>
<h1 id="Blogger-API-Using-the-API"><a href="#Blogger-API-Using-the-API" class="headerlink" title="Blogger API: Using the API"></a>Blogger API: Using the API</h1><p>The Blogger API enables you to integrate Blogger content with your application by using the REST APIs. Before you begin, you will need to set up authorization.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This document is intended for developers who want to write applications that can interact with the Blogger API. Blogger is a tool for creating websites that allow people to publish their thoughts on an ongoing basis.</p>
<p>If you’re unfamiliar with Blogger concepts, you should read Getting Started before starting to code.</p>
<h3 id="Authorizing-requests-and-identifying-your-application"><a href="#Authorizing-requests-and-identifying-your-application" class="headerlink" title="Authorizing requests and identifying your application"></a>Authorizing requests and identifying your application</h3><p>Every request your application sends to the Blogger APIs needs to identify your application to Google. There are two ways to identify your application: using an OAuth 2.0 token (which also authorizes the request) and/or using the application’s API key. Here’s how to determine which of those options to use:</p>
<p>If the request requires authorization (such as a request for an individual’s private data), then the application must provide an OAuth 2.0 token with the request. The application may also provide the API key, but it doesn’t have to.<br>If the request doesn’t require authorization (such as a request for public data), then the application must provide either the API key or an OAuth 2.0 token, or both—whatever option is most convenient for you.</p>
<h4 id="About-authorization-protocols"><a href="#About-authorization-protocols" class="headerlink" title="About authorization protocols"></a>About authorization protocols</h4><p>Your application must use OAuth 2.0 to authorize requests. No other authorization protocols are supported. If your application uses Google Sign-In, some aspects of authorization are handled for you.</p>
<h4 id="Authorizing-requests-with-OAuth-2-0"><a href="#Authorizing-requests-with-OAuth-2-0" class="headerlink" title="Authorizing requests with OAuth 2.0"></a>Authorizing requests with OAuth 2.0</h4><p>Requests to the Blogger APIs for non-public user data must be authorized by an authenticated user.</p>
<p>This process is facilitated with an OAuth client ID.</p>
<p>GET AN OAUTH CLIENT ID<br>Or create one in the Credentials page.</p>
<p>The details of the authorization process, or “flow,” for OAuth 2.0 vary somewhat depending on what kind of application you’re writing. The following general process applies to all application types:</p>
<p>When your application needs access to user data, it asks Google for a particular scope of access.<br>Google displays a consent screen to the user, asking them to authorize your application to request some of their data.<br>If the user approves, then Google gives your application a short-lived access token.<br>Your application requests user data, attaching the access token to the request.<br>If Google determines that your request and the token are valid, it returns the requested data.<br>Some flows include additional steps, such as using refresh tokens to acquire new access tokens. For detailed information about flows for various types of applications, see Google’s OAuth 2.0 documentation.</p>
<p>Here’s the OAuth 2.0 scope information for the Blogger APIs:</p>
<pre><code>https://www.googleapis.com/auth/blogger</code></pre><p>To request access using OAuth 2.0, your application needs the scope information, as well as information that Google supplies when you register your application (such as the client ID and the client secret).</p>
<p>Tip: The Google APIs client libraries can handle some of the authorization process for you. They are available for a variety of programming languages; check the page with libraries and samples for more details.</p>
<h4 id="Acquiring-and-using-an-API-key"><a href="#Acquiring-and-using-an-API-key" class="headerlink" title="Acquiring and using an API key"></a>Acquiring and using an API key</h4><p>Requests to the Blogger APIs for public data must be accompanied by an identifier, which can be an API key or an access token.</p>
<p>GET A KEY<br>Or create one in the Credentials page.</p>
<p>After you have an API key, your application can append the query parameter key=yourAPIKey to all request URLs.</p>
<p>The API key is safe for embedding in URLs; it doesn’t need any encoding.</p>
<h2 id="Working-with-blogs"><a href="#Working-with-blogs" class="headerlink" title="Working with blogs"></a>Working with blogs</h2><h3 id="Retrieving-a-blog"><a href="#Retrieving-a-blog" class="headerlink" title="Retrieving a blog"></a>Retrieving a blog</h3><p>You can retrieve information for a particular blog by sending an HTTP GET request to the blog’s URI. The URI for a blog has the following format:</p>
<pre><code>https://www.googleapis.com/blogger/v3/blogs/blogId</code></pre><p>Request</p>
<pre><code>GET https://www.googleapis.com/blogger/v3/blogs/2399953?key=YOUR-API-KEY</code></pre><p>A user does not need to be authenticated to retrieve a public blog. The application does not need to include Authorization HTTP header for a public blog request; however, you do need to provide the API key.</p>
<p>Blogger also has private blogs, which require authentication.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and the blog data:</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"blogger#blog"</span><span class="token punctuation">,</span>
  <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"2399953"</span><span class="token punctuation">,</span>
  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Blogger Buzz"</span><span class="token punctuation">,</span>
  <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"The Official Buzz from Blogger at Google"</span><span class="token punctuation">,</span>
  <span class="token property">"published"</span><span class="token operator">:</span> <span class="token string">"2007-04-23T22:17:29.261Z"</span><span class="token punctuation">,</span>
  <span class="token property">"updated"</span><span class="token operator">:</span> <span class="token string">"2011-08-02T06:01:15.941Z"</span><span class="token punctuation">,</span>
  <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://buzz.blogger.com/"</span><span class="token punctuation">,</span>
  <span class="token property">"selfLink"</span><span class="token operator">:</span> <span class="token string">"https://www.googleapis.com/blogger/v3/blogs/2399953"</span><span class="token punctuation">,</span>
  <span class="token property">"posts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"totalItems"</span><span class="token operator">:</span> <span class="token number">494</span><span class="token punctuation">,</span>
    <span class="token property">"selfLink"</span><span class="token operator">:</span> <span class="token string">"https://www.googleapis.com/blogger/v3/blogs/2399953/posts"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"pages"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"totalItems"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token property">"selfLink"</span><span class="token operator">:</span> <span class="token string">"https://www.googleapis.com/blogger/v3/blogs/2399953/pages"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"locale"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"language"</span><span class="token operator">:</span> <span class="token string">"en"</span><span class="token punctuation">,</span>
    <span class="token property">"country"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
    <span class="token property">"variant"</span><span class="token operator">:</span> <span class="token string">""</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="Retrieving-a-blog-by-its-URL"><a href="#Retrieving-a-blog-by-its-URL" class="headerlink" title="Retrieving a blog by its URL"></a>Retrieving a blog by its URL</h3><p>You can retrieve a blog using its URL by sending an HTTP GET request to the following URI with a url parameter:</p>
<pre><code>https://www.googleapis.com/blogger/v3/blogs/byurl?url=blog-url</code></pre><p>Request</p>
<pre><code>https://www.googleapis.com/blogger/v3/blogs/byurl?url=http://code.blogger.com/</code></pre><p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and the full representation of the identified blog:</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
 <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"blogger#blog"</span><span class="token punctuation">,</span>
 <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"3213900"</span><span class="token punctuation">,</span>
 <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Blogger Developers Network"</span><span class="token punctuation">,</span>
 <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"The official Blogger Developers Network weblog."</span><span class="token punctuation">,</span>
 <span class="token property">"published"</span><span class="token operator">:</span> <span class="token string">"2007-02-09T10:13:10-08:00"</span><span class="token punctuation">,</span>
 <span class="token property">"updated"</span><span class="token operator">:</span> <span class="token string">"2012-04-15T19:38:01-07:00"</span><span class="token punctuation">,</span>
 <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://code.blogger.com/"</span><span class="token punctuation">,</span>
 <span class="token property">"selfLink"</span><span class="token operator">:</span> <span class="token string">"https://www.googleapis.com/blogger/v3/blogs/3213900"</span><span class="token punctuation">,</span>
 <span class="token property">"posts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">"totalItems"</span><span class="token operator">:</span> <span class="token number">55</span><span class="token punctuation">,</span>
  <span class="token property">"selfLink"</span><span class="token operator">:</span> <span class="token string">"https://www.googleapis.com/blogger/v3/blogs/3213900/posts"</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token property">"pages"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">"totalItems"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token property">"selfLink"</span><span class="token operator">:</span> <span class="token string">"https://www.googleapis.com/blogger/v3/blogs/3213900/pages"</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token property">"locale"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">"language"</span><span class="token operator">:</span> <span class="token string">"en"</span><span class="token punctuation">,</span>
  <span class="token property">"country"</span><span class="token operator">:</span> <span class="token string">"US"</span><span class="token punctuation">,</span>
  <span class="token property">"variant"</span><span class="token operator">:</span> <span class="token string">""</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="Retrieving-a-user’s-blogs"><a href="#Retrieving-a-user’s-blogs" class="headerlink" title="Retrieving a user’s blogs"></a>Retrieving a user’s blogs</h3><p>You can retrieve a list of a user’s blogs by sending an HTTP GET request to the blogs collection URI:</p>
<pre><code>https://www.googleapis.com/blogger/v3/users/userId/blogs</code></pre><p>Request</p>
<pre><code>GET https://www.googleapis.com/blogger/v3/users/self/blogs</code></pre><p>Authorization: /* OAuth 2.0 token here */<br>Note: The user must be authenticated to list their own blogs, so you must provide the Authorization HTTP header with the GET request.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and the full representation of the list of the user’s blogs:</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"blogger#blogList"</span><span class="token punctuation">,</span>
  <span class="token property">"items"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"blogger#blog"</span><span class="token punctuation">,</span>
      <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"4967929378133675647"</span><span class="token punctuation">,</span>
      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Brett's Test Blawg"</span><span class="token punctuation">,</span>
      <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
      <span class="token property">"published"</span><span class="token operator">:</span> <span class="token string">"2010-10-06T23:33:31.662Z"</span><span class="token punctuation">,</span>
      <span class="token property">"updated"</span><span class="token operator">:</span> <span class="token string">"2011-08-08T06:50:02.005Z"</span><span class="token punctuation">,</span>
      <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://brettmorgan-test-blawg.blogspot.com/"</span><span class="token punctuation">,</span>
      <span class="token property">"selfLink"</span><span class="token operator">:</span> <span class="token string">"https://www.googleapis.com/blogger/v3/blogs/4967929378133675647"</span><span class="token punctuation">,</span>
      <span class="token property">"posts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"totalItems"</span><span class="token operator">:</span> <span class="token number">13</span><span class="token punctuation">,</span>
        <span class="token property">"selfLink"</span><span class="token operator">:</span> <span class="token string">"https://www.googleapis.com/blogger/v3/blogs/4967929378133675647/posts"</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token property">"pages"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"totalItems"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
        <span class="token property">"selfLink"</span><span class="token operator">:</span> <span class="token string">"https://www.googleapis.com/blogger/v3/blogs/4967929378133675647/pages"</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token property">"locale"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"language"</span><span class="token operator">:</span> <span class="token string">"en"</span><span class="token punctuation">,</span>
        <span class="token property">"country"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
        <span class="token property">"variant"</span><span class="token operator">:</span> <span class="token string">""</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="Working-with-posts"><a href="#Working-with-posts" class="headerlink" title="Working with posts"></a>Working with posts</h2><h3 id="Retrieving-posts-from-a-blog"><a href="#Retrieving-posts-from-a-blog" class="headerlink" title="Retrieving posts from a blog"></a>Retrieving posts from a blog</h3><p>You can retrieve a list of posts from a given blog by sending a GET request to the posts collection URI. The URI for a posts collection has the following format:</p>
<pre><code>https://www.googleapis.com/blogger/v3/blogs/blogId/posts</code></pre><p>Request</p>
<p>Here is an example:</p>
<pre><code>GET https://www.googleapis.com/blogger/v3/blogs/2399953/posts?key=YOUR-API-KEY</code></pre><p>A user does not need to be authenticated to retrieve a public blog. The application does not need to include Authorization HTTP header for a public blog request; however, you do need to provide the API key.</p>
<p>Blogger also has private blogs, which require authentication.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and the list of posts:</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"blogger#postList"</span><span class="token punctuation">,</span>
  <span class="token property">"nextPageToken"</span><span class="token operator">:</span> <span class="token string">"CgkIChiAkceVjiYQ0b2SAQ"</span><span class="token punctuation">,</span>
  <span class="token property">"prevPageToken"</span><span class="token operator">:</span> <span class="token string">"CgkIChDBwrK3mCYQ0b2SAQ"</span><span class="token punctuation">,</span>
  <span class="token property">"items"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"blogger#post"</span><span class="token punctuation">,</span>
      <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"7706273476706534553"</span><span class="token punctuation">,</span>
      <span class="token property">"blog"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"2399953"</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token property">"published"</span><span class="token operator">:</span> <span class="token string">"2011-08-01T19:58:00.000Z"</span><span class="token punctuation">,</span>
      <span class="token property">"updated"</span><span class="token operator">:</span> <span class="token string">"2011-08-01T19:58:51.947Z"</span><span class="token punctuation">,</span>
      <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://buzz.blogger.com/2011/08/latest-updates-august-1st.html"</span><span class="token punctuation">,</span>
      <span class="token property">"selfLink"</span><span class="token operator">:</span> <span class="token string">"https://www.googleapis.com/blogger/v3/blogs/2399953/posts/7706273476706534553"</span><span class="token punctuation">,</span>
      <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"Latest updates, August 1st"</span><span class="token punctuation">,</span>
      <span class="token property">"content"</span><span class="token operator">:</span> <span class="token string">"elided for readability"</span><span class="token punctuation">,</span>
      <span class="token property">"author"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"401465483996"</span><span class="token punctuation">,</span>
        <span class="token property">"displayName"</span><span class="token operator">:</span> <span class="token string">"Brett Wiltshire"</span><span class="token punctuation">,</span>
        <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://www.blogger.com/profile/01430672582309320414"</span><span class="token punctuation">,</span>
        <span class="token property">"image"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://4.bp.blogspot.com/_YA50adQ-7vQ/S1gfR_6ufpI/AAAAAAAAAAk/1ErJGgRWZDg/S45/brett.png"</span>
         <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token property">"replies"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"totalItems"</span><span class="token operator">:</span> <span class="token string">"0"</span><span class="token punctuation">,</span>
        <span class="token property">"selfLink"</span><span class="token operator">:</span> <span class="token string">"https://www.googleapis.com/blogger/v3/blogs/2399953/posts/7706273476706534553/comments"</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"blogger#post"</span><span class="token punctuation">,</span>
      <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"6069922188027612413"</span><span class="token punctuation">,</span>
      elided for readability
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="Retrieving-a-specific-post"><a href="#Retrieving-a-specific-post" class="headerlink" title="Retrieving a specific post"></a>Retrieving a specific post</h3><p>You can retrieve a specific post from a blog by sending a GET request to the posts resource URI. The URI for a posts resource has the following format:</p>
<pre><code>https://www.googleapis.com/blogger/v3/blogs/blogId/posts/postId</code></pre><p>Request</p>
<pre><code>GET https://www.googleapis.com/blogger/v3/blogs/2399953/posts/7706273476706534553?key=YOUR-API-KEY</code></pre><p>A user does not need to be authenticated to retrieve a public blog. The application does not need to include Authorization HTTP header for a public blog request; however, you do need to provide the API key.</p>
<p>Blogger also has private blogs, which require authentication.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and the contents of the post:</p>
<pre><code>{
  "kind": "blogger#post",
  "id": "7706273476706534553",
  "blog": {
    "id": "2399953"
  },
  "published": "2011-08-01T19:58:00.000Z",
  "updated": "2011-08-01T19:58:51.947Z",
  "url": "http://buzz.blogger.com/2011/08/latest-updates-august-1st.html",
  "selfLink": "https://www.googleapis.com/blogger/v3/blogs/2399953/posts/7706273476706534553",
  "title": "Latest updates, August 1st",
  "content": "elided for readability",
  "author": {
    "id": "401465483996",
    "displayName": "Brett Wiltshire",
    "url": "http://www.blogger.com/profile/01430672582309320414",
    "image": {
      "url": "http://4.bp.blogspot.com/_YA50adQ-7vQ/S1gfR_6ufpI/AAAAAAAAAAk/1ErJGgRWZDg/S45/brett.png"
    }
  },
  "replies": {
    "totalItems": "0",
    "selfLink": "https://www.googleapis.com/blogger/v3/blogs/2399953/posts/7706273476706534553/comments"
  }
}</code></pre><h3 id="Searching-for-a-post"><a href="#Searching-for-a-post" class="headerlink" title="Searching for a post"></a>Searching for a post</h3><p>You can search for posts from a blog by sending a GET request to the post search URI with the q search query parameter:</p>
<pre><code>https://www.googleapis.com/blogger/v3/blogs/blogId/posts/search?q=query terms</code></pre><p>Request</p>
<pre><code>GET https://www.googleapis.com/blogger/v3/blogs/3213900/posts/search?q=documentation&amp;key=YOUR-API-KEY</code></pre><p>A user does not need to be authenticated to retrieve a public blog. The application does not need to include Authorization HTTP header for a public blog request; however, you do need to provide the API key.</p>
<p>Blogger also has private blogs, which require authentication.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and the contents of the post:</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"blogger#postList"</span><span class="token punctuation">,</span>
  <span class="token property">"nextPageToken"</span><span class="token operator">:</span> <span class="token string">"CgkIChiAj86CpB8QzJTEAQ"</span><span class="token punctuation">,</span>
  <span class="token property">"prevPageToken"</span><span class="token operator">:</span> <span class="token string">"CgkIChDBq5v24yYQzJTEAQ"</span><span class="token punctuation">,</span>
  <span class="token property">"items"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"blogger#post"</span><span class="token punctuation">,</span>
    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"1387873546480002228"</span><span class="token punctuation">,</span>
    <span class="token property">"blog"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"3213900"</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token property">"published"</span><span class="token operator">:</span> <span class="token string">"2012-03-23T01:58:00-07:00"</span><span class="token punctuation">,</span>
    <span class="token property">"updated"</span><span class="token operator">:</span> <span class="token string">"2012-03-23T01:58:12-07:00"</span><span class="token punctuation">,</span>
    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://code.blogger.com/2012/03/blogger-documentation-has-moved-to.html"</span><span class="token punctuation">,</span>
    <span class="token property">"selfLink"</span><span class="token operator">:</span> <span class="token string">"https://www.googleapis.com/blogger/v3/blogs/3213900/posts/1387873546480002228"</span><span class="token punctuation">,</span>
    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"Blogger Documentation has moved to developers.google.com"</span><span class="token punctuation">,</span>
    <span class="token property">"content"</span><span class="token operator">:</span> <span class="token string">"content elided for readability"</span><span class="token punctuation">,</span>
    <span class="token property">"author"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"16258312240222542576"</span><span class="token punctuation">,</span>
      <span class="token property">"displayName"</span><span class="token operator">:</span> <span class="token string">"Brett Morgan"</span><span class="token punctuation">,</span>
      <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://www.blogger.com/profile/16258312240222542576"</span><span class="token punctuation">,</span>
      <span class="token property">"image"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://resources.blogblog.com/img/b16-rounded.gif"</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token property">"replies"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">"totalItems"</span><span class="token operator">:</span> <span class="token string">"0"</span><span class="token punctuation">,</span>
      <span class="token property">"selfLink"</span><span class="token operator">:</span> <span class="token string">"https://www.googleapis.com/blogger/v3/blogs/3213900/posts/1387873546480002228/comments"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  ...
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="Adding-a-post"><a href="#Adding-a-post" class="headerlink" title="Adding a post"></a>Adding a post</h3><p>You can add a post for a blog by sending a POST request to the post collection URI with a post JSON body:</p>
<pre><code>https://www.googleapis.com/blogger/v3/blogs/blogId/posts/</code></pre><p>Request</p>
<pre><code>POST https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/</code></pre><p>Authorization: /* OAuth 2.0 token here */<br>Content-Type: application/json</p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"blogger#post"</span><span class="token punctuation">,</span>
  <span class="token property">"blog"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"8070105920543249955"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"A new post"</span><span class="token punctuation">,</span>
  <span class="token property">"content"</span><span class="token operator">:</span> <span class="token string">"With &lt;b>exciting&lt;/b> content..."</span>
<span class="token punctuation">}</span></code></pre>
<p>You must be authenticated to create a post.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and the contents of the post:</p>
<p>{<br> “kind”: “blogger#post”,<br> “id”: “6819100329896798058”,<br> “blog”: {<br>  “id”: “8070105920543249955”<br> },<br> “published”: “2012-05-20T20:08:00-07:00”,<br> “updated”: “2012-05-20T20:08:35-07:00”,<br> “url”: “<a href="http://brettmorgan-test2.blogspot.com/2012/05/new-post.html&quot;" target="_blank" rel="noopener">http://brettmorgan-test2.blogspot.com/2012/05/new-post.html"</a>,<br> “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/6819100329896798058&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/6819100329896798058"</a>,<br> “title”: “A new post”,<br> “content”: “With <b>exciting</b> content…”,<br> “author”: {<br>  “id”: “16258312240222542576”,<br>  “displayName”: “Brett Morgan”,<br>  “url”: “<a href="http://www.blogger.com/profile/16258312240222542576&quot;" target="_blank" rel="noopener">http://www.blogger.com/profile/16258312240222542576"</a>,<br>  “image”: {<br>   “url”: “<a href="https://resources.blogblog.com/img/b16-rounded.gif&quot;" target="_blank" rel="noopener">https://resources.blogblog.com/img/b16-rounded.gif"</a><br>  }<br> },<br> “replies”: {<br>  “totalItems”: “0”,<br>  “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/6819100329896798058/comments&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/6819100329896798058/comments"</a><br> }<br>}<br>Deleting a post<br>You can delete a post for a blog by sending a DELETE request to the post resource URI:</p>
<p><a href="https://www.googleapis.com/blogger/v3/blogs/blogId/posts/postId" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/blogId/posts/postId</a><br>Request<br>Here is an example:</p>
<p>DELETE <a href="https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/6819100329896798058" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/6819100329896798058</a><br>Authorization: /* OAuth 2.0 token here */<br>You must be authenticated to delete a post.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code.</p>
<p>Retrieving a post by its path<br>You can retrieve a post from a blog by sending a GET request to the posts bypath URI with a path parameter. The URI for a posts by path request has the following format:</p>
<p><a href="https://www.googleapis.com/blogger/v3/blogs/blogId/posts/bypath?path=post-path" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/blogId/posts/bypath?path=post-path</a><br>Request<br><a href="https://www.googleapis.com/blogger/v3/blogs/2399953/posts/bypath?path=/2011/08/latest-updates-august-1st.html&amp;key=YOUR-API-KEY" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/2399953/posts/bypath?path=/2011/08/latest-updates-august-1st.html&amp;key=YOUR-API-KEY</a><br>A user does not need to be authenticated to retrieve a public blog. The application does not need to include Authorization HTTP header for a public blog request; however, you do need to provide the API key.</p>
<p>Blogger also has private blogs, which require authentication.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and the contents of the post:</p>
<p>{<br>  “kind”: “blogger#post”,<br>  “id”: “7706273476706534553”,<br>  “blog”: {<br>    “id”: “2399953”<br>  },<br>  “published”: “2011-08-01T19:58:00.000Z”,<br>  “updated”: “2011-08-01T19:58:51.947Z”,<br>  “url”: “<a href="http://buzz.blogger.com/2011/08/latest-updates-august-1st.html&quot;" target="_blank" rel="noopener">http://buzz.blogger.com/2011/08/latest-updates-august-1st.html"</a>,<br>  “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/blogs/2399953/posts/7706273476706534553&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/2399953/posts/7706273476706534553"</a>,<br>  “title”: “Latest updates, August 1st”,<br>  “content”: “elided for readability”,<br>  “author”: {<br>    “id”: “401465483996”,<br>    “displayName”: “Brett Wiltshire”,<br>    “url”: “<a href="http://www.blogger.com/profile/01430672582309320414&quot;" target="_blank" rel="noopener">http://www.blogger.com/profile/01430672582309320414"</a>,<br>    “image”: {<br>      “url”: “<a href="http://4.bp.blogspot.com/_YA50adQ-7vQ/S1gfR_6ufpI/AAAAAAAAAAk/1ErJGgRWZDg/S45/brett.png&quot;" target="_blank" rel="noopener">http://4.bp.blogspot.com/_YA50adQ-7vQ/S1gfR_6ufpI/AAAAAAAAAAk/1ErJGgRWZDg/S45/brett.png"</a><br>    }<br>  },<br>  “replies”: {<br>    “totalItems”: “0”,<br>    “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/blogs/2399953/posts/7706273476706534553/comments&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/2399953/posts/7706273476706534553/comments"</a><br>  }<br>}<br>Updating a post<br>You can update a post for a blog by sending a PUT request to the post resource URI with a post JSON body:</p>
<p><a href="https://www.googleapis.com/blogger/v3/blogs/blogId/posts/postId" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/blogId/posts/postId</a><br>Request<br>PUT <a href="https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/3445355871727114160" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/3445355871727114160</a><br>Authorization: /* OAuth 2.0 token here */<br>Content-Type: application/json</p>
<p>{<br> “kind”: “blogger#post”,<br> “id”: “3445355871727114160”,<br> “blog”: {<br>  “id”: “8070105920543249955”<br> },<br> “url”: “<a href="http://brettmorgan-test2.blogspot.com/2012/05/new-post_20.html&quot;" target="_blank" rel="noopener">http://brettmorgan-test2.blogspot.com/2012/05/new-post_20.html"</a>,<br> “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/3445355871727114160&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/3445355871727114160"</a>,<br> “title”: “An updated post”,<br> “content”: “With really <b>exciting</b> content…”<br>}<br>You must be authenticated to update a post.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and the contents of the post:</p>
<p>{<br> “kind”: “blogger#post”,<br> “id”: “6819100329896798058”,<br> “blog”: {<br>  “id”: “8070105920543249955”<br> },<br> “published”: “2012-05-20T20:08:00-07:00”,<br> “updated”: “2012-05-20T20:08:35-07:00”,<br> “url”: “<a href="http://brettmorgan-test2.blogspot.com/2012/05/new-post.html&quot;" target="_blank" rel="noopener">http://brettmorgan-test2.blogspot.com/2012/05/new-post.html"</a>,<br> “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/6819100329896798058&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/6819100329896798058"</a>,<br> “title”: “An updated post”,<br> “content”: “With really <b>exciting</b> content…”,<br> “author”: {<br>  “id”: “16258312240222542576”,<br>  “displayName”: “Brett Morgan”,<br>  “url”: “<a href="http://www.blogger.com/profile/16258312240222542576&quot;" target="_blank" rel="noopener">http://www.blogger.com/profile/16258312240222542576"</a>,<br>  “image”: {<br>   “url”: “<a href="https://resources.blogblog.com/img/b16-rounded.gif&quot;" target="_blank" rel="noopener">https://resources.blogblog.com/img/b16-rounded.gif"</a><br>  }<br> },<br> “replies”: {<br>  “totalItems”: “0”,<br>  “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/6819100329896798058/comments&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/6819100329896798058/comments"</a><br> }<br>}<br>Updating A post with patch semantics<br>You can update a post with patch semantics by sending a PATCH request to the post resource URI with a post JSON body:</p>
<p><a href="https://www.googleapis.com/blogger/v3/blogs/blogId/posts/postId" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/blogId/posts/postId</a><br>Request<br>Here is an example:</p>
<p>PATCH <a href="https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/3445355871727114160" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/3445355871727114160</a><br>Authorization: /* OAuth 2.0 token here */<br>Content-Type: application/json</p>
<p>{<br> “content”: “With absolutely <b>fabulous</b> content…”<br>}<br>You must be authenticated to update a post.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and the contents of the post:</p>
<p>{<br> “kind”: “blogger#post”,<br> “id”: “6819100329896798058”,<br> “blog”: {<br>  “id”: “8070105920543249955”<br> },<br> “published”: “2012-05-20T20:08:00-07:00”,<br> “updated”: “2012-05-20T20:08:35-07:00”,<br> “url”: “<a href="http://brettmorgan-test2.blogspot.com/2012/05/new-post.html&quot;" target="_blank" rel="noopener">http://brettmorgan-test2.blogspot.com/2012/05/new-post.html"</a>,<br> “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/6819100329896798058&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/6819100329896798058"</a>,<br> “title”: “An updated post”,<br> “content”: “With absolutely <b>fabulous</b> content…”,<br> “author”: {<br>  “id”: “16258312240222542576”,<br>  “displayName”: “Brett Morgan”,<br>  “url”: “<a href="http://www.blogger.com/profile/16258312240222542576&quot;" target="_blank" rel="noopener">http://www.blogger.com/profile/16258312240222542576"</a>,<br>  “image”: {<br>   “url”: “<a href="https://resources.blogblog.com/img/b16-rounded.gif&quot;" target="_blank" rel="noopener">https://resources.blogblog.com/img/b16-rounded.gif"</a><br>  }<br> },<br> “replies”: {<br>  “totalItems”: “0”,<br>  “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/6819100329896798058/comments&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/8070105920543249955/posts/6819100329896798058/comments"</a><br> }<br>}<br>Working with comments<br>Retrieving comments for a post<br>You can retrieve a list of comments for a post by sending a GET request to the comments collection URI. The URI for a comments collection has the following format:</p>
<p><a href="https://www.googleapis.com/blogger/v3/blogs/blogId/posts/postId/comments" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/blogId/posts/postId/comments</a><br>Request<br>GET <a href="https://www.googleapis.com/blogger/v3/blogs/2399953/posts/6069922188027612413/comments?key=YOUR-API-KEY" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/2399953/posts/6069922188027612413/comments?key=YOUR-API-KEY</a><br>“A user does not need to be authenticated to retrieve a public blog. The application does not need to include Authorization HTTP header for a public blog request; however, you do need to provide the API key.</p>
<p>Blogger also has private blogs, which require authentication.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and the list of comments:</p>
<p>{<br>  “kind”: “blogger#commentList”,<br>  “nextPageToken”: “CgkIFBDwjvDXlyYQ0b2SARj9mZe9n8KsnlQ”,<br>  “prevPageToken”: “CgkIFBisvMGRlyYQ0b2SARj9mZe9n8KsnlQ”,<br>  “items”: [<br>    {<br>       “kind”: “blogger#comment”,<br>       “id”: “9200761938824362519”,<br>       “post”: {<br>         “id”: “6069922188027612413”<br>       },<br>       “blog”: {<br>         “id”: “2399953”<br>       },<br>       “published”: “2011-07-28T19:19:57.740Z”,<br>       “updated”: “2011-07-28T21:29:42.015Z”,<br>       “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/blogs/2399953/posts/6069922188027612413/comments/9200761938824362519&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/2399953/posts/6069922188027612413/comments/9200761938824362519"</a>,<br>       “content”: “elided”,<br>       “author”: {<br>         “id”: “530579030283”,<br>         “displayName”: “elided”,<br>         “url”: “elided”,<br>         “image”: {<br>           “url”: “elided”<br>         }<br>       }<br>    },<br>    {<br>      “kind”: “blogger#comment”,<br>      “id”: “400101178920857170”,<br>      elided for readability<br>    }<br>  ]<br>}<br>Retrieving a specific comment<br>You can retrieve a specific comment from a post by sending a GET request to the comments resource URI. The URI for a comments resource has the following format:</p>
<p><a href="https://www.googleapis.com/blogger/v3/blogs/blogId/posts/postId/comments/commentId" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/blogId/posts/postId/comments/commentId</a><br>Request<br>GET <a href="https://www.googleapis.com/blogger/v3/blogs/2399953/posts/6069922188027612413/comments/9200761938824362519?key=YOUR-API-KEY" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/2399953/posts/6069922188027612413/comments/9200761938824362519?key=YOUR-API-KEY</a><br>“A user does not need to be authenticated to retrieve a public blog. The application does not need to include Authorization HTTP header for a public blog request; however, you do need to provide the API key.</p>
<p>Blogger also has private blogs, which require authentication.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and the comment data:</p>
<p>{<br>  “kind”: “blogger#comment”,<br>  “id”: “9200761938824362519”,<br>  “post”: {<br>    “id”: “6069922188027612413”<br>  },<br>  “blog”: {<br>    “id”: “2399953”<br>  },<br>  “published”: “2011-07-28T19:19:57.740Z”,<br>  “updated”: “2011-07-28T21:29:42.015Z”,<br>  “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/blogs/2399953/posts/6069922188027612413/comments/9200761938824362519&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/2399953/posts/6069922188027612413/comments/9200761938824362519"</a>,<br>  “content”: “elided”,<br>  “author”: {<br>    “id”: “530579030283”,<br>    “displayName”: “elided”,<br>    “url”: “elided”,<br>    “image”: {<br>      “url”: “elided”<br>    }<br>  }<br>}<br>Working with pages<br>Retrieving pages for a blog<br>You can retrieve a list of pages for a blog by sending a GET request to the pages collection URI. The URI for a pages collection has the following format:</p>
<p><a href="https://www.googleapis.com/blogger/v3/blogs/blogId/pages" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/blogId/pages</a><br>Request<br>GET <a href="https://www.googleapis.com/blogger/v3/blogs/4967929378133675647/pages?key=YOUR-API-KEY" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/4967929378133675647/pages?key=YOUR-API-KEY</a><br>“A user does not need to be authenticated to retrieve a public blog. The application does not need to include Authorization HTTP header for a public blog request; however, you do need to provide the API key.</p>
<p>Blogger also has private blogs, which require authentication.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and the list of pages:</p>
<p>{<br>  “kind”: “blogger#pageList”,<br>  “items”: [<br>    {<br>      “kind”: “blogger#page”,<br>      “id”: “273541696466681878”,<br>      “blog”: {<br>        “id”: “4967929378133675647”<br>      },<br>      “published”: “2011-07-14T16:16:00.000Z”,<br>      “updated”: “2011-07-14T16:16:23.602Z”,<br>      “url”: “<a href="http://brettmorgan-test-blawg.blogspot.com/p/static-content.html&quot;" target="_blank" rel="noopener">http://brettmorgan-test-blawg.blogspot.com/p/static-content.html"</a>,<br>      “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/blogs/4967929378133675647/pages/273541696466681878&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/4967929378133675647/pages/273541696466681878"</a>,<br>      “title”: “Static Content”,<br>      “content”: “elided for readability”,<br>      “author”: {<br>        “id”: “901569848744”,<br>        “displayName”: “brett”,<br>        “url”: “<a href="http://www.blogger.com/profile/16258312240222542576&quot;" target="_blank" rel="noopener">http://www.blogger.com/profile/16258312240222542576"</a>,<br>        “image”: {<br>          “url”: “<a href="https://resources.blogblog.com/img/b16-rounded.gif&quot;" target="_blank" rel="noopener">https://resources.blogblog.com/img/b16-rounded.gif"</a><br>        }<br>      }<br>    }<br>  ]<br>}<br>Retrieving a specific page<br>You can retrieve a specific page from a blog by sending a GET request to the pages resource URI. The URI for a pages Resource has the following format:</p>
<p><a href="https://www.googleapis.com/blogger/v3/blogs/blogId/pages/pageId" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/blogId/pages/pageId</a><br>Request<br>GET <a href="https://www.googleapis.com/blogger/v3/blogs/4967929378133675647/pages/273541696466681878?key=YOUR-API-KEY" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/4967929378133675647/pages/273541696466681878?key=YOUR-API-KEY</a><br>“A user does not need to be authenticated to retrieve a public blog. The application does not need to include Authorization HTTP header for a public blog request; however, you do need to provide the API key.</p>
<p>Blogger also has private blogs, which require authentication.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and the page data:</p>
<p>{<br>  “kind”: “blogger#page”,<br>  “id”: “273541696466681878”,<br>  “blog”: {<br>    “id”: “4967929378133675647”<br>  },<br>  “published”: “2011-07-14T16:16:00.000Z”,<br>  “updated”: “2011-07-14T16:16:23.602Z”,<br>  “url”: “<a href="http://brettmorgan-test-blawg.blogspot.com/p/static-content.html&quot;" target="_blank" rel="noopener">http://brettmorgan-test-blawg.blogspot.com/p/static-content.html"</a>,<br>  “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/blogs/4967929378133675647/pages/273541696466681878&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/blogs/4967929378133675647/pages/273541696466681878"</a>,<br>  “title”: “Static Content”,<br>  “content”: “elided for readability”,<br>  “author”: {<br>    “id”: “901569848744”,<br>    “displayName”: “brett”,<br>    “url”: “<a href="http://www.blogger.com/profile/16258312240222542576&quot;" target="_blank" rel="noopener">http://www.blogger.com/profile/16258312240222542576"</a>,<br>    “image”: {<br>      “url”: “<a href="https://resources.blogblog.com/img/b16-rounded.gif&quot;" target="_blank" rel="noopener">https://resources.blogblog.com/img/b16-rounded.gif"</a><br>    }<br>  }<br>}<br>Working with users<br>Retrieving a user<br>You can retrieve a user’s information by sending an HTTP GET request to the users resource URI:</p>
<p><a href="https://www.googleapis.com/blogger/v3/users/userId" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/users/userId</a><br>Request<br>GET <a href="https://www.googleapis.com/blogger/v3/users/self" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/users/self</a><br>Authorization: /* OAuth 2.0 token here */<br>Note: The user must be authenticated to list their own information, so you must provide the Authorization HTTP header with the GET request.</p>
<p>Response<br>If the request succeeds, the server responds with an HTTP 200 OK status code and a link to a list of the user’s blogs:</p>
<p>{<br>  “kind”: “blogger#user”,<br>  “id”: “901569848744”,<br>  “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/users/901569848744&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/users/901569848744"</a>,<br>  “blogs”: {<br>    “selfLink”: “<a href="https://www.googleapis.com/blogger/v3/users/901569848744/blogs&quot;" target="_blank" rel="noopener">https://www.googleapis.com/blogger/v3/users/901569848744/blogs"</a><br>  }<br>}<br>Standard query parameters<br>The following query parameters can be used with all methods and all resources in the Blogger APIs.</p>
<p>Query parameters that apply to all Blogger APIs operations are shown in the table below.</p>
<p>Notes (on API keys and auth tokens):</p>
<p>The key parameter is required with every request, unless you provide an OAuth 2.0 token with the request.<br>You must send an authorization token with every request that requires an OAuth scope. OAuth 2.0 is the only supported authorization protocol.<br>You can provide an OAuth 2.0 token with any request in one of two ways:<br>Using the access_token query parameter like this: ?access_token=oauth2-token<br>Using the HTTP Authorization header like this: Authorization: Bearer oauth2-token<br>All parameters are optional except where noted.</p>
<p>Parameter    Meaning    Notes<br>access_token    OAuth 2.0 token for the current user.<br>One possible way to provide an OAuth 2.0 token.<br>callback    Callback function.<br>Name of the JavaScript callback function that handles the response.<br>Used in JavaScript JSON-P requests.<br>fields    Selector specifying a subset of fields to include in the response.<br>For more information, see the partial response section in the Performance Tips document.<br>Use for better performance.<br>key    API key. (REQUIRED*)<br>*Required unless you provide an OAuth 2.0 token.<br>Your API key identifies your project and provides you with API access, quota, and reports.<br>Obtain your project’s API key from the Google API Console.<br>prettyPrint<br>Returns response with indentations and line breaks.</p>
<p>Returns the response in a human-readable format if true.<br>Default value: true.<br>When this is false, it can reduce the response payload size, which might lead to better performance in some environments.<br>quotaUser    Alternative to userIp.<br>Lets you enforce per-user quotas from a server-side application even in cases when the user’s IP address is unknown. This can occur, for example, with applications that run cron jobs on App Engine on a user’s behalf.<br>You can choose any arbitrary string that uniquely identifies a user, but it is limited to 40 characters.<br>Overrides userIp if both are provided.<br>Learn more about Capping API usage.<br>userIp    IP address of the end user for whom the API call is being made.<br>Lets you enforce per-user quotas when calling the API from a server-side application.<br>Learn more about Capping API usage.<br>Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code samples are licensed under the Apache 2.0 License. For details, see our Site Policies. Java is a registered trademark of Oracle and/or its affiliates.</p>
<p>Blogger JSON API: Performance Tips<br>This document covers some techniques you can use to improve the performance of your application. In some cases, examples from other APIs or generic APIs are used to illustrate the ideas presented. However, the same concepts are applicable to the Blogger APIs.</p>
<p>Using gzip<br>An easy and convenient way to reduce the bandwidth needed for each request is to enable gzip compression. Although this requires additional CPU time to uncompress the results, the trade-off with network costs usually makes it very worthwhile.</p>
<p>In order to receive a gzip-encoded response you must do two things: Set an Accept-Encoding header, and modify your user agent to contain the string gzip. Here is an example of properly formed HTTP headers for enabling gzip compression:</p>
<p>Accept-Encoding: gzip<br>User-Agent: my program (gzip)<br>Working with partial resources<br>Another way to improve the performance of your API calls is by sending and receiving only the portion of the data that you’re interested in. This lets your application avoid transferring, parsing, and storing unneeded fields, so it can use resources including network, CPU, and memory more efficiently.</p>
<p>There are two types of partial requests:</p>
<p>Partial response: A request where you specify which fields to include in the response (use the fields request parameter).<br>Patch: An update request where you send only the fields you want to change (use the PATCH HTTP verb).<br>More details on making partial requests are provided in the following sections.</p>
<p>Partial response<br>By default, the server sends back the full representation of a resource after processing requests. For better performance, you can ask the server to send only the fields you really need and get a partial response instead.</p>
<p>To request a partial response, use the fields request parameter to specify the fields you want returned. You can use this parameter with any request that returns response data.</p>
<p>Note that the fields parameter only affects the response data; it does not affect the data that you need to send, if any. To reduce the amount of data you send when modifying resources, use a patch request.</p>
<p>Example<br>The following example shows the use of the fields parameter with a generic (fictional) “Demo” API.</p>
<p>Simple request: This HTTP GET request omits the fields parameter and returns the full resource.</p>
<p><a href="https://www.googleapis.com/demo/v1?key=YOUR-API-KEY" target="_blank" rel="noopener">https://www.googleapis.com/demo/v1?key=YOUR-API-KEY</a><br>Full resource response: The full resource data includes the following fields, along with many others that have been omitted for brevity.</p>
<p>{<br>  “kind”: “demo”,<br>  …<br>  “items”: [<br>  {<br>    “title”: “First title”,<br>    “comment”: “First comment.”,<br>    “characteristics”: {<br>      “length”: “short”,<br>      “accuracy”: “high”,<br>      “followers”: [“Jo”, “Will”],<br>    },<br>    “status”: “active”,<br>    …<br>  },<br>  {<br>    “title”: “Second title”,<br>    “comment”: “Second comment.”,<br>    “characteristics”: {<br>      “length”: “long”,<br>      “accuracy”: “medium”<br>      “followers”: [ ],<br>    },<br>    “status”: “pending”,<br>    …<br>  },<br>  …<br>  ]<br>}<br>Request for a partial response: The following request for this same resource uses the fields parameter to significantly reduce the amount of data returned.</p>
<p><a href="https://www.googleapis.com/demo/v1?key=YOUR-API-KEY&amp;fields=kind,items(title,characteristics/length)" target="_blank" rel="noopener">https://www.googleapis.com/demo/v1?key=YOUR-API-KEY&amp;fields=kind,items(title,characteristics/length)</a><br>Partial response: In response to the request above, the server sends back a response that contains only the kind information along with a pared-down items array that includes only HTML title and length characteristic information in each item.</p>
<p>200 OK</p>
<p>{<br>  “kind”: “demo”,<br>  “items”: [<br>  {<br>    “title”: “First title”,<br>    “characteristics”: {<br>      “length”: “short”<br>    }<br>  },<br>  {<br>    “title”: “Second title”,<br>    “characteristics”: {<br>      “length”: “long”<br>    }<br>  },<br>  …<br>  ]<br>Note that the response is a JSON object that includes only the selected fields and their enclosing parent objects.</p>
<p>Details on how to format the fields parameter is covered next, followed by more details about what exactly gets returned in the response.</p>
<p>Fields parameter syntax summary<br>The format of the fields request parameter value is loosely based on XPath syntax. The supported syntax is summarized below, and additional examples are provided in the following section.</p>
<p>Use a comma-separated list to select multiple fields.<br>Use a/b to select a field b that is nested within field a; use a/b/c to select a field c nested within b.<br>Exception: For API responses that use “data” wrappers, where the response is nested within a data object that looks like data: { … }, do not include “data” in the fields specification. Including the data object with a fields specification like data/a/b causes an error. Instead, just use a fields specification like a/b.</p>
<p>Use a sub-selector to request a set of specific sub-fields of arrays or objects by placing expressions in parentheses “( )”.<br>For example: fields=items(id,author/email) returns only the item ID and author’s email for each element in the items array. You can also specify a single sub-field, where fields=items(id) is equivalent to fields=items/id.</p>
<p>Use wildcards in field selections, if needed.<br>For example: fields=items/pagemap/* selects all objects in a pagemap.</p>
<p>More examples of using the fields parameter<br>The examples below include descriptions of how the fields parameter value affects the response.</p>
<p>Note: As with all query parameter values, the fields parameter value must be URL encoded. For better readability, the examples in this document omit the encoding.</p>
<p>Identify the fields you want returned, or make field selections.<br>The fields request parameter value is a comma-separated list of fields, and each field is specified relative to the root of the response. Thus, if you are performing a list operation, the response is a collection, and it generally includes an array of resources. If you are performing an operation that returns a single resource, fields are specified relative to that resource. If the field you select is (or is part of) an array, the server returns the selected portion of all elements in the array.</p>
<p>Here are some collection-level examples:<br>Examples    Effect<br>items    Returns all elements in the items array, including all fields in each element, but no other fields.<br>etag,items    Returns both the etag field and all elements in the items array.<br>items/title    Returns only the title field for all elements in the items array.</p>
<p>Whenever a nested field is returned, the response includes the enclosing parent objects. The parent fields do not include any other child fields unless they are also selected explicitly.<br>context/facets/label    Returns only the label field for all members of the facets array, which is itself nested under the context object.<br>items/pagemap/*/title    For each element in the items array, returns only the title field (if present) of all objects that are children of pagemap.</p>
<p>Here are some resource-level examples:<br>Examples    Effect<br>title    Returns the title field of the requested resource.<br>author/uri    Returns the uri sub-field of the author object in the requested resource.<br>links/*/href<br>Returns the href field of all objects that are children of links.<br>Request only parts of specific fields using sub-selections.<br>By default, if your request specifies particular fields, the server returns the objects or array elements in their entirety. You can specify a response that includes only certain sub-fields. You do this using “( )” sub-selection syntax, as in the example below.<br>Example    Effect<br>items(title,author/uri)    Returns only the values of the title and author’s uri for each element in the items array.<br>Handling partial responses<br>After a server processes a valid request that includes the fields query parameter, it sends back an HTTP 200 OK status code, along with the requested data. If the fields query parameter has an error or is otherwise invalid, the server returns an HTTP 400 Bad Request status code, along with an error message telling the user what was wrong with their fields selection (for example, “Invalid field selection a/b”).</p>
<p>Here is the partial response example shown in the introductory section above. The request uses the fields parameter to specify which fields to return.</p>
<p><a href="https://www.googleapis.com/demo/v1?key=YOUR-API-KEY&amp;fields=kind,items(title,characteristics/length)" target="_blank" rel="noopener">https://www.googleapis.com/demo/v1?key=YOUR-API-KEY&amp;fields=kind,items(title,characteristics/length)</a><br>The partial response looks like this:</p>
<p>200 OK</p>
<p>{<br>  “kind”: “demo”,<br>  “items”: [<br>  {<br>    “title”: “First title”,<br>    “characteristics”: {<br>      “length”: “short”<br>    }<br>  },<br>  {<br>    “title”: “Second title”,<br>    “characteristics”: {<br>      “length”: “long”<br>    }<br>  },<br>  …<br>  ]<br>Note: For APIs that support query parameters for data pagination (maxResults and nextPageToken, for example), use those parameters to reduce the results of each query to a manageable size. Otherwise, the performance gains possible with partial response might not be realized.</p>
<p>Patch (partial update)<br>You can also avoid sending unnecessary data when modifying resources. To send updated data only for the specific fields that you’re changing, use the HTTP PATCH verb. The patch semantics described in this document are different (and simpler) than they were for the older, GData implementation of partial update.</p>
<p>The short example below shows how using patch minimizes the data you need to send to make a small update.</p>
<p>Example<br>This example shows a simple patch request to update only the title of a generic (fictional) “Demo” API resource. The resource also has a comment, a set of characteristics, status, and many other fields, but this request only sends the title field, since that’s the only field being modified:</p>
<p>PATCH <a href="https://www.googleapis.com/demo/v1/324" target="_blank" rel="noopener">https://www.googleapis.com/demo/v1/324</a><br>Authorization: Bearer your_auth_token<br>Content-Type: application/json</p>
<p>{<br>  “title”: “New title”<br>}<br>Response:</p>
<p>200 OK</p>
<p>{<br>  “title”: “New title”,<br>  “comment”: “First comment.”,<br>  “characteristics”: {<br>    “length”: “short”,<br>    “accuracy”: “high”,<br>    “followers”: [“Jo”, “Will”],<br>  },<br>  “status”: “active”,<br>  …<br>}<br>The server returns a 200 OK status code, along with the full representation of the updated resource. Since only the title field was included in the patch request, that’s the only value that is different from before.</p>
<p>Note: If you use the partial response fields parameter in combination with patch, you can increase the efficiency of your update requests even further. A patch request only reduces the size of the request. A partial response reduces the size of the response. So to reduce the amount of data sent in both directions, use a patch request with the fields parameter.</p>
<p>Semantics of a patch request<br>The body of the patch request includes only the resource fields you want to modify. When you specify a field, you must include any enclosing parent objects, just as the enclosing parents are returned with a partial response. The modified data you send is merged into the data for the parent object, if there is one.</p>
<p>Add: To add a field that doesn’t already exist, specify the new field and its value.<br>Modify: To change the value of an existing field, specify the field and set it to the new value.<br>Delete: To delete a field, specify the field and set it to null. For example, “comment”: null. You can also delete an entire object (if it is mutable) by setting it to null. If you are using the Java API Client Library, use Data.NULL_STRING instead; for details, see JSON null.<br>Note about arrays: Patch requests that contain arrays replace the existing array with the one you provide. You cannot modify, add, or delete items in an array in a piecemeal fashion.</p>
<p>Using patch in a read-modify-write cycle<br>It can be a useful practice to start by retrieving a partial response with the data you want to modify. This is especially important for resources that use ETags, since you must provide the current ETag value in the If-Match HTTP header in order to update the resource successfully. After you get the data, you can then modify the values you want to change and send the modified partial representation back with a patch request. Here is an example that assumes the Demo resource uses ETags:</p>
<p>GET <a href="https://www.googleapis.com/demo/v1/324?fields=etag,title,comment,characteristics" target="_blank" rel="noopener">https://www.googleapis.com/demo/v1/324?fields=etag,title,comment,characteristics</a><br>Authorization: Bearer your_auth_token<br>This is the partial response:</p>
<p>200 OK</p>
<p>{<br>  “etag”: “ETagString”<br>  “title”: “New title”<br>  “comment”: “First comment.”,<br>  “characteristics”: {<br>    “length”: “short”,<br>    “level”: “5”,<br>    “followers”: [“Jo”, “Will”],<br>  }<br>}<br>The following patch request is based on that response. As shown below, it also uses the fields parameter to limit the data returned in the patch response:</p>
<p>PATCH <a href="https://www.googleapis.com/demo/v1/324?fields=etag,title,comment,characteristics" target="_blank" rel="noopener">https://www.googleapis.com/demo/v1/324?fields=etag,title,comment,characteristics</a><br>Authorization: Bearer your_auth_token<br>Content-Type: application/json<br>If-Match: “ETagString”</p>
<p>{<br>  “etag”: “ETagString”<br>  “title”: “”,                  /* Clear the value of the title by setting it to the empty string. <em>/<br>  “comment”: null,              /</em> Delete the comment by replacing its value with null. <em>/<br>  “characteristics”: {<br>    “length”: “short”,<br>    “level”: “10”,              /</em> Modify the level value. <em>/<br>    “followers”: [“Jo”, “Liz”], /</em> Replace the followers array to delete Will and add Liz. <em>/<br>    “accuracy”: “high”          /</em> Add a new characteristic. */<br>  },<br>}<br>The server responds with a 200 OK HTTP status code, and the partial representation of the updated resource:</p>
<p>200 OK</p>
<p>{<br>  “etag”: “newETagString”<br>  “title”: “”,                 /* Title is cleared; deleted comment field is missing. <em>/<br>  “characteristics”: {<br>    “length”: “short”,<br>    “level”: “10”,             /</em> Value is updated.<em>/<br>    “followers”: [“Jo” “Liz”], /</em> New follower Liz is present; deleted Will is missing. <em>/<br>    “accuracy”: “high”         /</em> New characteristic is present. */<br>  }<br>}<br>Constructing a patch request directly<br>For some patch requests, you need to base them on the data you previously retrieved. For example, if you want to add an item to an array and don’t want to lose any of the existing array elements, you must get the existing data first. Similarly, if an API uses ETags, you need to send the previous ETag value with your request in order to update the resource successfully.</p>
<p>Note: You can use an “If-Match: *” HTTP header to force a patch to go through when ETags are in use.  If you do this, you don’t need to do the read before the write.</p>
<p>For other situations, however, you can construct the patch request directly, without first retrieving the existing data. For example, you can easily set up a patch request that updates a field to a new value or adds a new field. Here is an example:</p>
<p>PATCH <a href="https://www.googleapis.com/demo/v1/324?fields=comment,characteristics" target="_blank" rel="noopener">https://www.googleapis.com/demo/v1/324?fields=comment,characteristics</a><br>Authorization: Bearer your_auth_token<br>Content-Type: application/json</p>
<p>{<br>  “comment”: “A new comment”,<br>  “characteristics”: {<br>    “volume”: “loud”,<br>    “accuracy”: null<br>  }<br>}<br>With this request, if the comment field has an existing value, the new value overwrites it; otherwise it is set to the new value. Similarly, if there was a volume characteristic, its value is overwritten; if not, it is created. The accuracy field, if set, is removed.</p>
<p>Handling the response to a patch<br>After processing a valid patch request, the API returns a 200 OK HTTP response code along with the complete representation of the modified resource. If ETags are used by the API, the server updates ETag values when it successfully processes a patch request, just as it does with PUT.</p>
<p>The patch request returns the entire resource representation unless you use the fields parameter to reduce the amount of data it returns.</p>
<p>If a patch request results in a new resource state that is syntactically or semantically invalid, the server returns a 400 Bad Request or 422 Unprocessable Entity HTTP status code, and the resource state remains unchanged. For example, if you attempt to delete the value for a required field, the server returns an error.</p>
<p>Alternate notation when PATCH HTTP verb is not supported<br>If your firewall does not allow HTTP PATCH requests, then do an HTTP POST request and set the override header to PATCH, as shown below:</p>
<p>POST <a href="https://www.googleapis.com/" target="_blank" rel="noopener">https://www.googleapis.com/</a>…<br>X-HTTP-Method-Override: PATCH<br>…<br>Difference between patch and update<br>In practice, when you send data for an update request that uses the HTTP PUT verb, you only need to send those fields which are either required or optional; if you send values for fields that are set by the server, they are ignored. Although this might seem like another way to do a partial update, this approach has some limitations. With updates that use the HTTP PUT verb, the request fails if you don’t supply required parameters, and it clears previously set data if you don’t supply optional parameters.</p>
<p>It’s much safer to use patch for this reason. You only supply data for the fields you want to change; fields that you omit are not cleared. The only exception to this rule occurs with repeating elements or arrays: If you omit all of them, they stay just as they are; if you provide any of them, the whole set is replaced with the set that you provide.</p>
<p>Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code samples are licensed under the Apache 2.0 License. For details, see our Site Policies. Java is a registered trademark of Oracle and/or its affiliates.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
</search>
