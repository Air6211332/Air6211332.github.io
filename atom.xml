<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小米的HEXO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://localhost/"/>
  <updated>2018-04-06T02:38:36.672Z</updated>
  <id>http://localhost/</id>
  
  <author>
    <name>小米</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Markdown画图指南 -- 小米规整</title>
    <link href="http://localhost/2018/04/05/%E6%94%B6%E9%9B%86/Hexo%20Lean/"/>
    <id>http://localhost/2018/04/05/收集/Hexo Lean/</id>
    <published>2018-04-05T05:24:20.464Z</published>
    <updated>2018-04-06T02:38:36.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h1><h2 id="Hello-Word"><a href="#Hello-Word" class="headerlink" title="Hello Word"></a>Hello Word</h2><p>代码：<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">``sequence</span><br><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br><span class="line">``</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><pre class="mermaid">sequenceDiagram    participant Alice    participant Bob    Alice->>John: Hello John, how are you?    loop Healthcheck        John->>John: Fight against hypochondria    end    Note right of John: Rational thoughts <br>prevail...    John-->>Alice: Great!    John->>Bob: How about you?    Bob-->>John: Jolly good!</pre><h2 id="d"><a href="#d" class="headerlink" title="d"></a>d</h2><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><h2 id="Hello-Word-1"><a href="#Hello-Word-1" class="headerlink" title="Hello Word"></a>Hello Word</h2><p>代码：<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">``mermaid</span><br><span class="line">graph TD;</span><br><span class="line"><span class="code">    A--&gt;B;</span></span><br><span class="line"><span class="code">    A--&gt;C;</span></span><br><span class="line"><span class="code">    B--&gt;D;</span></span><br><span class="line"><span class="code">    C--&gt;D;</span></span><br><span class="line">``</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><pre class="mermaid">graph TD;    A-->B;    A-->C;    B-->D;    C-->D;</pre>## 基本格式<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">``mermaid</span><br><span class="line">graph TD</span><br><span class="line"><span class="code">    Start --&gt; Stop</span></span><br><span class="line">``</span><br></pre></td></tr></table></figure><pre class="mermaid">graph TD    Start --> Stop</pre><ul><li>Hexo图例语言–mermaid–在有道云中不需要声明该项</li><li>图例配置<ul><li>图例类型 graph</li><li>流程图绘画方向 TD</li></ul></li><li>流程图语句</li></ul><h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><p>流程图绘画方向</p><ul><li>TB - 从上而下</li><li>BT - 从下而上</li><li>RL - 从右到左</li><li>LR - 从左到右</li><li>TD - 从上到下</li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">``mermaid</span><br><span class="line">graph LR</span><br><span class="line"><span class="code">    Start --&gt; Stop</span></span><br><span class="line">``</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LR    Start --> Stop</pre><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><h3 id="默认节点"><a href="#默认节点" class="headerlink" title="默认节点"></a>默认节点</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">``</span><br><span class="line">graph LR</span><br><span class="line"><span class="code">    id</span></span><br><span class="line">``</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LR    id</pre>节点的标识符和内容一致### 文本节点<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">``</span><br><span class="line">graph LR</span><br><span class="line"><span class="code">    id1[This is the text in the box]</span></span><br><span class="line">``</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LR    id1[This is the text in the box]</pre>`[]`,`()`,`(())`,`>]`,`{}`可以声明节点的文本，使得文本和标识符不一致。其中- `[]` : 方形- `()` : 圆方- `(())` : 圆形- `>]` : 标签形- `{}` : 菱形<pre class="mermaid">graph LR    id1[This is the text in the box]    id2(This is the text in the box)    id3((This is the text in the box))    id4>This is the text in the box]    id5{This is the text in the box}</pre><h3 id="连线"><a href="#连线" class="headerlink" title="连线"></a>连线</h3><p>使用标识符进行连线，例如 A 连到 B <code>a --&gt; b</code><br>其中</p><ul><li><code>---</code> 实线无箭头</li><li><code>--&gt;</code> 实线带箭头</li><li><code>-.-</code> 虚线无箭头</li><li><code>-.&gt;</code> 虚线带箭头</li><li><code>===</code> 粗线无箭头</li><li><code>==&gt;</code> 粗线带箭头</li></ul><p>可以在线上加文字，例如 A 连到 B 文字为 你好 <code>a -- 你好 --&gt; b</code><br>以Text为例</p><ul><li><code>-- Text ---</code> 实线无箭头</li><li><code>-- Text --&gt;</code> 实线带箭头</li><li><code>-. Text -.-</code> 虚线无箭头</li><li><code>-. Text -.&gt;</code> 虚线带箭头</li><li><code>== Text ===</code> 粗线无箭头</li><li><code>== Text ==&gt;</code> 粗线带箭头</li></ul><blockquote><p>未完待续</p></blockquote><h1 id="GitGraph"><a href="#GitGraph" class="headerlink" title="GitGraph"></a>GitGraph</h1><p>代码：<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">``mermaid</span><br><span class="line">gitGraph:</span><br><span class="line">options</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    "nodeSpacing": 150,</span></span><br><span class="line"><span class="code">    "nodeRadius": 10</span></span><br><span class="line">&#125;</span><br><span class="line">end</span><br><span class="line">commit</span><br><span class="line">branch newbranch</span><br><span class="line">checkout newbranch</span><br><span class="line">commit</span><br><span class="line">commit</span><br><span class="line">checkout master</span><br><span class="line">commit</span><br><span class="line">commit</span><br><span class="line">merge newbranch</span><br><span class="line">``</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><pre class="mermaid">gitGraph:options{    "nodeSpacing": 150,    "nodeRadius": 10}endcommitbranch newbranchcheckout newbranchcommitcommitcheckout mastercommitcommitmerge newbranch</pre># 甘特图代码：<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">``mermaid</span><br><span class="line">gantt</span><br><span class="line">dateFormat  YYYY-MM-DD</span><br><span class="line">title Adding GANTT diagram to mermaid</span><br><span class="line"></span><br><span class="line">section A section</span><br><span class="line">Completed task            :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">Active task               :active,  des2, 2014-01-09, 3d</span><br><span class="line">Future task               :         des3, after des2, 5d</span><br><span class="line">Future task2               :         des4, after des3, 5d</span><br><span class="line">``</span><br></pre></td></tr></table></figure>效果如下：<pre class="mermaid">ganttdateFormat  YYYY-MM-DDtitle Adding GANTT diagram to mermaidsection A sectionCompleted task            :done,    des1, 2014-01-06,2014-01-08Active task               :active,  des2, 2014-01-09, 3dFuture task               :         des3, after des2, 5dFuture task2               :         des4, after des3, 5d</pre>]]></content>
    
    <summary type="html">
    
      Markdown的一些高级使用
    
    </summary>
    
      <category term="随笔" scheme="http://localhost/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://localhost/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="hexo" scheme="http://localhost/tags/hexo/"/>
    
      <category term="md" scheme="http://localhost/tags/md/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 插件推荐 -- 小米推荐</title>
    <link href="http://localhost/2018/04/05/%E6%94%B6%E9%9B%86/Chrome%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90--%E5%B0%8F%E7%B1%B3%E6%8E%A8%E8%8D%90/"/>
    <id>http://localhost/2018/04/05/收集/Chrome插件推荐--小米推荐/</id>
    <published>2018-04-05T04:01:41.910Z</published>
    <updated>2018-04-05T04:58:34.266Z</updated>
    
    <content type="html"><![CDATA[<p>闲话不多说，直接上推荐的插件，可以翻墙的直接点击标题跳转谷歌商店下载，不信的我下面也给出离线安装文件</p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180405120713.png" alt="我的插件"></p><h1 id="通用类插件"><a href="#通用类插件" class="headerlink" title="通用类插件"></a>通用类插件</h1><ol><li><p>历史记录管理 – Better History</p><p> 官方介绍：更好地查看您的历史记录。为查看您的历史记录带来最好的搜索体验，最清晰的界面和最有帮助的筛选。</p><p> 小米点评：个人觉得Chrome自带的历史管理工具很难用，界面虽然好看但是很不好管理，所以推荐这个大家使用。</p><p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405121159.png" alt=""></p><ul><li><a href="https://chrome.google.com/webstore/detail/better-history/obciceimmggglbmelaidpjlmodcebijb" target="_blank" rel="noopener">官方地址</a></li></ul></li><li><p>下载管理器 – Chrono下载管理器</p><p> 官方介绍：做Chrome浏览器中最好的下载管理器</p><p> 小米点评：我用了很久的一个插件，可以分类显示下载的内容，还可以嗅探出当前页面的资源，并可以批量下载网页的内容（图片和视频）</p><p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405121856.png" alt="弹出框"></p><p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405121957.png" alt="全屏页面"></p><p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405122043.png" alt="当前页面的资源"></p><ul><li><a href="https://chrome.google.com/webstore/detail/mciiogijehkdemklbdcbfkefimifhecn" target="_blank" rel="noopener">官方地址</a></li></ul></li><li><p>新标签页 – oscnews</p><p> 官方介绍：查看开源中国软件更新资讯，内置文档导航，GitHub 趋势榜，linux命令索引，浏览历史记录和时钟页面。</p><p> 小米点评：我目前在用的新标签页插件。可能不适用大家，不关注开发的可以尝试另一个Infinity。</p><p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405124044.png" alt=""></p><ul><li><a href="https://chrome.google.com/webstore/detail/mciiogijehkdemklbdcbfkefimifhecn" target="_blank" rel="noopener">官方地址</a></li></ul></li><li><p>新标签页 – Infinity</p><p> 官方介绍：Infinity新标签页，基于Chrome的云应用服务，让你更优雅、轻松地使用Chrome。</p><p> 小米点评：功能很丰富，具有导航，天前，TODO，壁纸，界面还不错。</p><p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405123724.png" alt=""></p><ul><li><a href="https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg" target="_blank" rel="noopener">官方地址</a></li><li></li></ul></li><li><p>目录 – Smart TOC</p><p> 官方介绍：Add a table of contents for web article or documentation</p><p> 小米点评：不是所有的网站都有一个悬浮的目录，这个插件可以生成一个悬浮的目录在页面上，比如Spring的官方文档的目录，长篇大幅的文章，目前在最顶上，阅读很不方便，这个插件的作用就尤为突出。</p><p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405124622.png" alt=""></p><ul><li><a href="https://chrome.google.com/webstore/detail/lifgeihcfpkmmlfjbailfpfhbahhibba" target="_blank" rel="noopener">官方地址</a></li></ul></li><li><p>油猴子 – Tampermonkey</p><p> 官方介绍：The world’s most popular userscript manager</p><p> 小米点评：插件中的神器，可以安装各种脚本，比如百度云Ex等，谁用谁知道。</p><p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405124828.png" alt=""></p><ul><li><a href="https://chrome.google.com/webstore/detail/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">官方地址</a></li></ul></li><li><p>广告过滤 – uBlock Origin</p><p> 官方介绍：一款高效的网络请求过滤工具，占用极低的内存和 CPU。</p><p> 小米点评：广告过滤妥妥的。</p><p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405124944.png" alt=""></p><ul><li><a href="https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm" target="_blank" rel="noopener">官方地址</a></li></ul></li><li><p>阅读 – 简悦 - SimpRead</p><p> 官方介绍：让你瞬间进入沉浸式阅读的 Chrome 扩展，类似 Safari 的阅读模式。</p><p> 小米点评：给你高效的阅读体验。</p><p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405125638.png" alt="开启前"></p><p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405125617.png" alt="开启后"></p><ul><li><a href="https://chrome.google.com/webstore/detail/simpread-reader-view/ijllcpnolfcooahcekpamkbidhejabll" target="_blank" rel="noopener">官方地址</a></li></ul></li></ol><h1 id="开发类插件"><a href="#开发类插件" class="headerlink" title="开发类插件"></a>开发类插件</h1><ol><li><p>CSS调试器 – Code Cola</p><p> 官方介绍：Code Cola 是一个可视化编辑在线页面 css 样式的 chrome 插件。</p><p> 小米点评：很直观调试样式，先选择页面元素后，可以在弹出框中修改样式 ，之后便可以导出 CSS 。</p><p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405122647.png" alt="样式修改死的截图"></p><ul><li><a href="https://chrome.google.com/webstore/detail/code-cola/lomkpheldlbkkfiifcbfifipaofnmnkn" target="_blank" rel="noopener">官方地址</a></li></ul></li><li><p>JSON查看器 – JSON-handle</p><p>官方介绍：It’s a browser and editor for JSON document.You can get a beautiful view</p><p>小米点评：打开页面后可以很方便的查看JSON的层次结构和数据类型和值。在值为Base64图片和图片Url的时候悬停可以直接预览图片。</p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180405123112.png" alt=""></p><ul><li><a href="https://chrome.google.com/webstore/detail/json-handle/iahnhfdhidomcpggpaimmmahffihkfnj" target="_blank" rel="noopener">官方地址</a></li></ul></li><li><p>DIV查看 – Outliner</p><p> 官方介绍：This extension outlines all the DOM elements on a page</p><p> 小米点评：给每一个Div加上边框，可以很方便的查看Div的位置</p><p> <img src="http://ot0en8caw.bkt.clouddn.com/20180405124247.png" alt=""></p><ul><li><a href="https://chrome.google.com/webstore/detail/outliner/hmdacajmldpieoadpgloddgkeamdhoka" target="_blank" rel="noopener">官方地址</a></li></ul></li></ol><h1 id="网站加强"><a href="#网站加强" class="headerlink" title="网站加强"></a>网站加强</h1><ol><li><p>GitHub – Insight.io for Github</p><p> 官方介绍：IDE like code intelligence and code search for GitHub by Insight.io.</p><p> 小米点评：可以在GitHub的左侧查看当前项目的目录结构，也可以单文件下载，还可以全局搜索。GitHub党必备。</p><ul><li><a href="https://chrome.google.com/webstore/detail/insightio-for-github/pmhfgjjhhomfplgmbalncpcohgeijonh" target="_blank" rel="noopener">官方地址</a></li></ul></li><li><p>百度云 – 云盘万能钥匙</p><p> 官方介绍：你的云盘智能助手</p><p> 小米点评：在你打开网盘分享的链接的时候，可以自动充填提取密码。基于和WiFi万能钥匙一样的原理，属于记录各个分享链接的密码在充填密码，在装有该插件的人中你若是第一个打开，还是得要自己来填写。</p><ul><li><a href="https://chrome.google.com/webstore/detail/anlllmnpjodopgbkbpnghnjlelnogfjc" target="_blank" rel="noopener">官方地址</a></li></ul></li><li><p>新浪微博 – 眼不见心不烦（新浪微博）</p><p> 官方介绍：新浪微博（weibo.com）非官方功能增强插件，可以无限制地屏蔽关键词、用户、来源，去除页面广告和推广微博，反刷屏，还您一个清爽干净的微博！</p><p> 小米点评：还你干净的微博浏览体验。</p><ul><li><a href="https://chrome.google.com/webstore/detail/aognaapdfnnldnjglanfbbklaakbpejm" target="_blank" rel="noopener">官方地址</a></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      分享下本米自用的 Chrome 插件希望大家喜欢
    
    </summary>
    
      <category term="随笔" scheme="http://localhost/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://localhost/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="soft" scheme="http://localhost/tags/soft/"/>
    
      <category term="chrome" scheme="http://localhost/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>图文并茂，深入浅出 Nginx</title>
    <link href="http://localhost/2018/04/05/%E6%94%B6%E9%9B%86/%E5%9B%BE%E6%96%87%E5%B9%B6%E8%8C%82%EF%BC%8C%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANginx/"/>
    <id>http://localhost/2018/04/05/收集/图文并茂，深入浅出Nginx/</id>
    <published>2018-04-04T16:13:46.430Z</published>
    <updated>2018-04-04T16:42:30.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Nginx 是一款轻量级的 Web 服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180405001432.png" alt="架构图"></p><p>上图基本上说明了当下流行的技术架构，其中 Nginx 有点入口网关的味道。<br><a id="more"></a></p><h1 id="反向代理服务器？"><a href="#反向代理服务器？" class="headerlink" title="反向代理服务器？"></a>反向代理服务器？</h1><p>经常听人说到一些术语，如反向代理，那么什么是反向代理，什么又是正向代理呢？</p><p>正向代理：</p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180405001549.png" alt="正向代理"></p><p>反向代理：</p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180405001608.png" alt="反向代理"></p><p>由于防火墙的原因，我们并不能直接访问谷歌，那么我们可以借助 VPN 来实现，这就是一个简单的正向代理的例子。这里你能够发现，正向代理 “代理” 的是客户端，而且客户端是知道目标的，而目标是不知道客户端是通过 VPN 访问的。</p><p>当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即反向代理 “代理” 的是服务器端，而且这一个过程对于客户端而言是透明的。</p><h1 id="Nginx-的-Master-Worker-模式"><a href="#Nginx-的-Master-Worker-模式" class="headerlink" title="Nginx 的 Master-Worker 模式"></a>Nginx 的 Master-Worker 模式</h1><p><img src="http://ot0en8caw.bkt.clouddn.com/20180405001635.png" alt="nginx 进程"></p><p>启动 Nginx 后，其实就是在 80 端口启动了 Socket 服务进行监听，如图所示，Nginx 涉及 Master 进程和 Worker 进程。</p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180405001659.png" alt="Master-Worker 模式"></p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180405001721.png" alt="nginx.conf"></p><h2 id="Master-进程的作用是？"><a href="#Master-进程的作用是？" class="headerlink" title="Master 进程的作用是？"></a>Master 进程的作用是？</h2><p>读取并验证配置文件 nginx.conf；管理 worker 进程；</p><h2 id="Worker-进程的作用是？"><a href="#Worker-进程的作用是？" class="headerlink" title="Worker 进程的作用是？"></a>Worker 进程的作用是？</h2><p>每一个 Worker 进程都维护一个线程（避免线程切换），处理连接和请求；注意 Worker 进程的个数由配置文件决定，一般和 CPU 个数相关（有利于进程切换），配置几个就有几个 Worker 进程。</p><h1 id="思考：Nginx-如何做到热部署？"><a href="#思考：Nginx-如何做到热部署？" class="headerlink" title="思考：Nginx 如何做到热部署？"></a>思考：Nginx 如何做到热部署？</h1><p>所谓热部署，就是配置文件 nginx.conf 修改后，不需要 stop Nginx，不需要中断请求，就能让配置文件生效！（nginx -s reload 重新加载 / nginx -t 检查配置 / nginx -s stop）</p><p>通过上文我们已经知道 worker 进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象：</p><p>方案一：</p><p>修改配置文件 nginx.conf 后，主进程 master 负责推送给 woker 进程更新配置信息，woker 进程收到信息后，更新进程内部的线程信息。（有点 valatile 的味道）</p><p>方案二：</p><p>修改配置文件 nginx.conf 后，重新生成新的 worker 进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的 worker 进程，至于老的 worker 进程，等把那些以前的请求处理完毕后，kill 掉即可。</p><p>Nginx 采用的就是方案二来达到热部署的！</p><h1 id="思考：Nginx-如何做到高并发下的高效处理？"><a href="#思考：Nginx-如何做到高并发下的高效处理？" class="headerlink" title="思考：Nginx 如何做到高并发下的高效处理？"></a>思考：Nginx 如何做到高并发下的高效处理？</h1><p>上文已经提及 Nginx 的 worker 进程个数与 CPU 绑定、worker 进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。</p><p>作为专业的程序员，我们可以开一下脑洞：BIO/NIO/AIO、异步 / 同步、阻塞 / 非阻塞…</p><p>要同时处理那么多的请求，要知道，有的请求需要发生 IO，可能需要很长时间，如果等着它，就会拖慢 worker 的处理速度。</p><p>Nginx 采用了 Linux 的 epoll 模型，epoll 模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果 OK，那么放入 epoll 队列中，这个过程是异步的。worker 只需要从 epoll 队列循环处理即可。</p><h1 id="思考：Nginx-挂了怎么办？"><a href="#思考：Nginx-挂了怎么办？" class="headerlink" title="思考：Nginx 挂了怎么办？"></a>思考：Nginx 挂了怎么办？</h1><p>Nginx 既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。</p><p>答案是：Keepalived+Nginx 实现高可用。</p><p>Keepalived 是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和 Nginx 配合来实现 Web 服务的高可用。</p><p>（其实，Keepalived 不仅仅可以和 Nginx 配合，还可以和很多其他服务配合）</p><h1 id="Keepalived-Nginx-实现高可用的思路："><a href="#Keepalived-Nginx-实现高可用的思路：" class="headerlink" title="Keepalived+Nginx 实现高可用的思路："></a>Keepalived+Nginx 实现高可用的思路：</h1><p>第一：请求不要直接打到 Nginx 上，应该先通过 Keepalived（这就是所谓虚拟 IP，VIP）</p><p>第二：Keepalived 应该能监控 Nginx 的生命状态（提供一个用户自定义的脚本，定期检查 Nginx 进程状态，进行权重变化,，从而实现 Nginx 故障切换）</p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180405002123.png" alt="Keepalived+Nginx"></p><h1 id="我们的主战场：nginx-conf"><a href="#我们的主战场：nginx-conf" class="headerlink" title="我们的主战场：nginx.conf"></a>我们的主战场：nginx.conf</h1><p>很多时候，在开发、测试环境下，我们都得自己去配置 Nginx，就是去配置 nginx.conf。</p><p>nginx.conf 是典型的分段配置文件，下面我们来分析下。</p><h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p><img src="http://ot0en8caw.bkt.clouddn.com/20180405003223.png" alt="http 的 server 段"></p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180405003235.png" alt="访问结果"></p><p>其实这是把 Nginx 作为 web server 来处理静态资源。</p><p>第一：location 可以进行正则匹配，应该注意正则的几种形式以及优先级。（这里不展开）</p><p>第二：Nginx 能够提高速度的其中一个特性就是：动静分离，就是把静态资源放到 Nginx 上，由 Nginx 管理，动态请求转发给后端。</p><p>第三：我们可以在 Nginx 下把静态资源、日志文件归属到不同域名下（也即是目录），这样方便管理维护。</p><p>第四：Nginx 可以进行 IP 访问控制，有些电商平台，就可以在 Nginx 这一层，做一下处理，内置一个黑名单模块，那么就不必等请求通过 Nginx 达到后端在进行拦截，而是直接在 Nginx 这一层就处理掉。</p><h1 id="反向代理【proxy-pass】"><a href="#反向代理【proxy-pass】" class="headerlink" title="反向代理【proxy_pass】"></a>反向代理【proxy_pass】</h1><p>所谓反向代理，很简单，其实就是在 location 这一段配置中的 root 替换成 proxy_pass 即可。root 说明是静态资源，可以由 Nginx 进行返回；而 proxy_pass 说明是动态请求，需要进行转发，比如代理到 Tomcat 上。</p><p>反向代理，上面已经说了，过程是透明的，比如说 request -&gt; Nginx -&gt; Tomcat，那么对于 Tomcat 而言，请求的 IP 地址就是 Nginx 的地址，而非真实的 request 地址，这一点需要注意。不过好在 Nginx 不仅仅可以反向代理请求，还可以由用户自定义设置 HTTP HEADER。</p><h1 id="负载均衡【upstream】"><a href="#负载均衡【upstream】" class="headerlink" title="负载均衡【upstream】"></a>负载均衡【upstream】</h1><p>上面的反向代理中，我们通过 proxy_pass 来指定 Tomcat 的地址，很显然我们只能指定一台 Tomcat 地址，那么我们如果想指定多台来达到负载均衡呢？</p><p>第一，通过 upstream 来定义一组 Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx 可以监控这一组 Tomcat 的状态）等。</p><p>第二，将 proxy_pass 替换成 upstream 指定的值即可。</p><h1 id="负载均衡可能带来的问题？"><a href="#负载均衡可能带来的问题？" class="headerlink" title="负载均衡可能带来的问题？"></a>负载均衡可能带来的问题？</h1><p>负载均衡所带来的明显的问题是，一个请求，可以到 A server，也可以到 B server，这完全不受我们的控制，当然这也不是什么问题，只是我们得注意的是：用户状态的保存问题，如 Session 会话信息，不能在保存到服务器上。</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>缓存，是 Nginx 提供的，可以加快访问速度的机制，说白了，在配置上就是一个开启，同时指定目录，让缓存可以存储到磁盘上。具体配置，大家可以参考 Nginx 官方文档，这里就不在展开了。</p><p>好了，到这里，Nginx 的介绍就到这里了。欢迎转发。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Nginx 是一款轻量级的 Web 服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ot0en8caw.bkt.clouddn.com/20180405001432.png&quot; alt=&quot;架构图&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图基本上说明了当下流行的技术架构，其中 Nginx 有点入口网关的味道。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://localhost/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://localhost/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Nginx" scheme="http://localhost/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>史上最污技术解读，60 个 IT 术语我竟然秒懂了......</title>
    <link href="http://localhost/2018/04/04/%E6%94%B6%E9%9B%86/%E5%8F%B2%E4%B8%8A%E6%9C%80%E6%B1%A1%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB%EF%BC%8C60%20%E4%B8%AA%20IT%20%E6%9C%AF%E8%AF%AD%E6%88%91%E7%AB%9F%E7%84%B6%E7%A7%92%E6%87%82%E4%BA%86/"/>
    <id>http://localhost/2018/04/04/收集/史上最污技术解读，60 个 IT 术语我竟然秒懂了/</id>
    <published>2018-04-04T06:17:26.727Z</published>
    <updated>2018-04-04T06:25:04.693Z</updated>
    
    <content type="html"><![CDATA[<p>假设你是个妹子，你有一位男朋友，于此同时你和另外一位男生暧昧不清，比朋友好，又不是恋人。你随时可以甩了现任男友，另外一位马上就能补上。这是<strong>冷备份</strong>。</p><p>假设你是个妹子，同时和两位男性在交往，两位都是你男朋友。并且他们还互不干涉，独立运行。这就是<strong>双机热备份</strong>。</p><p>假设你是个妹子，不安于男朋友给你的安全感。在遥远的男友未知的地方，和一位男生保持着联系，你告诉他你没有男朋友，你现在处于纠结期，一旦你和你男朋友分开了，你马上可以把自己感情转移到异地男人那里去。这是<strong>异地容灾备份</strong>。</p><p>假设你是个妹子，有一位男朋友，你又付了钱给一家婚姻介绍所，让他帮你留意好的资源，一旦你和你这位男朋友分开，婚姻介绍所马上给你安排资源，你感情不间断运行，这是<strong>云备份</strong>。。。。</p><p>假设你是个妹子，你怀疑男朋友对你的忠诚，在某宝购买了一个测试忠诚度的服务。这是<strong>灾难演练</strong>。友情提醒，在没有备份的情况下，切忌进行灾难演练，说不好会让你数据血本无归。</p><p>假设你是个妹子，你和男友异地恋，你每天晚上都打电话查岗，问他还爱不爱你了，这叫<strong>ping</strong>。</p><p>假设你是个妹子，你的男友经常玩失踪，所以你希望时刻掌握他的行踪，你先打电话给他的好基友A，A说好基友B知道，B说好基友C知道，C说好基友D知道，D说你男朋友正在网吧打游戏，你终于知道了男友在哪儿，这叫<strong>TraceRoute</strong>。</p><p>假设你是个妹子，你的男友沉迷游戏经常不接电话无故宕机，所以当你们约好下午逛街以后你要时不时的打个电话询问，看看他是不是还能正常提供服务，这叫<strong>心跳监测</strong>。</p><p>假设你是个妹子，你想去逛街而你的男友A在打游戏不接电话，于是乎你把逛街的请求发给了替补男友B，从而保障服务不间断运行，这叫<strong>故障切换</strong>。</p><p>假设你是个妹子，你有很多需要男朋友完成的事情，于是乎你跟A逛街旅游吃饭不可描述，而B只能陪你逛街，不能拥有全部男朋友的权利，这叫<strong>主从配置 master-slave</strong>。</p><p>假设你是个妹子，你败家太厉害，以至于你的男友根本吃不消，于是呼你找了两个男朋友，一三五单号，二四六双号限行，从而减少一个男朋友所面临的压力，这叫<strong>负载均衡</strong>。</p><p>假设你是个妹子并且有多个男朋友，配合心跳检测与故障切换和负载均衡将会达到极致的体验，这叫<strong>集群LVS</strong>，注意，当需求单机可以处理的情况下不建议启用集群，会造成大量资源闲置，提高维护成本。</p><p>假设你是个妹子，你的需求越来越高导致一个男朋友集群已经处理不了了，于是乎你又新增了另外几个，这叫<strong>多集群横向扩容</strong>，简称<strong>multi-cluster grid</strong>。</p><p>假设你是个妹子，你的男朋友身体瘦弱从而无法满足需求，于是乎你买了很多大补产品帮你男朋友升级，从而提高单机容量，这叫<strong>纵向扩容</strong>，<strong>Scale up</strong>。切记，纵向扩容的成本会越来越高而效果越来越不明显。</p><p>假设你是个妹子，你跟男友经常出去游玩，情到深处想做点什么的时候却苦于没有tt，要去超市购买，于是乎你在你们经常去的地方都放置了tt，从而大幅度降低等待时间，这叫<strong>CDN</strong>。</p><p>假设你是个妹子,你的男朋友英俊潇洒风流倜傥财大气粗对你唯一,于是乎你遭到了女性B的敌视，B会以朋友名义在周末请求你男朋友修电脑,修冰箱,占用男朋友大量时间,造成男朋友无法为你服务,这叫<strong>拒绝服务攻击</strong>,简称<strong>DOS</strong>。</p><p>假设你是个妹子,你因男朋友被一位女性敌视,但是你男朋友的处理能力十分强大,处理速度已经高于她的请求速度,于是她雇佣了一票女性来轮流麻烦你的男朋友,这叫<strong>分布式拒绝服务攻击</strong>,简称<strong>DDOS</strong>。</p><p>假设你是个妹子，你发现男朋友总是在处理一些无关紧要的其它请求，于是乎你给男朋友了一个白名单,要求他只处理白名单内的请求，而拒绝其它身份不明的人的要求,这叫<strong>访问控制</strong>。</p><p>假设你是个妹子，你男朋友风流倜傥，你总担心他出轨，于是你在他身上安装了一个窃听器，里面内置了一些可疑女生勾搭行为的特征库，只要出现疑似被勾搭的情况，就会立刻向你报警，这叫<strong>入侵检测系统（IDS）</strong>。</p><p>假设你是个妹子，你改良了上面的窃听器，当可疑女性对你男朋友做出勾搭行为的时候，立刻释放1万伏电压，把可疑人击昏，终止这次勾搭。这叫<strong>入侵防御系统（IPS）</strong>。</p><p>假设你是个妹子，虽然你装了各种窃听器、报警器，可是你蓝朋友处处留情，报警器响个不停，让你应接不暇，疲于奔命，于是你搞了个装置集中收集这些出轨告警，进行综合分析，生成你男朋友的出轨报告。这叫<strong>SIEM</strong>或者<strong>SOC</strong>。</p><p>假设你是个妹子，你把男朋友的出轨报告提交给他父母，得到了他们的大力支持，男友父母开始对他严加管教、限期整改，为你们的爱情保驾护航，做到合情合理、合法合规，这叫<strong>等级保护</strong>。</p><p>假设你是个妹子，你离男朋友家有点远，你开车去，这叫自建专线，你打车过去，这叫租用专线，你骑摩拜单车过去，这叫<strong>SDWAN</strong>。</p><p>假设你是个妹子，你和男朋友的恋爱遭到了双方家长的反对，不准双方往来，你们偷偷挖了一条隧道，便于进行幽会，这叫<strong>VPN</strong>。</p><p>假设你是个妹子，你的男朋友太优秀而造人窥视，于是乎它们研究了一下你的男朋友，稍微修改了一点点生产出一个男朋友B，与你的男朋友百分制99相似，这不叫剽窃，这叫<strong>逆向工程</strong>,比如男朋友外挂。</p><p>假设你是个妹子，你要求你的男朋友坚持十分钟，然后十五分钟继而二十分钟，以测试你男朋友的极限在哪里，这叫<strong>压力测试</strong>。</p><p>假设你是个妹子，为了保证你男朋友的正常运行，于是乎你每天查看他的微信微博等社交资料来寻找可能产生问题的线索，这叫<strong>数据分析</strong>。</p><p>假设你是个妹子，你的男朋友属于社交活跃选手，每天的微博知乎微信生产了大量信息，你发现自己的分析速度远远低于他生的速度，于是乎你找来你的闺蜜一起分析，这叫<strong>并行计算</strong>。</p><p>假设你是个妹子，你的男朋友太能折腾处处留情产生了天量的待处理信息，你和你的闺蜜们已经累趴也没赶上他创造的速度，于是你付费在知乎上找了20个小伙伴帮你一起分析，这叫<strong>云计算</strong>。</p><p>假设你是个妹子，你在得到男朋友经常出没的地点后，根据酒店，敏感时间段等信息确定男朋友因该是出轨了，这叫<strong>数据挖掘</strong>。</p><p>假设你是个妹子，在分析男友的数据后，得知他下午又要出去开房，于是乎你在他准备出门前给他发了个短信，问他有没有带tt，没有的话可以在我这里买，这叫<strong>精准推送</strong>，需要配合数据挖掘。</p><p>假如你是个妹子，你的男朋友总该出去浪而各种出问题，于是乎你租了间屋子并准备好了所有需要的东西并告诉他，以后不用找酒店了，直接来我这屋子吧，什么都准备好了，这叫<strong>容器</strong>。</p><p>假如你是个妹子，你每天都要和男朋友打通一次接口，<strong>采集数据</strong>。你一天24小时不停地采，这叫<strong>实时数据采集</strong>。你决定开发新的接口来和男朋友交流，这叫<strong>虚拟化</strong>。你决定从不同的男友身上采集数据，你就是<strong>大数据中心</strong>。有一天你决定生一个宝宝，这叫<strong>大数据应用</strong>。宝宝生下来不知道是谁的，这叫<strong>大数据脱敏</strong>。但是从宝宝外观来看，黑色皮肤金色头发，这叫<strong>数据融合跨域建模</strong>。你决定把这个宝宝拿来展览收点门票，这叫<strong>大数据变现</strong>。</p><p>假如妹纸男友多多多，看都看不过来、用不到也记不住，索性把最典型、必不可少、有潜力的那些优质男友挑出来，这叫<strong>数据简化</strong>。至于如何挑，用到<strong>数据简化技术</strong>。</p>]]></content>
    
    <summary type="html">
    
      假设你是个妹子......
    
    </summary>
    
      <category term="随笔" scheme="http://localhost/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://localhost/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Swift 与 Kotlin 的简单对比</title>
    <link href="http://localhost/2018/04/03/Java/Swift%20%E4%B8%8E%20Kotlin%20%E7%9A%84%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/"/>
    <id>http://localhost/2018/04/03/Java/Swift 与 Kotlin 的简单对比/</id>
    <published>2018-04-03T05:15:17.247Z</published>
    <updated>2018-04-03T05:21:05.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BASICS"><a href="#BASICS" class="headerlink" title="BASICS"></a>BASICS</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello, world!&quot;);</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;Hello, world!&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myVariable = 42;</span><br><span class="line">myVariable = 50;</span><br><span class="line">let myConstant = 42;</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myVariable = 42;</span><br><span class="line">myVariable = 50;</span><br><span class="line">val myConstant = 42;</span><br></pre></td></tr></table></figure></p><h2 id="显式类型"><a href="#显式类型" class="headerlink" title="显式类型"></a>显式类型</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let explicitDouble: Double = 70</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val explicitDouble: Double = 70.0</span><br></pre></td></tr></table></figure></p><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let label = &quot;The width is &quot;</span><br><span class="line">let width = 94</span><br><span class="line">let widthLabel = label + String(width)</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val label = &quot;The width is &quot;</span><br><span class="line">val width = 94</span><br><span class="line">val widthLabel = label + width</span><br></pre></td></tr></table></figure></p><h2 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let apples = 3</span><br><span class="line">let oranges = 5</span><br><span class="line">let fruitSummary = &quot;I have \(apples + oranges) &quot; +</span><br><span class="line">                   &quot;pieces of fruit.&quot;</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val apples = 3</span><br><span class="line">val oranges = 5</span><br><span class="line">val fruitSummary = &quot;I have $&#123;apples + oranges&#125; &quot; +</span><br><span class="line">                   &quot;pieces of fruit.&quot;</span><br></pre></td></tr></table></figure></p><h2 id="范围操作符"><a href="#范围操作符" class="headerlink" title="范围操作符"></a>范围操作符</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]</span><br><span class="line">let count = names.count</span><br><span class="line">for i in 0..&lt;count &#123;</span><br><span class="line">    print(&quot;Person \(i + 1) is called \(names[i])&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// Person 1 is called Anna</span><br><span class="line">// Person 2 is called Alex</span><br><span class="line">// Person 3 is called Brian</span><br><span class="line">// Person 4 is called Jack</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val names = arrayOf(&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;)</span><br><span class="line">val count = names.count()</span><br><span class="line">for (i in 0..count - 1) &#123;</span><br><span class="line">    println(&quot;Person $&#123;i + 1&#125; is called $&#123;names[i]&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// Person 1 is called Anna</span><br><span class="line">// Person 2 is called Alex</span><br><span class="line">// Person 3 is called Brian</span><br><span class="line">// Person 4 is called Jack</span><br></pre></td></tr></table></figure></p><h2 id="包罗广泛的范围操作符（Inclusive-Range-Operator）"><a href="#包罗广泛的范围操作符（Inclusive-Range-Operator）" class="headerlink" title="包罗广泛的范围操作符（Inclusive Range Operator）"></a>包罗广泛的范围操作符（Inclusive Range Operator）</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for index in 1...5 &#123;</span><br><span class="line">    print(&quot;\(index) times 5 is \(index * 5)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 1 times 5 is 5</span><br><span class="line">// 2 times 5 is 10</span><br><span class="line">// 3 times 5 is 15</span><br><span class="line">// 4 times 5 is 20</span><br><span class="line">// 5 times 5 is 25</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (index in 1..5) &#123;</span><br><span class="line">    println(&quot;$index times 5 is $&#123;index * 5&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 1 times 5 is 5</span><br><span class="line">// 2 times 5 is 10</span><br><span class="line">// 3 times 5 is 15</span><br><span class="line">// 4 times 5 is 20</span><br><span class="line">// 5 times 5 is 25</span><br></pre></td></tr></table></figure></p><h1 id="BASICS-1"><a href="#BASICS-1" class="headerlink" title="BASICS"></a>BASICS</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var shoppingList = [&quot;catfish&quot;, &quot;water&quot;,</span><br><span class="line">    &quot;tulips&quot;, &quot;blue paint&quot;]</span><br><span class="line">shoppingList[1] = &quot;bottle of water&quot;</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val shoppingList = arrayOf(&quot;catfish&quot;, &quot;water&quot;,</span><br><span class="line">    &quot;tulips&quot;, &quot;blue paint&quot;)</span><br><span class="line">shoppingList[1] = &quot;bottle of water&quot;</span><br></pre></td></tr></table></figure></p><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var occupations = [</span><br><span class="line">    &quot;Malcolm&quot;: &quot;Captain&quot;,</span><br><span class="line">    &quot;Kaylee&quot;: &quot;Mechanic&quot;,</span><br><span class="line">]</span><br><span class="line">occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot;</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val occupations = mutableMapOf(</span><br><span class="line">    &quot;Malcolm&quot; to &quot;Captain&quot;,</span><br><span class="line">    &quot;Kaylee&quot; to &quot;Mechanic&quot;</span><br><span class="line">)</span><br><span class="line">occupations[&quot;Jayne&quot;] = &quot;Public Relations&quot;</span><br></pre></td></tr></table></figure></p><h2 id="空集合"><a href="#空集合" class="headerlink" title="空集合"></a>空集合</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let emptyArray = [String]()</span><br><span class="line">let emptyDictionary = [String: Float]()</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val emptyArray = arrayOf&lt;String&gt;()</span><br><span class="line">val emptyMap = mapOf&lt;String, Float&gt;()</span><br></pre></td></tr></table></figure></p><h1 id="FUNCTIONS"><a href="#FUNCTIONS" class="headerlink" title="FUNCTIONS"></a>FUNCTIONS</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func greet(_ name: String,_ day: String) -&gt; String &#123;</span><br><span class="line">    return &quot;Hello \(name), today is \(day).&quot;</span><br><span class="line">&#125;</span><br><span class="line">greet(&quot;Bob&quot;, &quot;Tuesday&quot;)</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun greet(name: String, day: String): String &#123;</span><br><span class="line">    return &quot;Hello $name, today is $day.&quot;</span><br><span class="line">&#125;</span><br><span class="line">greet(&quot;Bob&quot;, &quot;Tuesday&quot;)</span><br></pre></td></tr></table></figure></p><h2 id="元组返回"><a href="#元组返回" class="headerlink" title="元组返回"></a>元组返回</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func getGasPrices() -&gt; (Double, Double, Double) &#123;</span><br><span class="line">    return (3.59, 3.69, 3.79)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data class GasPrices(val a: Double, val b: Double,</span><br><span class="line">     val c: Double)</span><br><span class="line">fun getGasPrices() = GasPrices(3.59, 3.69, 3.79)</span><br></pre></td></tr></table></figure></p><h2 id="参数的变量数目（Variable-Number-Of-Arguments）"><a href="#参数的变量数目（Variable-Number-Of-Arguments）" class="headerlink" title="参数的变量数目（Variable Number Of Arguments）"></a>参数的变量数目（Variable Number Of Arguments）</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func sumOf(_ numbers: Int...) -&gt; Int &#123;</span><br><span class="line">    var sum = 0</span><br><span class="line">    for number in numbers &#123;</span><br><span class="line">        sum += number</span><br><span class="line">    &#125;</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br><span class="line">sumOf(42, 597, 12)</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun sumOf(vararg numbers: Int): Int &#123;</span><br><span class="line">    var sum = 0</span><br><span class="line">    for (number in numbers) &#123;</span><br><span class="line">        sum += number</span><br><span class="line">    &#125;</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br><span class="line">sumOf(42, 597, 12)</span><br><span class="line"></span><br><span class="line">// sumOf() can also be written in a shorter way:</span><br><span class="line">fun sumOf(vararg numbers: Int) = numbers.sum()</span><br></pre></td></tr></table></figure></p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func makeIncrementer() -&gt; (Int -&gt; Int) &#123;</span><br><span class="line">    func addOne(number: Int) -&gt; Int &#123;</span><br><span class="line">        return 1 + number</span><br><span class="line">    &#125;</span><br><span class="line">    return addOne</span><br><span class="line">&#125;</span><br><span class="line">let increment = makeIncrementer()</span><br><span class="line">increment(7)</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun makeIncrementer(): (Int) -&gt; Int &#123;</span><br><span class="line">    val addOne = fun(number: Int): Int &#123;</span><br><span class="line">        return 1 + number</span><br><span class="line">    &#125;</span><br><span class="line">    return addOne</span><br><span class="line">&#125;</span><br><span class="line">val increment = makeIncrementer()</span><br><span class="line">increment(7)</span><br><span class="line"></span><br><span class="line">// makeIncrementer can also be written in a shorter way:</span><br><span class="line">fun makeIncrementer() = fun(number: Int) = 1 + number</span><br></pre></td></tr></table></figure></p><h2 id="映射-1"><a href="#映射-1" class="headerlink" title="映射"></a>映射</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let numbers = [20, 19, 7, 12]</span><br><span class="line">numbers.map &#123; 3 * $0 &#125;</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val numbers = listOf(20, 19, 7, 12)</span><br><span class="line">numbers.map &#123; 3 * it &#125;</span><br></pre></td></tr></table></figure></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mutableArray = [1, 5, 3, 12, 2]</span><br><span class="line">mutableArray.sort()</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listOf(1, 5, 3, 12, 2).sorted()</span><br></pre></td></tr></table></figure></p><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func area(width: Int, height: Int) -&gt; Int &#123;</span><br><span class="line">    return width * height</span><br><span class="line">&#125;</span><br><span class="line">area(width: 2, height: 3)</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun area(width: Int, height: Int) = width * height</span><br><span class="line">area(width = 2, height = 3)</span><br><span class="line"></span><br><span class="line">// This is also possible with named arguments</span><br><span class="line">area(2, height = 2)</span><br><span class="line">area(height = 3, width = 2)</span><br></pre></td></tr></table></figure></p><h1 id="CLASSES"><a href="#CLASSES" class="headerlink" title="CLASSES"></a>CLASSES</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">    var numberOfSides = 0</span><br><span class="line">    func simpleDescription() -&gt; String &#123;</span><br><span class="line">        return &quot;A shape with \(numberOfSides) sides.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">    var numberOfSides = 0</span><br><span class="line">    fun simpleDescription() =</span><br><span class="line">        &quot;A shape with $numberOfSides sides.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var shape = Shape()</span><br><span class="line">shape.numberOfSides = 7</span><br><span class="line">var shapeDescription = shape.simpleDescription()</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var shape = Shape()</span><br><span class="line">shape.numberOfSides = 7</span><br><span class="line">var shapeDescription = shape.simpleDescription()</span><br></pre></td></tr></table></figure></p><h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class NamedShape &#123;</span><br><span class="line">    var numberOfSides: Int = 0</span><br><span class="line">    let name: String</span><br><span class="line"></span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func simpleDescription() -&gt; String &#123;</span><br><span class="line">        return &quot;A shape with \(numberOfSides) sides.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Square: NamedShape &#123;</span><br><span class="line">    var sideLength: Double</span><br><span class="line"></span><br><span class="line">    init(sideLength: Double, name: String) &#123;</span><br><span class="line">        self.sideLength = sideLength</span><br><span class="line">        super.init(name: name)</span><br><span class="line">        self.numberOfSides = 4</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func area() -&gt; Double &#123;</span><br><span class="line">        return sideLength * sideLength</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override func simpleDescription() -&gt; String &#123;</span><br><span class="line">        return &quot;A square with sides of length &quot; +</span><br><span class="line">       sideLength + &quot;.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let test = Square(sideLength: 5.2, name: &quot;square&quot;)</span><br><span class="line">test.area()</span><br><span class="line">test.simpleDescription()</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">open class NamedShape(val name: String) &#123;</span><br><span class="line">    var numberOfSides = 0</span><br><span class="line"></span><br><span class="line">    open fun simpleDescription() =</span><br><span class="line">        &quot;A shape with $numberOfSides sides.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Square(var sideLength: BigDecimal, name: String) :</span><br><span class="line">        NamedShape(name) &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        numberOfSides = 4</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun area() = sideLength.pow(2)</span><br><span class="line"></span><br><span class="line">    override fun simpleDescription() =</span><br><span class="line">        &quot;A square with sides of length $sideLength.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val test = Square(BigDecimal(&quot;5.2&quot;), &quot;square&quot;)</span><br><span class="line">test.area()</span><br><span class="line">test.simpleDescription()</span><br></pre></td></tr></table></figure></p><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var movieCount = 0</span><br><span class="line">var songCount = 0</span><br><span class="line"></span><br><span class="line">for item in library &#123;</span><br><span class="line">    if item is Movie &#123;</span><br><span class="line">        movieCount += 1</span><br><span class="line">    &#125; else if item is Song &#123;</span><br><span class="line">        songCount += 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var movieCount = 0</span><br><span class="line">var songCount = 0</span><br><span class="line"></span><br><span class="line">for (item in library) &#123;</span><br><span class="line">    if (item is Movie) &#123;</span><br><span class="line">        ++movieCount</span><br><span class="line">    &#125; else if (item is Song) &#123;</span><br><span class="line">        ++songCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let nb = 42</span><br><span class="line">switch nb &#123;</span><br><span class="line">    case 0...7, 8, 9: print(&quot;single digit&quot;)</span><br><span class="line">    case 10: print(&quot;double digits&quot;)</span><br><span class="line">    case 11...99: print(&quot;double digits&quot;)</span><br><span class="line">    case 100...999: print(&quot;triple digits&quot;)</span><br><span class="line">    default: print(&quot;four or more digits&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val nb = 42</span><br><span class="line">when (nb) &#123;</span><br><span class="line">    in 0..7, 8, 9 -&gt; println(&quot;single digit&quot;)</span><br><span class="line">    10 -&gt; println(&quot;double digits&quot;)</span><br><span class="line">    in 11..99 -&gt; println(&quot;double digits&quot;)</span><br><span class="line">    in 100..999 -&gt; println(&quot;triple digits&quot;)</span><br><span class="line">    else -&gt; println(&quot;four or more digits&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="类型向下转换"><a href="#类型向下转换" class="headerlink" title="类型向下转换"></a>类型向下转换</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for current in someObjects &#123;</span><br><span class="line">    if let movie = current as? Movie &#123;</span><br><span class="line">        print(&quot;Movie: &apos;\(movie.name)&apos;, &quot; +</span><br><span class="line">            &quot;dir. \(movie.director)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (current in someObjects) &#123;</span><br><span class="line">    if (current is Movie) &#123;</span><br><span class="line">        println(&quot;Movie: &apos;$&#123;current.name&#125;&apos;, &quot; +</span><br><span class="line">    &quot;dir. $&#123;current.director&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protocol Nameable &#123;</span><br><span class="line">    func name() -&gt; String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func f&lt;T: Nameable&gt;(x: T) &#123;</span><br><span class="line">    print(&quot;Name is &quot; + x.name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Nameable &#123;</span><br><span class="line">    fun name(): String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun f&lt;T: Nameable&gt;(x: T) &#123;</span><br><span class="line">    println(&quot;Name is &quot; + x.name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>Swift<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">extension Double &#123;</span><br><span class="line">    var km: Double &#123; return self * 1_000.0 &#125;</span><br><span class="line">    var m: Double &#123; return self &#125;</span><br><span class="line">    var cm: Double &#123; return self / 100.0 &#125;</span><br><span class="line">    var mm: Double &#123; return self / 1_000.0 &#125;</span><br><span class="line">    var ft: Double &#123; return self / 3.28084 &#125;</span><br><span class="line">&#125;</span><br><span class="line">let oneInch = 25.4.mm</span><br><span class="line">print(&quot;One inch is \(oneInch) meters&quot;)</span><br><span class="line">// prints &quot;One inch is 0.0254 meters&quot;</span><br><span class="line">let threeFeet = 3.ft</span><br><span class="line">print(&quot;Three feet is \(threeFeet) meters&quot;)</span><br><span class="line">// prints &quot;Three feet is 0.914399970739201 meters&quot;</span><br></pre></td></tr></table></figure></p><p>Kotlin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val Double.km: Double get() = this * 1000</span><br><span class="line">val Double.m: Double get() = this</span><br><span class="line">val Double.cm: Double get() = this / 100</span><br><span class="line">val Double.mm: Double get() = this / 1000</span><br><span class="line">val Double.ft: Double get() = this / 3.28084</span><br><span class="line"></span><br><span class="line">val oneInch = 25.4.mm</span><br><span class="line">println(&quot;One inch is $oneInch meters&quot;)</span><br><span class="line">// prints &quot;One inch is 0.0254 meters&quot;</span><br><span class="line">val threeFeet = 3.0.ft</span><br><span class="line">println(&quot;Three feet is $threeFeet meters&quot;)</span><br><span class="line">// prints &quot;Three feet is 0.914399970739201 meters&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      Swift 与 Kotlin 的简单对比
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
      <category term="Kotlin" scheme="http://localhost/categories/Java/Kotlin/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
      <category term="Swift" scheme="http://localhost/tags/Swift/"/>
    
      <category term="Kotlin" scheme="http://localhost/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>在 Java 8 中避免 Null 检查</title>
    <link href="http://localhost/2018/04/03/Java/jdk8/%E5%9C%A8%20Java%208%20%E4%B8%AD%E9%81%BF%E5%85%8D%20Null%20%E6%A3%80%E6%9F%A5/"/>
    <id>http://localhost/2018/04/03/Java/jdk8/在 Java 8 中避免 Null 检查/</id>
    <published>2018-04-03T05:11:06.286Z</published>
    <updated>2018-04-03T05:13:01.524Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来源：ostatsu，</p><p><a href="http://www.oschina.net/translate/avoid-null-checks-in-java" target="_blank" rel="noopener">www.oschina.net/translate/avoid-null-checks-in-java</a></p></blockquote><p>如何预防 Java 中著名的 NullPointerException 异常？这是每个 Java 初学者迟早会问到的关键问题之一。而且中级和高级程序员也在时时刻刻规避这个错误。其是迄今为止 Java 以及很多其他编程语言中最流行的一种错误。</p><p>Null 引用的发明者 Tony Hoare 在 2009 年道歉，并称这种错误为他的十亿美元错误。</p><blockquote><p>我将其称之为自己的十亿美元错误。它的发明是在1965 年，那时我用一个面向对象语言（ALGOL W）设计了第一个全面的引用类型系统。我的目的是确保所有引用的使用都是绝对安全的，编译器会自动进行检查。但是我未能抵御住诱惑，加入了 Null 引用，仅仅是因为实现起来非常容易。它导致了数不清的错误、漏洞和系统崩溃，可能在之后 40 年中造成了十亿美元的损失。</p></blockquote><p>无论如何，我们必须要面对它。所以，我们到底能做些什么来防止 NullPointerException 异常呢？那么，答案显然是对其添加 null 检查。由于 null 检查还是挺麻烦和痛苦的，很多语言为了处理 null 检查添加了特殊的语法，即空合并运算符 —— 其在像 Groovy 或 Kotlin 这样的语言中也被称为 Elvis 运算符。</p><p>不幸的是 Java 没有提供这样的语法糖。但幸运的是这在 Java 8 中得到了改善。这篇文章介绍了如何利用像 lambda 表达式这样的 Java 8 新特性来防止编写不必要的 null 检查的几个技巧。</p><h1 id="在-Java-8-中提高-Null-的安全性"><a href="#在-Java-8-中提高-Null-的安全性" class="headerlink" title="在 Java 8 中提高 Null 的安全性"></a>在 Java 8 中提高 Null 的安全性</h1><p>我已经在另一篇文章中说明了我们可以如何利用 Java 8 的 Optional 类型来预防 null 检查。下面是那篇文章中的示例代码。</p><p><a href="http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/" target="_blank" rel="noopener">http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/</a></p><p>假设我们有一个像这样的类层次结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Nested nested;</span><br><span class="line"></span><br><span class="line">    <span class="function">Nested <span class="title">getNested</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nested;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Inner inner;</span><br><span class="line"></span><br><span class="line">    <span class="function">Inner <span class="title">getInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String foo;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> foo;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决这种结构的深层嵌套路径是有点麻烦的。我们必须编写一堆 null 检查来确保不会导致一个 NullPointerException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (outer != <span class="keyword">null</span> &amp;&amp; outer.nested != <span class="keyword">null</span> &amp;&amp; outer.nested.inner != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(outer.nested.inner.foo);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过利用 Java 8 的 Optional 类型来摆脱所有这些 null 检查。map 方法接收一个 Function 类型的 lambda 表达式，并自动将每个 function 的结果包装成一个 Optional 对象。这使我们能够在一行中进行多个 map 操作。Null 检查是在底层自动处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Optional.of(<span class="keyword">new</span> Outer())</span><br><span class="line"></span><br><span class="line">    .map(Outer::getNested)</span><br><span class="line"></span><br><span class="line">    .map(Nested::getInner)</span><br><span class="line"></span><br><span class="line">    .map(Inner::getFoo)</span><br><span class="line"></span><br><span class="line">    .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><p>还有一种实现相同作用的方式就是通过利用一个 supplier 函数来解决嵌套路径的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Outer obj = <span class="keyword">new</span> Outer();</span><br><span class="line"></span><br><span class="line">resolve(() -&gt; obj.getNested().getInner().getFoo());</span><br><span class="line"></span><br><span class="line">    .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><p>调用 obj.getNested().getInner().getFoo()) 可能会抛出一个 NullPointerException 异常。在这种情况下，该异常将会被捕获，而该方法会返回 Optional.empty()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">resolve</span><span class="params">(Supplier&lt;T&gt; resolver)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        T result = resolver.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请记住，这两个解决方案可能没有传统 null 检查那么高的性能。不过在大多数情况下不会有太大问题。</p>]]></content>
    
    <summary type="html">
    
      如何预防 Java 中著名的 NullPointerException 异常？这是每个 Java 初学者迟早会问到的关键问题之一。而且中级和高级程序员也在时时刻刻规避这个错误。其是迄今为止 Java 以及很多其他编程语言中最流行的一种错误。
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
      <category term="JDK8" scheme="http://localhost/categories/Java/JDK8/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
      <category term="JDK8" scheme="http://localhost/tags/JDK8/"/>
    
  </entry>
  
  <entry>
    <title>JDK 10 的 109 项新特性</title>
    <link href="http://localhost/2018/04/03/Java/jdk10/JDK%2010%20%E7%9A%84%20109%20%E9%A1%B9%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://localhost/2018/04/03/Java/jdk10/JDK 10 的 109 项新特性/</id>
    <published>2018-04-03T05:03:28.879Z</published>
    <updated>2018-04-03T05:09:59.917Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>来源：开源中国，</p><p><a href="http://www.oschina.net/translate/109-new-features-in-jdk-10" target="_blank" rel="noopener">www.oschina.net/translate/109-new-features-in-jdk-10</a></p></blockquote><p>虽然感觉 JDK9 发布才仅仅几周的时间，然而，随着新的 OpenJDK 的发布节奏，JDK10 已经到达发布候选里程碑阶段。</p><p>我看过各种关于 JDK10 新特性的博客，但是它们都倾向于关注通过 JEPS 定义的大方面。这篇博文，我将看看是否可以罗列出 JDK10 中已经发生变化的方方面面（包括新增的和剔除的）。</p><p>有时候，我会做一些关于 Java SE 的报告会。之前我在“ JDK9 的 55 个新特性”的报告会上曾开玩笑说：下次我将做的恐怕是“ JDK10 的 5 个新特性”。然而事实证明，即使仅有六个多月的开发时间，JDK10 依然超乎想象。</p><p>即便我不再为 Oracle 工作，我也在此先做一个“安全港声明”，以便消除误会。这个列表是由下面这些公开可用的信息整理编辑的：JDK Enhancement Proposals (JEPs)、the OpenJDK bug database 和 Java SE 10 public review specification (JSR 383) 。当然，尽管我已尽可能的研究以保证信息准确，但在 JDK 10 最终发布之前仍可能会发生变化。</p><h1 id="大事记"><a href="#大事记" class="headerlink" title="大事记"></a>大事记</h1><p>JDK10 包含 12 个JEP (改善提议）：</p><p><strong>[286]局部变量类型推断</strong> ：对于开发者来说，这是 JDK10 唯一的真正特性。它向 Java 中引入在其他语言中很常见的  var   ，比如 JavaScript 。只要编译器可以推断此种类型，你不再需要专门声明一个局部变量的类型。一个简单的例子是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>这就消除了我们之前必须执行的 ArrayList<string> 类型定义的重复。我鼓励你们去读 JEP ，因为上面有一些关于这个句法是否能用的规则。</string></p><p>有趣的是，需要注意 var 不能成为一个关键字，而是一个保留字。这意味着你仍然可以使用 var 作为一个变量，方法或包名，但是现在（尽管我确定你绝不会）你不能再有一个类被调用。</p><p><strong>[310]应用类数据共享(CDS)</strong> ：CDS 在 JDK5 时被引进以改善 JVM 启动的表现，同时减少当多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用。JDK10 将扩展 CDS 到允许内部系统的类加载器、内部平台的类加载器和自定义类加载器来加载获得的类。之前，CDS 的使用仅仅限制在了 bootstrap 的类加载器。</p><p><strong>[314]额外的 Unicode 语言标签扩展</strong>：这将改善 java.util.Locale 类和相关的 API 以实现额外 BCP 47 语言标签的 Unicode 扩展。尤其是，货币类型，一周的第一天，区域覆盖和时区等标签现在将被支持。</p><p><strong>[322]基于时间的版本控制</strong>：正如我在之前的博客中所讨论的，我们的 JDK 版本字符串格式几乎与 JDK 版本一样多。有幸的是，这是最后需要使用到的，我们可以坚持用它。这种格式使用起来很像 JDK9 中介绍的提供一个更加语义的形式。有一件困扰我的事是包含了一个 INTERIM 元素，正如 JEP 提议中所说，“永远是0”。好吧，如果永远是0，那它有什么意义呢？他们说这是为未来使用做保留，但我仍不是很赞同。我认为，这有些冗余繁杂。这也消除了在 JDK9 中有过的相当奇怪的情形。第一次更新是 JDK 9.0.1 , 非常符合逻辑。第二次更新是 JDK 9.0.4 ，不合逻辑。原因是，在 JDK9 的版本计数模式下，需要留下空白以便应急或不在预期安排的更新使用。但既然没有更新是必须的，为什么不简单称之为 JDK 9.0.2 呢？</p><p><strong>[319]根证书</strong>：在 JDK 中将提供一套默认的 CA 根证书。关键的安全部件，如 TLS ，在 OpenJDK 构建中将默认有效。这是 Oracle 正在努力确保 OpenJDK 二进制和 Oracle JDK 二进制功能上一样的工作的一部分，是一项有用的补充内容。</p><p><strong>[307] 并行全垃圾回收器 G1</strong> : G1 是设计来作为一种低延时的垃圾回收器（但是如果它跟不上旧的堆碎片产生的提升速率的话，将仍然采用完整压缩集合）。在 JDK9 之前，默认的收集器是并行，吞吐，收集器。为了减少在使用默认的收集器的应用性能配置文件的差异，G1 现在有一个并行完整收集机制。</p><p><strong>[313]移除 Native-Header 自动生成工具</strong>：Java9 开始了一些对 JDK 的家务管理，这项特性是对它的延续。当编译 JNI 代码时，已不再需要单独的工具来生成头文件，因为这可以通过 javac 完成。在未来的某一时刻，JNI 将会被 Panama 项目的结果取代，但是何时发生还不清楚。</p><p><strong>[304]垃圾回收器接口</strong>: 这不是让开发者用来控制垃圾回收的接口；而是一个在 JVM 源代码中的允许另外的垃圾回收器快速方便的集成的接口。</p><p><strong>[312]线程-局部变量管控</strong>：这是在 JVM 内部相当低级别的更改，现在将允许在不运行全局虚拟机安全点的情况下实现线程回调。这将使得停止单个线程变得可能和便宜，而不是只能启用或停止所有线程。</p><p><strong>[316]在备用存储装置上的堆分配</strong>：硬件技术在持续进化，现在可以使用与传统 DRAM 具有相同接口和类似性能特点的非易失性 RAM 。这项 JEP 将使得 JVM 能够使用适用于不同类型的存储机制的堆。</p><p><strong>[317] 试验性的基于 Java 的 JIT 编译器</strong>：最近宣布的 Metropolis 项目，提议用 Java 重写大部分 JVM 。乍一想，觉得很奇怪。如果 JVM 是用 Java 编写的，那么是否需要一个 JVM 来运行 JVM ？ 相应的，这导致了一个很好的镜像类比。 现实情况是，使用 Java 编写 JVM 并不意味着必须将其编译为字节码，你可以使用 AOT 编译，然后在运行时编译代码以提高性能。这项 JEP 将 Graal 编译器研究项目引入到 JDK 中。并给将 Metropolis 项目成为现实，使 JVM 性能与当前 C++ 所写版本匹敌（或有幸超越）提供基础。</p><p><strong>[296]: 合并 JDK 多个代码仓库到一个单独的储存库中</strong>：在 JDK9 中，有 8 个仓库： root、corba、hotspot、jaxp、jaxws、jdk、langtools 和 nashorn 。在 JDK10 中这些将被合并为一个，使得跨相互依赖的变更集的存储库运行 atomic commit （原子提交）成为可能。</p><h1 id="新-API"><a href="#新-API" class="headerlink" title="新 API"></a>新 API</h1><p>有 73 项新增内容添加到了标准类库中。</p><p>java.awt.Toolkit</p><p>int getMenuShortcutKeyMaskEx(): 确定哪个扩展修饰符键是菜单快捷键的适当加速键。</p><p>java.awt.geom.Path2D:</p><p>void trimToSize(): 将此 Path2D 实例的容量计算到它当前的大小。应用可使用此操作将路径的存储空间最小化。这个方法也被添加到 Path2D.Double 和 Path2D.Float 类。</p><p>java.io.ByteArrayOutputStream:</p><p>String toString(Charset): 重载 toString()，通过使用指定的字符集解码字节，将缓冲区的内容转换为字符串。</p><p>java.io.PrintStream:</p><p>lang.io.PrintWriter:</p><p>这两个类都有三个新的构造函数，它们需要额外的 Charset 参数。</p><p>java.io.Reader:</p><p>long transferTo(Writer): 从这个 Reader 中读取所有字符，并按照所读的顺序将字符写入给定的 Writer 。</p><p>java.lang.Runtime.Version:</p><p>有四种新方法返回新（JEP 322）版本字符串字段的整数值: feature()、interim()、patch() 和 update() 。</p><p>java.lang.StackWalker.StackFrame:</p><p>String getDescriptor(): 按照 JVM 标准返回此堆栈帧所代表的方法的描述符。</p><p>String getMethodType():返回此堆栈帧所代表的方法类型，描述参数类型和返回值类型。</p><p>java.lang.invoke.MethodType:</p><p>Class&lt;?&gt; lastParameterType():返回这个方法类型的最后一个参数类型。如果这个方法类型没有参数，则返回空类型作为岗哨值（Sentinel Value）。</p><p>java.lang.management.RuntimeMXBean:</p><p>long getPid(): R 返回正在运行的 JVM 的进程 ID 。</p><p>java.lang.management.ThreadMXBean:</p><ul><li>ThreadInfo[] dumpAllThreads(boolean, boolean, int): 返回所有活动线程的线程信息，其中有指定的最大元素数量和同步信息的堆栈跟踪。</li><li>ThreadInfo[] getThreadInfo(long[], boolean, boolean, int): 返回每个线程的线程信息，这些线程的标识位于输入数组中，其中有指定的最大元素数量和同步信息的堆栈跟踪。</li></ul><p>java.lang.reflect.MalformedParameterizedTypeException: 添加了一个新的构造函数，它以字符串的形式作为参数来获取详细信息。</p><p>java.net.URLDecoder:</p><p>java.net.URLEncoder:</p><p>这两个类都有新的重载的解码和编码方法，将 charset 作为附加参数。</p><p>java.nio.channels.Channels:</p><p>两个新的静态重载方法，允许使用 Charset 的 newReader（ReadByteChannel，Charset）和newWriter（WriteByteChannel，Charset）。</p><p>java.nio.file.FileStore:</p><p>long getBlockSize(): 在这个文件存储中返回每个块的字节数。</p><p>java.time.chrono: 这个包里有三个类，HijrahEra、MiinguoEra 和 ThaiBuddhistEra ，都有同样的方法。</p><p>String getDisplayName(TextStyle, Locale): 这将返回用于识别 era 的文本名称，适合于向用户展示。</p><p>java.time.format.DateTimeFormatter:</p><p>localizedBy(Locale): 返回指定格式器的一个副本，其中包含地区、日历、区域、小数和/或时区的本地化值，这将取代该格式器中的值。</p><p>java.util: DoubleSummaryStatistics、IntSummaryStatistics 和 LongSummaryStatistics 都有一个新的构造函数，它包含 4 个数值。它使用指定的计数、最小值、最大值和总和构造一个非空实例。</p><p>java.util.List:</p><p>java.util.Map:</p><p>java.util.Set: 这些接口中的每一个都增加了一个新的静态方法，copyOf(Collection）。这些函数按照其迭代顺序返回一个不可修改的列表、映射或包含给定集合的元素的集合。</p><p>java.util.Optional:</p><p>java.util.OptionalDouble:</p><p>java.util.OptionalInt:</p><p>java.util.OptionalLong: 每一个类都有一个新的方法，orElseThrow() ，它本质上和 get() 一样，也就是说，如果 Optional 有值则返回。否则，将抛出 NoSuchElementException 。</p><p>java.util.Formatter:</p><p>java.util.Scanner:</p><p>这两个类都有三个新的构造函数，除了其他参数之外，它们都带有一个 charset 参数。</p><h1 id="其它翻译版本-1"><a href="#其它翻译版本-1" class="headerlink" title="其它翻译版本(1)"></a>其它翻译版本(1)</h1><p>java.util.Properties: 这有一个新的构造函数，它接受一个 int 参数。这将创建一个没有默认值的空属性列表，并且指定初始大小以容纳指定的元素数量，而无需动态调整大小。还有一个新的重载的 replace 方法，接受三个 Object 参数并返回一个布尔值。只有在当前映射到指定值时，才会替换指定键的条目。</p><p>java.SplittableRandom:</p><p>void nextBytes(byte[]): 用生成的伪随机字节填充一个用户提供的字节数组。</p><p>java.util.concurrent.FutureTask: 添加了 toString() 方法，该方法返回一个标识 FutureTask 的字符串，以及它的完成状态。在括号中，状态包含如下字符串中的一个，“Completed Normally” 、“Completed Exceptionally”、 “Cancelled” 或者 “Not completed”。</p><p>java.util.concurrent.locks.StampedLock:</p><ul><li><p>boolean isLockStamp(long): 返回一个标记戳表示是否持有一个锁。</p></li><li><p>boolean isOptimisticReadStamp(long): 返回一个标记戳代表是否成功的进行了乐观读（optimistic read）。</p></li><li><p>boolean isReadLockStamp(long): 返回一个标记戳表示是否持有一个非独占锁（即 read lock ）。</p></li><li><p>boolean isWriteLockStamp(long): 返回一个标记戳表示是否持有一个独占锁（即 write lock ）。</p></li></ul><p>java.jar.JarEntry:</p><p>String getRealName(): 返回这个 JarEntry 的真实名称。如果这个 JarEntry 是一个多版本 jar 文件的入口，它被配置为这样处理，这个方法返回的名字是 JarEntry 所代表的版本条目的入口，而不是 ZipEntry.getName（） 返回的基本条目的路径名。如果 JarEntry 不代表一个多版本 jar 文件的版本化条目或者 jar 文件没有被配置为作为一个多版本 jar 文件进行处理，这个方法将返回与 ZipEntry.getName（） 返回的相同名称。</p><p>java.util.jar.JarFile:</p><p>Stream<jarentry> versionedStream(): 返回 jar 文件中指定版本的入口对应 Stream 。与 JarEntry 的 getRealName 方法类似，这与多版本 jar 文件有关。</jarentry></p><p>java.util.spi.LocaleNameProvider:</p><p>getDisplayUnicodeExtensionKey(String, Locale): 为给定的 Unicode 扩展键返回一个本地化名称。</p><p>getDisplayUnicodeExtensionType(String, String, Locale): 为给定的 Unicode 扩展键返回一个本地化名称。</p><p>java.util.stream.Collectors:</p><p>toUnmodifiableList():</p><p>toUnmodifiableSet():</p><p>toUnmodifiableMap(Function, Function):</p><p>toUnmodifiableMap(Function, Function, BinaryOperator): 这四个新方法都返回 Collectors ，将输入元素聚集到适当的不可修改的集合中。</p><p>java.lang.model.SourceVersion: 现在有了一个字段，它代表了 JDK 10 的版本。</p><p>java.lang.model.util.TypeKindVisitor6:</p><p>javax.lang.model.util.TypeKindVisitor9:</p><p>（我必须承认，我从来没听说过这些类）</p><p>R visitNoTypeAsModule(NoType, P): 访问一个 MODULE 的 pseudo-type 。我不确定为什么只有这两个类得到这个方法，因为还有 Visitor7 和 Visitor8 变量。</p><p>javax.remote.management.rmi.RMIConnectorServer:</p><p>这个类已经添加了两个字段： CREDENTIALS_FILTER_PATTERN 和 SERIAL_FILTER_PATTERN 。</p><p>javax.ButtonModel：看，Swing 还在更新！</p><p>ButtonGroup getGroup(): 返回按钮所属的组。通常用于单选按钮，它们在组中是互斥的。</p><p>javax.plaf.basic.BasicMenuUI:</p><p>Dimension getMinimumSize(JComponent): 返回指定组件适合观感的最小大小。</p><h1 id="JVM-规范改动"><a href="#JVM-规范改动" class="headerlink" title="JVM 规范改动"></a>JVM 规范改动</h1><p>这些改动相当小：</p><ul><li><p>4.6节：类文件格式（第99页）。在方法访问标志方面有小的改动。</p></li><li><p>4.7节：模块属性（第169页）。如果模块不是 java.base ，则 JDK 10 不再允许设置 ACC_TRANSITIVE 或 ACC_STATIC_PHASE 。</p></li><li><p>4.10节：类文件的校验（第252页）。dup2 指令已改变了 typesafe form 1 的定义，颠倒了 canSafleyPushList 一节中类型的顺序（你需要仔细查看才能发现它）。</p></li><li><p>5.2节：Java 虚拟机启动（第350页）。该描述添加了在创建初始类或接口时可使用用户定义的类加载器（ bootstrap 类加载器除外）。</p></li></ul><h1 id="对-Java-语言规范的更改"><a href="#对-Java-语言规范的更改" class="headerlink" title="对 Java 语言规范的更改"></a>对 Java 语言规范的更改</h1><p>这里还有一些更改，但主要是为了支持局部变量类型推断。</p><ul><li><p>第3.8节：标识符（第23页）。在忽略了可忽略的字符之后，标识符的等价性现在被考虑了。这似乎是合乎逻辑的。</p></li><li><p>（第24页）一个新的 Token，TypeIdentifier，它支持对局部变量类型推断的新用法，而 var 的使用不是关键字，而是一个具有特殊含义的标识符，作为局部变量声明的类型。</p></li><li><p>第4.10.5节：类型预测（第76页）。这是一个相当复杂的部分，它涉及到捕获变量、嵌套类以及如何使用局部变量类型推断。我建议你阅读规范中的这一部分，而不是试图解释它。</p></li><li><p>第6.1节：声明（第134页）。一个反映使用 TypeIdentifier 来支持局部变量类型的推断的小改动。</p></li><li><p>第6.5节：确定名字的含义（第153页，第158页和第159页）。根据类型标识符的使用而更改类类型。</p></li><li><p>第6.5.4.1:简单的 PackageOrTypeNames（第160页）</p></li><li><p>第6.5.4.2节：合规的 PackageOrTypeNames（第160页）。这两种方式都与使用 TypeIdentifier 有细微的变化。</p></li><li><p>第7.5.3:单静态导入声明（第191页）。这改变了导入具有相同名称的静态类型的规则。除非类型是相同的，否则这将成为一个错误，在这种情况下，重复被忽略。</p></li><li><p>第7.7.1:依赖（第198页）。如果你明确声明一个模块需要 java.base ，那在必要的关键字之后，你就不能再使用修饰符（例如静态）了。</p></li><li><p>第8部分：正式参数（第244页）。接收者参数可能只出现在一个实例方法的 formalparameters 列表，或者是一个内部类的构造函数中，其中内部类没有在静态上下文中声明。</p></li><li><p>第9.7.4节：注释可能出现的地方（第335页）。有一个与局部变量类型推断相关的变更。</p></li><li><p>第14.4部分：局部变量声明语句（第433页）。实现局部变量类型推断所需的大量更改。</p></li><li><p>第14节：增强的 for 语句（第455页）。这个结构已经更新，包括对局部变量类型推断的支持。</p></li><li><p>第14.20.3节:try-with-resources（474页）。这个结构已经更新，包括对局部变量类型推断的支持。</p></li></ul><p>最后，第 19 章有多处语法更新，反映了应更多使用 TypeIdentifier 类型标识符，而不仅仅是 Identifier 标识符，以支持局部变量类型推断。</p>]]></content>
    
    <summary type="html">
    
      虽然感觉 JDK9 发布才仅仅几周的时间，然而，随着新的 OpenJDK 的发布节奏，JDK10 已经到达发布候选里程碑阶段。
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
      <category term="JDK10" scheme="http://localhost/categories/Java/JDK10/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
      <category term="JDK10" scheme="http://localhost/tags/JDK10/"/>
    
  </entry>
  
  <entry>
    <title>MySQL5.7解压包安装教程</title>
    <link href="http://localhost/2018/04/03/Linux/mysql57/"/>
    <id>http://localhost/2018/04/03/Linux/mysql57/</id>
    <published>2018-04-03T04:59:59.477Z</published>
    <updated>2018-04-03T05:01:01.390Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>创建配置文件<br> 创建 my.ini 文件</p> <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">basedir</span>=C:\\soft\mysql-<span class="number">5.7</span>.<span class="number">21</span>-winx64</span><br><span class="line"><span class="attr">datadir</span>=C:\\soft\mysql-<span class="number">5.7</span>.<span class="number">21</span>-winx64\data</span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br></pre></td></tr></table></figure></li><li><p>初始化Data目录</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize --user=mysql --console</span><br></pre></td></tr></table></figure><p> 记录下默认密码</p></li><li><p>创建MySQL服务</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld -install</span><br></pre></td></tr></table></figure></li><li><p>启动MySQL</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure></li><li><p>修改密码</p><ol><li><p>登录root</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure></li><li><p>修改密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> = <span class="keyword">PASSWORD</span>(<span class="string">'root'</span>);</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="MySQL" scheme="http://localhost/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://localhost/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux 文件权限管理剖析</title>
    <link href="http://localhost/2018/04/02/Linux/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%89%96%E6%9E%90/"/>
    <id>http://localhost/2018/04/02/Linux/文件权限管理剖析/</id>
    <published>2018-04-02T00:18:56.342Z</published>
    <updated>2018-04-02T00:24:00.123Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 系统中，为了保证文件的安全，对文件所有者、同组用户、其他用户的访问权限进行了分别管理。其中，文件所有者，即建立文件或目录的用户。同组用户，是所属组群中的所有用户。其他用户，指的是既不是文件所有者，也不是同组用户的其他用户。<br><img src="http://7xivgs.com1.z0.glb.clouddn.com/Linux%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""><br>此外，每个文件和目录都具有读取权限、写入权限和执行权限，这三个权限之间相互独立。<br>！<a href="http://7xivgs.com1.z0.glb.clouddn.com/Linux%20%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%8F%82%E7%85%A7%E8%A1%A8.PNG" target="_blank" rel="noopener"></a></p><h1 id="功能模式"><a href="#功能模式" class="headerlink" title="功能模式"></a>功能模式</h1><p>在Linux 系统中，每个文件的访问权限可以用 9 个字母表示，每 3 个字母表示一类用户权限，分别代表文件创建者、同组用户、其他用户。其中，r 表示读取权限，w 表示写入权限，x 表示执行权限。<br><img src="http://7xivgs.com1.z0.glb.clouddn.com/Linux%E7%94%A8%E6%88%B7%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><p>通过功能模式修改文件权限，有三个部分组成，包括对象、操作和权限。</p><p><img src="http://7xivgs.com1.z0.glb.clouddn.com/%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%BC%8F%E5%8F%82%E7%85%A7%E8%A1%A8.PNG" alt=""></p><p>假设需要增加同组用户写入权限，下面来看一个例子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod g+w /root/install.log</span><br></pre></td></tr></table></figure></p><h1 id="数字模式"><a href="#数字模式" class="headerlink" title="数字模式"></a>数字模式</h1><p>每一类用户的访问也可以通过数字的方式进行表示。</p><p><img src="http://7xivgs.com1.z0.glb.clouddn.com/%E6%95%B0%E5%AD%97%E6%A8%A1%E5%BC%8F%E5%8F%82%E7%85%A7%E8%A1%A8.PNG" alt=""></p><p>那么，通过数字模式就可以对常见的 Linux 文件权限操作进行归纳。</p><p><img src="http://7xivgs.com1.z0.glb.clouddn.com/%E5%B8%B8%E7%94%A8%E7%9A%84Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.PNG" alt=""></p><p>假设需要设置创建者可读可写可执行、同组用户可读、其他用户可读，下面来看一个例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 /root/install.log</span><br></pre></td></tr></table></figure><p>注意的是，只有文件创建者和超级用户才可以修改文件权限。s</p>]]></content>
    
    <summary type="html">
    
      在 Linux 系统中，为了保证文件的安全，对文件所有者、同组用户、其他用户的访问权限进行了分别管理。其中，文件所有者，即建立文件或目录的用户。同组用户，是所属组群中的所有用户。其他用户，指的是既不是文件所有者，也不是同组用户的其他用户。
    
    </summary>
    
      <category term="Linux" scheme="http://localhost/categories/Linux/"/>
    
      <category term="Shell" scheme="http://localhost/categories/Linux/Shell/"/>
    
    
      <category term="Linux" scheme="http://localhost/tags/Linux/"/>
    
      <category term="Shell" scheme="http://localhost/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Spring Data Jpa 最大分页 size --原创 彭应智</title>
    <link href="http://localhost/2018/03/31/Java/spring/Spring%20Data%20Jpa%E6%9C%80%E5%A4%A7%E5%88%86%E9%A1%B5size/"/>
    <id>http://localhost/2018/03/31/Java/spring/Spring Data Jpa最大分页size/</id>
    <published>2018-03-31T07:21:24.091Z</published>
    <updated>2018-03-31T07:37:28.372Z</updated>
    
    <content type="html"><![CDATA[<p>我们需要重写PageableHandlerMethodArgumentResolver这个Bean，<br>调用其中的setMaxPageSize()来配置最大分页的size。默认值为2000.</p><p>如下代码配置最大分页的size为Integer的最大值2147483647：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaginationConfiguration</span> <span class="keyword">extends</span> <span class="title">SpringDataWebConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageableHandlerMethodArgumentResolver <span class="title">pageableResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PageableHandlerMethodArgumentResolver pageableHandlerMethodArgumentResolver =</span><br><span class="line">                <span class="keyword">new</span> PageableHandlerMethodArgumentResolver(sortResolver());</span><br><span class="line"></span><br><span class="line">        pageableHandlerMethodArgumentResolver.setMaxPageSize(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pageableHandlerMethodArgumentResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      如果你在项目使用Jpa并遇到Pageable的size最大2000的问题，那么这篇文章将会对你有帮助。
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
      <category term="Spring" scheme="http://localhost/categories/Java/Spring/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
      <category term="Spring" scheme="http://localhost/tags/Spring/"/>
    
      <category term="原创" scheme="http://localhost/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="Spring Data Jpa" scheme="http://localhost/tags/Spring-Data-Jpa/"/>
    
  </entry>
  
  <entry>
    <title>Java 9 新特性概述</title>
    <link href="http://localhost/2018/03/31/Java/jdk9/Java%209%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0/"/>
    <id>http://localhost/2018/03/31/Java/jdk9/Java 9 新特性概述/</id>
    <published>2018-03-31T07:04:19.085Z</published>
    <updated>2018-03-31T07:13:20.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-平台-模块系统"><a href="#Java-平台-模块系统" class="headerlink" title="Java 平台 模块系统"></a>Java 平台 模块系统</h1><p>Java 平台模块系统，也就是 Project Jigsaw，把模块化开发实践引入到了 Java 平台中。在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。这对于目前流行的不可变基础设施的实践来说，镜像的大小的减少可以节省很多存储空间和带宽资源 。</p><p>模块化开发的实践在软件开发领域并不是一个新的概念。Java 开发社区已经使用这样的模块化实践有相当长的一段时间。主流的构建工具，包括 Apache Maven 和 Gradle 都支持把一个大的项目划分成若干个子项目。子项目之间通过不同的依赖关系组织在一起。每个子项目在构建之后都会产生对应的 JAR 文件。 在 Java9 中 ，已有的这些项目可以很容易的升级转换为 Java 9 模块 ，并保持原有的组织结构不变。</p><p>Java 9 模块的重要特征是在其工件（artifact）的根目录中包含了一个描述模块的 module-info.class 文 件。 工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件。这个文件由根目录中的源代码文件 module-info.java 编译而来。该模块声明文件可以描述模块的不同特征。模块声明文件中可以包含的内容如下：</p><ul><li>模块导出的包：使用 exports 可以声明模块对其他模块所导出的包。包中的 public 和 protected 类型，以及这些类型的 public 和 protected 成员可以被其他模块所访问。没有声明为导出的包相当于模块中的私有成员，不能被其他模块使用。</li><li>模块的依赖关系：使用 requires 可以声明模块对其他模块的依赖关系。使用 requires transitive 可 以把一个模块依赖声明为传递的。传递的模块依赖可以被依赖当前模块的其他模块所读取。 如果一个模块所导出的类型的型构中包含了来自它所依赖的模块的类型，那么对该模块的依赖应该声明为传递的。</li><li>服务的提供和使用：如果一个模块中包含了可以被 ServiceLocator 发现的服务接口的实现 ，需要使用 provides with 语句来声明具体的实现类 ；如果一个模块需要使用服务接口，可以使用 uses 语句来声明。<br>代码清单 1 中给出了一个模块声明文件的示例。在该声明文件中，模块 c om.mycompany.sample 导出了 Java 包 com.mycompany.sample。该模块依赖于模块 c om.mycompany.sample 。该模块也提供了服务接口 com.mycompany.common.DemoService 的实现类 c om.mycompany.sample.DemoServiceImpl 。</li></ul><p>清单 1. 模块声明示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> com.mycompany.sample &#123; </span><br><span class="line">    <span class="keyword">exports</span> com.mycompany.sample; </span><br><span class="line">    <span class="keyword">requires</span> com.mycompany.common; </span><br><span class="line">    provides com.mycompany.common.DemoService with</span><br><span class="line">        com.mycompany.sample.DemoServiceImpl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>模块系统中增加了模块路径的概念。模块系统在解析模块时，会从模块路径中进行查找。为了保持与之前 Java 版本的兼容性，CLASSPATH 依然被保留。所有的类型在运行时都属于某个特定的模块。对于从 CLASSPATH 中加载的类型，它们属于加载它们的类加载器对应的未命名模块。可以通过 Class 的 getModule()方法来获取到表示其所在模块的 Module 对象。</p><p>在 JVM 启动时，会从应用的根模块开始，根据依赖关系递归的进行解析，直到得到一个表示依赖关系的图。如果解析过程中出现找不到模块的情况，或是在模块路径的同一个地方找到了名称相同的模块，模块解析过程会终止，JVM 也会退出。Java 也提供了相应的 API 与模块系统进行交互。</p><h1 id="Jshell"><a href="#Jshell" class="headerlink" title="Jshell"></a>Jshell</h1><p>jshell 是 Java 9 新增的一个实用工具。jshell 为 Java 增加了类似 NodeJS 和 Python 中的读取-求值-打印循环（ Read-Evaluation-Print Loop ） 。 在 jshell 中 可以直接 输入表达式并查看其执行结果。当需要测试一个方法的运行效果，或是快速的对表达式进行求值时，jshell 都非常实用。只需要通过 jshell 命令启动 jshell，然后直接输入表达式即可。每个表达式的结果会被自动保存下来 ，以数字编号作为引用，类似 $1 和$2 这样的名称 。可以在后续的表达式中引用之前语句的运行结果。 在 jshell 中 ，除了表达式之外，还可以创建 Java 类和方法。jshell 也有基本的代码完成功能。</p><p>在代码清单 2 中，我们直接创建了一个方法 add。</p><p>清单 2. 在 jshell 中添加方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; int add(int x, int y) &#123; </span><br><span class="line">    ...&gt; return x + y; </span><br><span class="line">    ...&gt; &#125; </span><br><span class="line"> | created method add(int,int)</span><br></pre></td></tr></table></figure></p><p>接着就可以在 jshell 中直接使用这个方法，如 代码清单 3 所示。</p><p>清单 3. 在 jshell 中使用创建的方法<br><code>jshelljshell&gt; add(1, 2) $19 ==&gt; 3</code></p><h1 id="集合、Stream-和-Optional"><a href="#集合、Stream-和-Optional" class="headerlink" title="集合、Stream 和 Optional"></a>集合、Stream 和 Optional</h1><p>在集合上，Java 9 增加 了 List.of()、Set.of()、Map.of() 和 M ap.ofEntries()等工厂方法来创建不可变集合 ，如 代码清单 4 所示。</p><p>清单 4 . 创建不可变集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List.of(); </span><br><span class="line">List.of(<span class="string">"Hello"</span>, <span class="string">"World"</span>); </span><br><span class="line">List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Set.of(); </span><br><span class="line">Set.of(<span class="string">"Hello"</span>, <span class="string">"World"</span>); </span><br><span class="line">Set.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Map.of();</span><br><span class="line">Map.of(<span class="string">"Hello"</span>, <span class="number">1</span>, <span class="string">"World"</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>Stream 中增加了新的方法 ofNullable、dropWhile、takeWhile 和 iterate。在 代码清单 5 中，流中包含了从 1 到 5 的 元素。断言检查元素是否为奇数。第一个元素 1 被删除，结果流中包含 4 个元素。</p><p>清单 5 . Stream 中的 dropWhile 方法示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDropWhile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> count = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) </span><br><span class="line">        .dropWhile(i -&gt; i % <span class="number">2</span> != <span class="number">0</span>) </span><br><span class="line">        .count(); </span><br><span class="line">    assertEquals(<span class="number">4</span>, count); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Collectors 中增加了新的方法 filtering 和 flatMapping。在 代码清单 6 中，对于输入的 String 流 ，先通过 flatMapping 把 String 映射成 Integer 流 ，再把所有的 Integer 收集到一个集合中。</p><p>清单 6 . Collectors 的 flatMapping 方法示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFlatMapping</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    <span class="keyword">final</span> Set&lt;Integer&gt; result = Stream.of(<span class="string">"a"</span>, <span class="string">"ab"</span>, <span class="string">"abc"</span>) </span><br><span class="line">        .collect(Collectors.flatMapping(v -&gt; v.chars().boxed(), </span><br><span class="line">            Collectors.toSet())); </span><br><span class="line">    assertEquals(<span class="number">3</span>, result.size()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Optiona l 类中新增了 ifPresentOrElse、or 和 stream 等方法。在 代码清单 7 中，Optiona l 流中包含 3 个 元素，其中只有 2 个有值。在使用 flatMap 之后，结果流中包含了 2 个值。</p><p>清单 7 . Optional 的 stream 方法示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStream</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> count = Stream.of( </span><br><span class="line">        Optional.of(<span class="number">1</span>), </span><br><span class="line">        Optional.empty(), </span><br><span class="line">        Optional.of(<span class="number">2</span>) </span><br><span class="line">    ).flatMap(Optional::stream) </span><br><span class="line">        .count(); </span><br><span class="line">    assertEquals(<span class="number">2</span>, count); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h1><p>Java 9 增加了 ProcessHandle 接口，可以对原生进程进行管理，尤其适合于管理长时间运行的进程。在使用 P rocessBuilder 来启动一个进程之后，可以通过 Process.toHandle()方法来得到一个 ProcessHandl e 对象的实例。通过 ProcessHandle 可以获取到由 ProcessHandle.Info 表 示的进程的基本信息，如命令行参数、可执行文件路径和启动时间等。ProcessHandle 的 onExit()方法返回一个 C ompletableFuture<processhandle>对象，可以在进程结束时执行自定义的动作。 代码清单 8 中给出了进程 API 的使用示例。</processhandle></p><p>清单 8 . 进程API 示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ProcessBuilder processBuilder = <span class="keyword">new</span> ProcessBuilder(<span class="string">"top"</span>) </span><br><span class="line">    .inheritIO(); </span><br><span class="line"><span class="keyword">final</span> ProcessHandle processHandle = processBuilder.start().toHandle(); </span><br><span class="line">processHandle.onExit().whenCompleteAsync((handle, throwable) -&gt; &#123; </span><br><span class="line">    <span class="keyword">if</span> (throwable == <span class="keyword">null</span>) &#123; </span><br><span class="line">        System.out.println(handle.pid()); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        throwable.printStackTrace(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="平台日志-API-和-服务"><a href="#平台日志-API-和-服务" class="headerlink" title="平台日志 API 和 服务"></a>平台日志 API 和 服务</h1><p>Java 9 允许为 JDK 和应用配置同样的日志实现。新增的 System.LoggerFinder 用来管理 JDK 使 用的日志记录器实现。JVM 在运行时只有一个系统范围的 LoggerFinder 实例。LoggerFinder 通 过服务查找机制来加载日志记录器实现。默认情况下，JDK 使用 java.logging 模块中的 java.util.logging 实现。通过 LoggerFinder 的 getLogger()方法就可以获取到表示日志记录器的 System.Logger 实现。应用同样可以使用 System.Logger 来记录日志。这样就保证了 JDK 和应用使用同样的日志实现。我们也可以通过添加自己的 System.LoggerFinder 实现来让 JDK 和应用使用 SLF4J 等其他日志记录框架。 代码清单 9 中给出了平台日志 API 的使用示例。</p><p>清单 9.使用平台日志 API<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> System.Logger LOGGER = System.getLogger(<span class="string">"Main"</span>); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123; </span><br><span class="line">        LOGGER.log(Level.INFO, <span class="string">"Run!"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="反应式流-（-Reactive-Streams-）"><a href="#反应式流-（-Reactive-Streams-）" class="headerlink" title="反应式流 （ Reactive Streams ）"></a>反应式流 （ Reactive Streams ）</h1><p>反应式编程的思想最近得到了广泛的流行。 在 Java 平台上有流行的反应式 库 RxJava 和 R eactor。反应式流规范的出发点是提供一个带非阻塞负压（ non-blocking backpressure ） 的异步流处理规范。反应式流规范的核心接口已经添加到了 Java9 中的 java.util.concurrent.Flow 类中。</p><p>Flow 中包含了 Flow.Publisher、Flow.Subscriber、Flow.Subscription 和 F low.Processor 等 4 个核心接口。Java 9 还提供了 SubmissionPublisher 作为 Flow.Publisher 的一个实现。RxJava 2 和 Reactor 都可以很方便的 与 Flow 类的核心接口进行互操作。</p><h1 id="变量句柄"><a href="#变量句柄" class="headerlink" title="变量句柄"></a>变量句柄</h1><p>变量句柄是一个变量或一组变量的引用，包括静态域，非静态域，数组元素和堆外数据结构中的组成部分等。变量句柄的含义类似于已有的方法句柄。变量句柄由 J ava 类 java.lang.invoke.VarHandle 来表示。可以使用类 j ava.lang.invoke.MethodHandles.Looku p 中的静态工厂方法来创建 VarHandle 对 象。通过变量句柄，可以在变量上进行各种操作。这些操作称为访问模式。不同的访问模式尤其在内存排序上的不同语义。目前一共有 31 种 访问模式，而每种访问模式都 在 VarHandle 中 有对应的方法。这些方法可以对变量进行读取、写入、原子更新、数值原子更新和比特位原子操作等。VarHandle 还 可以用来访问数组中的单个元素，以及把 byte[]数组 和 ByteBuffer 当成是不同原始类型的数组来访问。</p><p>在 代码清单 10 中，我们创建了访问 HandleTarget 类中的域 count 的变量句柄，并在其上进行读取操作。</p><p>清单 10. 变量句柄使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleTarget</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarHandleTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HandleTarget handleTarget = <span class="keyword">new</span> HandleTarget(); </span><br><span class="line">    <span class="keyword">private</span> VarHandle varHandle; </span><br><span class="line">    <span class="meta">@Before</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.handleTarget = <span class="keyword">new</span> HandleTarget(); </span><br><span class="line">        <span class="keyword">this</span>.varHandle = MethodHandles </span><br><span class="line">            .lookup() </span><br><span class="line">            .findVarHandle(HandleTarget.class, <span class="string">"count"</span>, <span class="keyword">int</span>.class); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        assertEquals(<span class="number">1</span>, <span class="keyword">this</span>.varHandle.get(<span class="keyword">this</span>.handleTarget)); </span><br><span class="line">        assertEquals(<span class="number">1</span>, <span class="keyword">this</span>.varHandle.getVolatile(<span class="keyword">this</span>.handleTarget)); </span><br><span class="line">        assertEquals(<span class="number">1</span>, <span class="keyword">this</span>.varHandle.getOpaque(<span class="keyword">this</span>.handleTarget)); </span><br><span class="line">        assertEquals(<span class="number">1</span>, <span class="keyword">this</span>.varHandle.getAcquire(<span class="keyword">this</span>.handleTarget)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="改进方法句柄（Method-Handle）"><a href="#改进方法句柄（Method-Handle）" class="headerlink" title="改进方法句柄（Method Handle）"></a>改进方法句柄（Method Handle）</h1><p>类 java.lang.invoke.MethodHandles 增加了更多的静态方法来创建不同类型的方法句柄。</p><ul><li>arrayConstructor：创建指定类型的数组。</li><li>arrayLength：获取指定类型的数组的大小。</li><li>varHandleInvoker 和 varHandleExactInvoker：调用 VarHandle 中的访问模式方法。</li><li>zero：返回一个类型的默认值。</li><li>empty：返 回 MethodType 的返回值类型的默认值。</li><li>loop、countedLoop、iteratedLoop、whileLoop 和 doWhileLoop：创建不同类型的循环，包括 for 循环、while 循环 和 do-while 循环。</li><li>tryFinally：把对方法句柄的调用封装在 try-finally 语句中。<br>在 代码清单 11 中，我们使用 iteratedLoop 来创建一个遍历 S tring 类型迭代器的方法句柄，并计算所有字符串的长度的总和。</li></ul><p>清单 11. 循环方法句柄使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratedLoopTest</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">body</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> sum, <span class="keyword">final</span> String value)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> sum + value.length(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIteratedLoop</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; </span><br><span class="line">        <span class="keyword">final</span> MethodHandle iterator = MethodHandles.constant( </span><br><span class="line">            Iterator.class, </span><br><span class="line">            List.of(<span class="string">"a"</span>, <span class="string">"bc"</span>, <span class="string">"def"</span>).iterator()); </span><br><span class="line">        <span class="keyword">final</span> MethodHandle init = MethodHandles.zero(<span class="keyword">int</span>.class); </span><br><span class="line">        <span class="keyword">final</span> MethodHandle body = MethodHandles </span><br><span class="line">            .lookup() </span><br><span class="line">            .findStatic( </span><br><span class="line">                IteratedLoopTest.class, </span><br><span class="line">                <span class="string">"body"</span>, </span><br><span class="line">                MethodType.methodType( </span><br><span class="line">                    <span class="keyword">int</span>.class, </span><br><span class="line">                    <span class="keyword">int</span>.class, </span><br><span class="line">                    String.class)); </span><br><span class="line">        <span class="keyword">final</span> MethodHandle iteratedLoop = MethodHandles </span><br><span class="line">            .iteratedLoop(iterator, init, body); </span><br><span class="line">        assertEquals(<span class="number">6</span>, iteratedLoop.invoke()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>在并发方面，类 CompletableFuture 中增加了几个新的方法。completeAsync 使用一个异步任务来获取结果并完成该 CompletableFuture。orTimeout 在 CompletableFuture 没有在给定的超时时间之前完成，使用 TimeoutException 异常来完成 CompletableFuture。completeOnTimeout 与 o rTimeout 类似，只不过它在超时时使用给定的值来完成 CompletableFuture。新的 Thread.onSpinWai t 方法在当前线程需要使用忙循环来等待时，可以提高等待的效率。</p><h1 id="Nashorn"><a href="#Nashorn" class="headerlink" title="Nashorn"></a>Nashorn</h1><p>Nashorn 是 Java 8 中引入的新的 JavaScript 引擎。Java 9 中的 Nashorn 已经实现了一些 ECMAScript 6 规范中的新特性，包括模板字符串、二进制和八进制字面量、迭代器 和 for..of 循环和箭头函数等。Nashorn 还提供了 API 把 ECMAScript 源代码解析成抽象语法树（ Abstract Syntax Tree，AST ） ，可以用来对 ECMAScript 源代码进行分析。</p><h1 id="I-O-流新特性"><a href="#I-O-流新特性" class="headerlink" title="I/O 流新特性"></a>I/O 流新特性</h1><p>类 java.io.InputStream 中增加了新的方法来读取和复制 InputStream 中包含的数据。</p><ul><li>readAllBytes：读取 InputStream 中的所有剩余字节。</li><li>readNBytes： 从 InputStream 中读取指定数量的字节到数组中。</li><li>transferTo：读取 InputStream 中的全部字节并写入到指定的 OutputStream 中 。<br>代码清单 12 中给出了这些新方法的使用示例。</li></ul><p>清单 12. InputStream 中的新方法使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream inputStream; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT = <span class="string">"Hello World"</span>; </span><br><span class="line">    <span class="meta">@Before</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.inputStream = </span><br><span class="line">            TestInputStream.class.getResourceAsStream(<span class="string">"/input.txt"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadAllBytes</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        <span class="keyword">final</span> String content = <span class="keyword">new</span> String(<span class="keyword">this</span>.inputStream.readAllBytes()); </span><br><span class="line">        assertEquals(CONTENT, content); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadNBytes</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>]; </span><br><span class="line">        <span class="keyword">this</span>.inputStream.readNBytes(data, <span class="number">0</span>, <span class="number">5</span>); </span><br><span class="line">        assertEquals(<span class="string">"Hello"</span>, <span class="keyword">new</span> String(data)); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransferTo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        <span class="keyword">final</span> ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream(); </span><br><span class="line">        <span class="keyword">this</span>.inputStream.transferTo(outputStream); </span><br><span class="line">        assertEquals(CONTENT, outputStream.toString()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ObjectInputFilter 可以对 ObjectInputStream 中 包含的内容进行检查，来确保其中包含的数据是合法的。可以使用 ObjectInputStream 的方法 setObjectInputFilter 来设置。ObjectInputFilter 在 进行检查时，可以检查如对象图的最大深度、对象引用的最大数量、输入流中的最大字节数和数组的最大长度等限制，也可以对包含的类的名称进行限制。</p><h1 id="改进应用安全性能"><a href="#改进应用安全性能" class="headerlink" title="改进应用安全性能"></a>改进应用安全性能</h1><p>Java 9 新增了 4 个 SHA- 3 哈希算法，SHA3-224、SHA3-256、SHA3-384 和 S HA3-512。另外也增加了通过 java.security.SecureRandom 生成使用 DRBG 算法的强随机数。 代码清单 13 中给出了 SHA-3 哈希算法的使用示例。</p><p>清单 13. SHA-3 哈希算法使用示例<br>清单 13. SHA-3 哈希算法使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Hex; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SHA3</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123; </span><br><span class="line">        <span class="keyword">final</span> MessageDigest instance = MessageDigest.getInstance(<span class="string">"SHA3-224"</span>); </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] digest = instance.digest(<span class="string">""</span>.getBytes()); </span><br><span class="line">        System.out.println(Hex.encodeHexString(digest)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h1><p>类 java.awt.Desktop 增加了新的与桌面进行互动的能力。可以使用 addAppEventListener 方法来添加不同应用事件的监听器，包括应用变为前台应用、应用隐藏或显示、屏幕和系统进入休眠与唤醒、以及 用户会话的开始和终止等。还可以在显示关于窗口和配置窗口时，添加自定义的逻辑。在用户要求退出应用时，可以通过自定义处理器来接受或拒绝退出请求。在 A WT 图像支持方面，可以在应用中使用多分辨率图像。</p><h1 id="统一-JVM-日志"><a href="#统一-JVM-日志" class="headerlink" title="统一 JVM 日志"></a>统一 JVM 日志</h1><p>Java 9 中 ，JVM 有了统一的日志记录系统，可以使用新的命令行选项-Xlog 来控制 JVM 上 所有组件的日志记录。该日志记录系统可以设置输出的日志消息的标签、级别、修饰符和输出目标等。Java 9 移除了在 Java 8 中 被废弃的垃圾回收器配置组合，同时 把 G1 设为默认的垃圾回收器实现。另外，CMS 垃圾回收器已经被声明为废弃。Java 9 也增加了很多可以通过 jcmd 调用的诊断命令。</p><h1 id="其他改动方面"><a href="#其他改动方面" class="headerlink" title="其他改动方面"></a>其他改动方面</h1><p>在 Java 语言本身，Java 9 允许在接口中使用私有方法。 在 try-with-resources 语句中可以使用 e ffectively-final 变量。 类 java.lang.StackWalker 可 以对线程的堆栈进行遍历，并且支持过滤和延迟访问。Java 9 把对 Unicode 的支持升级到了 8.0。ResourceBundle 加载属性文件的默认编码从 ISO-8859-1 改成了 UTF-8，不再需要使用 native2ascii 命 令来对属性文件进行额外处理。注解@Deprecated 也得到了增强，增加了 since 和 forRemoval 两 个属性，可以分别指定一个程序元素被废弃的版本，以及是否会在今后的版本中被删除。</p><p>在 代码清单 14 中，buildMessage 是接口 SayHi 中的私有方法，在默认方法 sayHi 中被使用。</p><p>清单 14. 接口中私有方法的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SayHi</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildMessage</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">(<span class="keyword">final</span> String message)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        sayHi(buildMessage()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>作为 Java 平台最新的一个重大更新，Java 9 中的很多新特性，尤其模块系统，对于 Java 应用的开发会产生深远的影响。本文对 Java 9 中的新特性做了概括的介绍，可以作为了解 Java 9 的基础。这些新特性的相信内容，可以通过官方文档来进一步的了解。</p><h1 id="参考资源-resources"><a href="#参考资源-resources" class="headerlink" title="参考资源 (resources )"></a>参考资源 (resources )</h1><p>参考 <a href="https://docs.oracle.com/javase/9/" target="_blank" rel="noopener">Java 9 官方文档</a> ，了解 Java 9 的更多内容 。<br>参考 <a href="https://docs.oracle.com/javase/9/docs/api/overview-summary.html" target="_blank" rel="noopener">Java 9 官方 Java 文档</a> ，了解 Java API 的细节。<br>了解 <a href="http://www.reactive-streams.org/" target="_blank" rel="noopener">反应式流规范</a> 的更多内容 。</p>]]></content>
    
    <summary type="html">
    
      Java 9 正式发布于 2017 年 9 月 21 日 。作为 Java8 之后 3 年半才发布的新版本，Java 9 带 来了很多重大的变化。其中最重要的改动是 Java 平台模块系统的引入。除此之外，还有一些新的特性。 本文对 Java9 中包含的新特性做了概括性的介绍，可以帮助你快速了解 Java 9。
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
      <category term="JDK9" scheme="http://localhost/categories/Java/JDK9/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
      <category term="JDK9" scheme="http://localhost/tags/JDK9/"/>
    
  </entry>
  
  <entry>
    <title>Spring Framework 5 中的新特性</title>
    <link href="http://localhost/2018/03/31/Java/spring/Spring%20Framework%205%20%E4%B8%AD%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://localhost/2018/03/31/Java/spring/Spring Framework 5 中的新特性/</id>
    <published>2018-03-31T06:55:48.316Z</published>
    <updated>2018-03-31T07:02:31.216Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 5 于 2017 年 9 月发布了通用版本 (GA)，它标志着自 2013 年 12 月以来第一个主要 Spring Framework 版本。它提供了一些人们期待已久的改进，还采用了一种全新的编程范例，以反应式宣言中陈述的反应式原则为基础。</p><p>这个版本是很长时间以来最令人兴奋的 Spring Framework 版本。Spring 5 兼容 Java™8 和 JDK 9，它集成了反应式流，以便提供一种颠覆性方法来实现端点和 Web 应用程序开发。</p><p>诚然，反应式编程不仅是此版本的主题，还是令许多开发人员激动不已的重大特性。人们对能够针对负载波动进行无缝扩展的灾备和响应式服务的需求在不断增加，Spring 5 很好地满足了这一需求。</p><p>本文将全面介绍 Spring 5。我将介绍 Java SE 8 和 Java EE 7 API 的基准升级、Spring 5 的新反应式编程模型、HTTP/2 支持，以及 Spring 通过 Kotlin 对函数式编程的全面支持。我还会简要介绍测试和性能增强，最后介绍对 Spring 核心和容器的一般性修订。</p><h1 id="升级到-Java-SE-8-和-Java-EE-7"><a href="#升级到-Java-SE-8-和-Java-EE-7" class="headerlink" title="升级到 Java SE 8 和 Java EE 7"></a>升级到 Java SE 8 和 Java EE 7</h1><p>直到现在，Spring Framework 仍支持一些弃用的 Java 版本，但 Spring 5 已从旧包袱中解放出来。为了充分利用 Java 8 特性，它的代码库已进行了改进，而且该框架要求将 Java 8 作为最低的 JDK 版本。</p><p>Spring 5 在类路径（和模块路径）上完全兼容 Java 9，而且它通过了 JDK 9 测试套件的测试。对 Java 9 爱好者而言，这是一条好消息，因为在 Java 9 发布后，Spring 能立即使用它。</p><p>在 API 级别上，Spring 5 兼容 Java EE 8 技术，满足对 Servlet 4.0、Bean Validation 2.0 和全新的 JSON Binding API 的需求。对 Java EE API 的最低要求为 V7，该版本引入了针对 Servlet、JPA 和 Bean Validation API 的次要版本。</p><h1 id="反应式编程模型"><a href="#反应式编程模型" class="headerlink" title="反应式编程模型"></a>反应式编程模型</h1><p>Spring 5 最令人兴奋的新特性是它的反应式编程模型。Spring 5 Framework 基于一种反应式基础而构建，而且是完全异步和非阻塞的。只需少量的线程，新的事件循环执行模型就可以垂直扩展。</p><p>该框架采用反应式流来提供在反应式组件中传播负压的机制。负压是一个确保来自多个生产者的数据不会让使用者不堪重负的概念。</p><p>Spring WebFlux 是 Spring 5 的反应式核心，它为开发人员提供了两种为 Spring Web 编程而设计的编程模型：一种基于注解的模型和 Functional Web Framework (WebFlux.fn)。</p><p>基于注解的模型是 Spring WebMVC 的现代替代方案，该模型基于反应式基础而构建，而 Functional Web Framework 是基于 @Controller 注解的编程模型的替代方案。这些模型都通过同一种反应式基础来运行，后者调整非阻塞 HTTP 来适应反应式流 API。</p><h1 id="使用注解进行编程"><a href="#使用注解进行编程" class="headerlink" title="使用注解进行编程"></a>使用注解进行编程</h1><p>WebMVC 程序员应该对 Spring 5 的基于注解的编程模型非常熟悉。Spring 5 调整了 WebMVC 的 @Controller 编程模型，采用了相同的注解。</p><p>在清单 1 中，BookController 类提供了两个方法，分别响应针对某个图书列表的 HTTP 请求，以及针对具有给定 id 的图书的 HTTP 请求。请注意 resource 方法返回的对象（Mono 和 Flux）。这些对象是实现反应式流规范中的 Publisher 接口的反应式类型。它们的职责是处理数据流。Mono 对象处理一个仅含 1 个元素的流，而 Flux 表示一个包含 N 个元素的流。</p><p>清单 1. 反应式控制器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/book"</span>)</span><br><span class="line">    <span class="function">Flux&lt;Book&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.repository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/book/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">Mono&lt;Book&gt; <span class="title">findById</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.repository.findOne(id);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Plumbing code omitted for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是针对 Spring Web 编程的注解。现在我们使用函数式 Web 框架来解决同一个问题。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>Spring 5 的新函数式方法将请求委托给处理函数，这些函数接受一个服务器请求实例并返回一种反应式类型。清单 2 演示了这一过程，其中 listBook 和 getBook 方法类似于清单 1 中的功能。</p><p>清单 2. 清单 2.BookHandler 函数类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookHandler</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">listBooks</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.ok()</span><br><span class="line">            .contentType(APPLICATION_JSON)</span><br><span class="line">            .body(repository.allPeople(), Book.class);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getBook</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.getBook(request.pathVariable(<span class="string">"id"</span>))</span><br><span class="line">            .then(book -&gt; ServerResponse.ok()</span><br><span class="line">            .contentType(APPLICATION_JSON)</span><br><span class="line">            .body(fromObject(book)))</span><br><span class="line">            .otherwiseIfEmpty(ServerResponse.notFound().build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Plumbing code omitted for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过路由函数来匹配 HTTP 请求谓词与媒体类型，将客户端请求路由到处理函数。清单 3 展示了图书资源端点 URI 将调用委托给合适的处理函数：</p><p>清单 3. Router 函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BookHandler handler = <span class="keyword">new</span> BookHandler();</span><br><span class="line"> </span><br><span class="line">RouterFunction&lt;ServerResponse&gt; personRoute =</span><br><span class="line">    route(</span><br><span class="line">        GET(<span class="string">"/books/&#123;id&#125;"</span>)</span><br><span class="line">        .and(accept(APPLICATION_JSON)), handler::getBook)</span><br><span class="line">        .andRoute(</span><br><span class="line">    GET(<span class="string">"/books"</span>)</span><br><span class="line">        .and(accept(APPLICATION_JSON)), handler::listBooks);</span><br></pre></td></tr></table></figure></p><p>这些示例背后的数据存储库也支持完整的反应式体验，该体验是通过 Spring Data 对反应式 Couchbase、Reactive MongoDB 和 Cassandra 的支持来实现的。</p><h1 id="使用-REST-端点执行反应式编程"><a href="#使用-REST-端点执行反应式编程" class="headerlink" title="使用 REST 端点执行反应式编程"></a>使用 REST 端点执行反应式编程</h1><p>新的编程模型脱离了传统的 Spring WebMVC 模型，引入了一些很不错的新特性。</p><p>举例来说，WebFlux 模块为 RestTemplate 提供了一种完全非阻塞、反应式的替代方案，名为 WebClient。清单 4 创建了一个 WebClient，并调用 books 端点来请求一本给定 id 为 1234 的图书。</p><p>清单 4. 通过 WebClient 调用 REST 端点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;Book&gt; book = WebClient.create(<span class="string">"http://localhost:8080"</span>)</span><br><span class="line">      .get()</span><br><span class="line">      .url(<span class="string">"/books/&#123;id&#125;"</span>, <span class="number">1234</span>)</span><br><span class="line">      .accept(APPLICATION_JSON)</span><br><span class="line">      .exchange(request)</span><br><span class="line">      .then(response -&gt; response.bodyToMono(Book.class));</span><br></pre></td></tr></table></figure></p><h1 id="HTTP-2-支持"><a href="#HTTP-2-支持" class="headerlink" title="HTTP/2 支持"></a>HTTP/2 支持</h1><blockquote><p><strong>HTTP/2 幕后原理</strong>：要了解 HTTP/2 如何提高传输性能，减少延迟，并帮助提高应用程序吞吐量，从而提供经过改进的丰富 Web 体验。</p></blockquote><p>Spring Framework 5.0 将提供专门的 HTTP/2 特性支持，还支持人们期望出现在 JDK 9 中的新 HTTP 客户端。尽管 HTTP/2 的服务器推送功能已通过 Jetty servlet 引擎的 ServerPushFilter 类向 Spring 开发人员公开了很长一段时间，但如果发现 Spring 5 中开箱即用地提供了 HTTP/2 性能增强，Web 优化者们一定会为此欢呼雀跃。</p><p>Java EE Servlet 规范预计将于 2017 年第 4 季度发布，Servlet 4.0 支持将在 Spring 5.1 中提供。到那时，HTTP/2 特性将由 Tomcat 9.0、Jetty 9.3 和 Undertow 1.4 原生提供。</p><h1 id="Kotlin-和-Spring-WebFlux"><a href="#Kotlin-和-Spring-WebFlux" class="headerlink" title="Kotlin 和 Spring WebFlux"></a>Kotlin 和 Spring WebFlux</h1><p>Kotlin 是一种来自 JetBrains 的面向对象的语言，它支持函数式编程。它的主要优势之一是与 Java 有非常高的互操作性。通过引入对 Kotlin 的专门支持，Spring 在 V5 中全面吸纳了这一优势。它的函数式编程风格与 Spring WebFlux 模块完美匹配，它的新路由 DSL 利用了函数式 Web 框架以及干净且符合语言习惯的代码。可以像清单 5 中这样简单地表达端点路由：</p><p>清单 5. Kotlin 的用于定义端点的路由 DSL<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">fun <span class="title">apiRouter</span><span class="params">()</span> </span>= router &#123;</span><br><span class="line">    (accept(APPLICATION_JSON) and <span class="string">"/api"</span>).nest &#123;</span><br><span class="line">        <span class="string">"/book"</span>.nest &#123;</span><br><span class="line">            GET(<span class="string">"/"</span>, bookHandler::findAll)</span><br><span class="line">            GET(<span class="string">"/&#123;id&#125;"</span>, bookHandler::findOne)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">"/video"</span>.nest &#123;</span><br><span class="line">            GET(<span class="string">"/"</span>, videoHandler::findAll)</span><br><span class="line">            GET(<span class="string">"/&#123;genre&#125;"</span>, videoHandler::findByGenre)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 Kotlin 1.1.4+ 时，还添加了对 Kotlin 的不可变类的支持（通过带默认值的可选参数），以及对完全支持 null 的 API 的支持。</p><h1 id="使用-Lambda-表达式注册-bean"><a href="#使用-Lambda-表达式注册-bean" class="headerlink" title="使用 Lambda 表达式注册 bean"></a>使用 Lambda 表达式注册 bean</h1><p>作为传统 XML 和 JavaConfig 的替代方案，现在可以使用 lambda 表达式注册 Spring bean，使 bean 可以实际注册为提供者。清单 6 使用 lambda 表达式注册了一个 Book bean。</p><p>清单 6. 将 Bean 注册为提供者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line">context.registerBean(Book.class, () -&gt; <span class="keyword">new</span> </span><br><span class="line">              Book(context.getBean(Author.class))</span><br><span class="line">        );</span><br></pre></td></tr></table></figure></p><h1 id="Spring-WebMVC-支持最新的-API"><a href="#Spring-WebMVC-支持最新的-API" class="headerlink" title="Spring WebMVC 支持最新的 API"></a>Spring WebMVC 支持最新的 API</h1><p>全新的 WebFlux 模块提供了许多新的、令人兴奋的功能，但 Spring 5 也迎合了愿意继续使用 Spring MVC 的开发人员的需求。Spring 5 中更新了模型-视图-控制器框架，以兼容 WebFlux 和最新版的 Jackson 2.9 和 Protobuf 3.0，甚至包括对新的 Java EE 8 JSON-Binding API 的支持。</p><p>除了 HTTP/2 特性的基础服务器实现之外，Spring WebMVC 还通过 MVC 控制器方法的一个参数来支持 Servlet 4.0 的 PushBuilder。最后，WebMVC 全面支持 Reactor 3.1 的 Flux 和 Mono 对象，以及 RxJava 1.3 和 2.1，它们被视为来自 MVC 控制器方法的返回值。这项支持的最终目的是支持 Spring Data 中的新的反应式 WebClient 和反应式存储库。</p><h1 id="使用-JUnit-5-执行条件和并发测试"><a href="#使用-JUnit-5-执行条件和并发测试" class="headerlink" title="使用 JUnit 5 执行条件和并发测试"></a>使用 JUnit 5 执行条件和并发测试</h1><blockquote><p><strong>JUnit 和 Spring 5</strong>：Spring 5 全面接纳了函数式范例，并支持 JUnit 5 及其新的函数式测试风格。还提供了对 JUnit 4 的向后兼容性，以确保不会破坏旧代码。</p></blockquote><p>Spring 5 的测试套件通过多种方式得到了增强，但最明显的是它对 JUnit 5 的支持。现在可以在您的单元测试中利用 Java 8 中提供的函数式编程特性。清单 7 演示了这一支持：</p><p>清单 7. 清单 7.JUnit 5 全面接纳了 Java 8 流和 lambda 表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">givenStreamOfInts_SumShouldBeMoreThanFive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertTrue(Stream.of(<span class="number">20</span>, <span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line">      .stream()</span><br><span class="line">      .mapToInt(i -&gt; i)</span><br><span class="line">      .sum() &gt; <span class="number">110</span>, () -&gt; <span class="string">"Total should be more than 100"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>迁移到 JUnit 5</strong>：如果您对升级到 JUnit 5 持观望态度，Steve Perry 的分两部分的深入剖析教程将说服您冒险尝试。</p></blockquote><p>Spring 5 继承了 JUnit 5 在 Spring TestContext Framework 内实现多个扩展 API 的灵活性。举例而言，开发人员可以使用 JUnit 5 的条件测试执行注解 @EnabledIf 和 @DisabledIf 来自动计算一个 SpEL (Spring Expression Language) 表达式，并适当地启用或禁用测试。借助这些注解，Spring 5 支持以前很难实现的复杂的条件测试方案。Spring TextContext Framework 现在能够并发执行测试。</p><h1 id="使用-Spring-WebFlux-执行集成测试"><a href="#使用-Spring-WebFlux-执行集成测试" class="headerlink" title="使用 Spring WebFlux 执行集成测试"></a>使用 Spring WebFlux 执行集成测试</h1><p>Spring Test 现在包含一个 WebTestClient，后者支持对 Spring WebFlux 服务器端点执行集成测试。WebTestClient 使用模拟请求和响应来避免耗尽服务器资源，并能直接绑定到 WebFlux 服务器基础架构。</p><p>WebTestClient 可绑定到真实的服务器，或者使用控制器或函数。在清单 8 中，WebTestClient 被绑定到 localhost：</p><p>清单 8. 绑定到 localhost 的 WebTestClient<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WebTestClient testClient = WebTestClient</span><br><span class="line">  .bindToServer()</span><br><span class="line">  .baseUrl(<span class="string">"http://localhost:8080"</span>)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure></p><p>在清单 9 中，测试了 RouterFunction：</p><p>清单 9. 将 WebTestClient 绑定到 RouterFunction<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RouterFunction bookRouter = RouterFunctions.route(</span><br><span class="line">  RequestPredicates.GET(<span class="string">"/books"</span>),</span><br><span class="line">  request -&gt; ServerResponse.ok().build()</span><br><span class="line">);</span><br><span class="line">  </span><br><span class="line">WebTestClient</span><br><span class="line">  .bindToRouterFunction(bookRouter)</span><br><span class="line">  .build().get().uri(<span class="string">"/books"</span>)</span><br><span class="line">  .exchange()</span><br><span class="line">  .expectStatus().isOk()</span><br><span class="line">  .expectBody().isEmpty();</span><br></pre></td></tr></table></figure></p><h1 id="包清理和弃用"><a href="#包清理和弃用" class="headerlink" title="包清理和弃用"></a>包清理和弃用</h1><p>Spring 5 中止了对一些过时 API 的支持。遭此厄运的还有 Hibernate 3 和 4，为了支持 Hibernate 5，它们遭到了弃用。另外，对 Portlet、Velocity、JasperReports、XMLBeans、JDO 和 Guava 的支持也已中止。</p><p>包级别上的清理工作仍在继续：Spring 5 不再支持 beans.factory.access、jdbc.support.nativejdbc、mock.staticmock（来自 spring-aspects 模块）或 web.view.tiles2M。Tiles 3 现在是 Spring 的最低要求。</p><h1 id="对-Spring-核心和容器的一般更新"><a href="#对-Spring-核心和容器的一般更新" class="headerlink" title="对 Spring 核心和容器的一般更新"></a>对 Spring 核心和容器的一般更新</h1><p>Spring Framework 5 改进了扫描和识别组件的方法，使大型项目的性能得到提升。目前，扫描是在编译时执行的，而且向 META-INF/spring.components 文件中的索引文件添加了组件坐标。该索引是通过一个为项目定义的特定于平台的应用程序构建任务来生成的。</p><p>标有来自 javax 包的注解的组件会添加到索引中，任何带 @Index 注解的类或接口都会添加到索引中。Spring 的传统类路径扫描方式没有删除，而是保留为一种后备选择。有许多针对大型代码库的明显性能优势，而托管许多 Spring 项目的服务器也会缩短启动时间。</p><p>Spring 5 还添加了对 @Nullable 的支持，后者可用于指示可选的注入点。使用者现在必须准备接受 null 值。此外，还可以使用此注解来标记可以为 null 的参数、字段和返回值。@Nullable 主要用于 IntelliJ IDEA 等 IDE，但也可用于 Eclipse 和 FindBugs，它使得在编译时处理 null 值变得更方便，而无需在运行时发送 NullPointerExceptions。</p><p>Spring Logging 还提升了性能，自带开箱即用的 Commons Logging 桥接器。现在已通过资源抽象支持防御性编程，为 getFile 访问提供了 isFile 指示器。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>Spring 5 的首要特性是新的反应式编程模型，这代表着对提供可无缝扩展、基于 Spring 的响应式服务的重大保障。随着人们对 Spring 5 的采用，开发人员有望看到反应式编程将会成为使用 Java 语言的 Web 和企业应用程序开发的未来发展道路。</p><p>未来的 Spring Framework 版本将继续反映这一承诺，因为 Spring Security、Spring Data 和 Spring Integration 有望采用反应式编程的特征和优势。</p><p>总之，Spring 5 代表着一次大受 Spring 开发人员欢迎的范例转变，同时也为其他框架指出了一条发展之路。</p>]]></content>
    
    <summary type="html">
    
      Spring 5 如何利用 Java 8 的函数式语法和一种新的反应式编程模型
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
      <category term="Spring" scheme="http://localhost/categories/Java/Spring/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
      <category term="Spring" scheme="http://localhost/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>通过实例理解 JDK8 的 CompletableFuture</title>
    <link href="http://localhost/2018/03/31/Java/jdk8/%E9%80%9A%E8%BF%87%E5%AE%9E%E4%BE%8B%E7%90%86%E8%A7%A3%20JDK8%20%E7%9A%84%20CompletableFuture/"/>
    <id>http://localhost/2018/03/31/Java/jdk8/通过实例理解 JDK8 的 CompletableFuture/</id>
    <published>2018-03-31T06:26:50.225Z</published>
    <updated>2018-03-31T06:55:28.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 5 并发库主要关注于异步任务的处理，它采用了这样一种模式，producer 线程创建任务并且利用阻塞队列将其传递给任务的 consumer。这种模型在 Java 7 和 8 中进一步发展，并且开始支持另外一种风格的任务执行，那就是将任务的数据集分解为子集，每个子集都可以由独立且同质的子任务来负责处理。</p><p>这种风格的基础库也就是 fork/join 框架，它允许程序员规定数据集该如何进行分割，并且支持将子任务提交到默认的标准线程池中，也就是 “通用的”ForkJoinPool。Java 8 中，fork/join 并行功能借助并行流的机制变得更加具有可用性。但是，不是所有的问题都适合这种风格的并行处理：所处理的元素必须是独立的，数据集要足够大，并且在并行加速方面，每个元素的处理成本要足够高，这样才能补偿建立 fork/join 框架所消耗的成本。CompletableFuture 类则是 Java 8 在并行流方面的创新。</p><h1 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h1><h2 id="异步计算"><a href="#异步计算" class="headerlink" title="异步计算"></a>异步计算</h2><p>所谓异步调用其实就是实现一个可无需等待被调用函数的返回值而让操作继续运行的方法。在 Java 语言中，简单的讲就是另启一个线程来完成调用中的部分计算，使调用继续运行或返回，而不需要等待计算结果。但调用者仍需要取线程的计算结果。</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数比较通用的解释是，它是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外一方调用的，用于对该事件或条件进行响应。</p><p>回调函数的机制：</p><ol><li><p>定义一个回调函数；</p></li><li><p>提供函数实现的一方在初始化时候，将回调函数的函数指针注册给调用者；</p></li><li><p>当特定的事件或条件发生的时候，调用者使用函数指针调用回调函数对事件进行处理。</p></li></ol><p>回调函数通常与原始调用者处于同一层次，如图 1 所示：</p><p>图 1 回调函数示例图<br><img src="https://www.ibm.com/developerworks/cn/java/j-cf-of-jdk8/image001.png" alt=""></p><h2 id="Future-接口介绍"><a href="#Future-接口介绍" class="headerlink" title="Future 接口介绍"></a>Future 接口介绍</h2><p>JDK5 新增了 Future 接口，用于描述一个异步计算的结果。虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式呢？即当计算结果完成及时通知监听者。</p><p>有一些开源框架实现了我们的设想，例如 Netty 的 ChannelFuture 类扩展了 Future 接口，通过提供 addListener 方法实现支持回调方式的异步编程。Netty 中所有的 I/O 操作都是异步的, 这意味着任何的 I/O 调用都将立即返回，而不保证这些被请求的 I/O 操作在调用结束的时候已经完成。取而代之地，你会得到一个返回的 ChannelFuture 实例，这个实例将给你一些关于 I/O 操作结果或者状态的信息。当一个 I/O 操作开始的时候，一个新的 Future 对象就会被创建。在开始的时候，新的 Future 是未完成的状态－－它既非成功、失败，也非被取消，因为 I/O 操作还没有结束。如果 I/O 操作以成功、失败或者被取消中的任何一种状态结束了，那么这个 Future 将会被标记为已完成，并包含更多详细的信息（例如：失败的原因）。请注意，即使是失败和被取消的状态，也是属于已完成的状态。阻塞方式的示例代码如代码 1 所示。</p><p>代码 1 阻塞方式示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the connection attempt.</span></span><br><span class="line">ChannelFuture Future = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line"><span class="comment">// Wait until the connection is closed or the connection attempt fails.</span></span><br><span class="line">Future.getChannel().getCloseFuture().awaitUninterruptibly();</span><br><span class="line"><span class="comment">// Shut down thread pools to exit.</span></span><br><span class="line">bootstrap.releaseExternalResources();</span><br></pre></td></tr></table></figure></p><p>上面代码使用的是 awaitUninterruptibly 方法，源代码如代码 2 所示。</p><p>代码 2 awaitUninterruptibly 源代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">publicChannelFutureawaitUninterruptibly() &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 循环等待到完成</span></span><br><span class="line">        <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">            checkDeadLock();</span><br><span class="line">            waiters++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 不允许中断</span></span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            waiters--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码 3 异步非阻塞方式示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the connection attempt.</span></span><br><span class="line">ChannelFuture Future = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">Future.addListener(<span class="keyword">new</span> ChannelFutureListener()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(<span class="keyword">final</span> ChannelFuture Future)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">        </span>&#123;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Shut down thread pools to exit. </span></span><br><span class="line">bootstrap.releaseExternalResources();</span><br></pre></td></tr></table></figure></p><p>可以明显的看出，在异步模式下，上面这段代码没有阻塞，在执行 connect 操作后直接执行到 printTime(“异步时间：”)，随后 connect 完成，Future 的监听函数输出 connect 操作完成。</p><p>非阻塞则是添加监听类 ChannelFutureListener，通过覆盖 ChannelFutureListener 的 operationComplete 执行业务逻辑。</p><p>代码 4 异步非阻塞方式示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(<span class="keyword">final</span> ChannelFutureListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"listener"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    booleannotifyNow = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        notifyNow = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//listener 链表头</span></span><br><span class="line">        firstListener = listener;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (otherListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">        otherListeners = <span class="keyword">new</span> ArrayList&lt;ChannelFutureListener&gt;(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加到 listener 链表中，以便操作完成后遍历操作</span></span><br><span class="line">        otherListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (notifyNow) &#123;</span><br><span class="line">        <span class="comment">// 通知 listener 进行处理</span></span><br><span class="line">        notifyListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这部分代码的逻辑很简单，就是注册回调函数，当操作完成后自动调用回调函数，就达到了异步的效果。</p><h2 id="CompletableFuture-类介绍"><a href="#CompletableFuture-类介绍" class="headerlink" title="CompletableFuture 类介绍"></a>CompletableFuture 类介绍</h2><p>Java 8 中, 新增加了一个包含 50 个方法左右的类 –CompletableFuture，它提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合 CompletableFuture 的方法。</p><p>对于阻塞或者轮询方式，依然可以通过 CompletableFuture 类的 CompletionStage 和 Future 接口方式支持。</p><p>CompletableFuture 类声明了 CompletionStage 接口，CompletionStage 接口实际上提供了同步或异步运行计算的舞台，所以我们可以通过实现多个 CompletionStage 命令，并且将这些命令串联在一起的方式实现多个命令之间的触发。</p><p>我们可以通过 CompletableFuture.supplyAsync(this::sendMsg); 这么一行代码创建一个简单的异步计算。在这行代码中，supplyAsync 支持异步地执行我们指定的方法，这个例子中的异步执行方法是 sendMsg。当然，我们也可以使用 Executor 执行异步程序，默认是 ForkJoinPool.commonPool()。</p><p>我们也可以在异步计算结束之后指定回调函数，例如 CompletableFuture.supplyAsync(this::sendMsg) .thenAccept(this::notify); 这行代码中的 thenAccept 被用于增加回调函数，在我们的示例中 notify 就成了异步计算的消费者，它会处理计算结果。</p><h1 id="CompletableFuture-类使用示例"><a href="#CompletableFuture-类使用示例" class="headerlink" title="CompletableFuture 类使用示例"></a>CompletableFuture 类使用示例</h1><p>接下来我们通过 20 个示例看看 CompletableFuture 类具体怎么用。</p><h2 id="创建完整的-CompletableFuture"><a href="#创建完整的-CompletableFuture" class="headerlink" title="创建完整的 CompletableFuture"></a>创建完整的 CompletableFuture</h2><p>代码 5 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completedFutureExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt;cf = CompletableFuture.completedFuture(<span class="string">"message"</span>);</span><br><span class="line">    assertTrue(cf.isDone());</span><br><span class="line">    assertEquals(<span class="string">"message"</span>, cf.getNow(<span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码一般来说被用于启动异步计算，getNow(null) 返回计算结果或者 null。</p><h2 id="运行简单的异步场景"><a href="#运行简单的异步场景" class="headerlink" title="运行简单的异步场景"></a>运行简单的异步场景</h2><p>代码 6 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAsyncExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt;cf = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        assertTrue(Thread.currentThread().isDaemon());</span><br><span class="line">        randomSleep();</span><br><span class="line">    &#125;);</span><br><span class="line">    assertFalse(cf.isDone());</span><br><span class="line">    sleepEnough();</span><br><span class="line">    assertTrue(cf.isDone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码的关键点有两点：</p><ol><li>CompletableFuture 是异步执行方式；</li><li>使用 ForkJoinPool 实现异步执行，这种方式使用了 daemon 线程执行 Runnable 任务。</li></ol><h2 id="同步执行动作示例"><a href="#同步执行动作示例" class="headerlink" title="同步执行动作示例"></a>同步执行动作示例</h2><p>代码 7 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenApplyExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt;cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApply(s -&gt; &#123;</span><br><span class="line">    assertFalse(Thread.currentThread().isDaemon());</span><br><span class="line">    returns.toUpperCase();</span><br><span class="line">    &#125;);</span><br><span class="line">    assertEquals(<span class="string">"MESSAGE"</span>, cf.getNow(<span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码在异步计算正常完成的前提下将执行动作（此处为转换成大写字母）。</p><h2 id="异步执行动作示例"><a href="#异步执行动作示例" class="headerlink" title="异步执行动作示例"></a>异步执行动作示例</h2><p>相较前一个示例的同步方式，以下代码实现了异步方式，仅仅是在上面的代码里的多个方法增加 “Async” 这样的关键字。</p><p>代码 8 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenApplyAsyncExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt;cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApplyAsync(s -&gt; &#123;</span><br><span class="line">    assertTrue(Thread.currentThread().isDaemon());</span><br><span class="line">    randomSleep();</span><br><span class="line">    returns.toUpperCase();</span><br><span class="line">    &#125;);</span><br><span class="line">    assertNull(cf.getNow(<span class="keyword">null</span>));</span><br><span class="line">    assertEquals(<span class="string">"MESSAGE"</span>, cf.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用固定的线程池完成异步执行动作示例"><a href="#使用固定的线程池完成异步执行动作示例" class="headerlink" title="使用固定的线程池完成异步执行动作示例"></a>使用固定的线程池完成异步执行动作示例</h2><p>我们可以通过使用线程池方式来管理异步动作申请，以下代码基于固定的线程池，也是做一个大写字母转换动作，代码如代码 9 所示。</p><p>代码 9 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">staticExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>, <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(runnable, <span class="string">"custom-executor-"</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenApplyAsyncWithExecutorExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            CompletableFuture&lt;String&gt;cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApplyAsync(s -&gt; &#123;</span><br><span class="line">            assertTrue(Thread.currentThread().getName().startsWith(<span class="string">"custom-executor-"</span>));</span><br><span class="line">            assertFalse(Thread.currentThread().isDaemon());</span><br><span class="line">            randomSleep();</span><br><span class="line">            returns.toUpperCase();</span><br><span class="line">        &#125;, executor);</span><br><span class="line">        assertNull(cf.getNow(<span class="keyword">null</span>));</span><br><span class="line">        assertEquals(<span class="string">"MESSAGE"</span>, cf.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="作为消费者消费计算结果示例"><a href="#作为消费者消费计算结果示例" class="headerlink" title="作为消费者消费计算结果示例"></a>作为消费者消费计算结果示例</h2><p>假设我们本次计算只需要前一次的计算结果，而不需要返回本次计算结果，那就有点类似于生产者（前一次计算）- 消费者（本次计算）模式了，示例代码如代码 10 所示。</p><p>代码 10 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenAcceptExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    CompletableFuture.completedFuture(<span class="string">"thenAccept message"</span>)</span><br><span class="line">    .thenAccept(s -&gt;result.append(s));</span><br><span class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消费者是同步执行的，所以不需要在 CompletableFuture 里对结果进行合并。</p><h2 id="异步消费示例"><a href="#异步消费示例" class="headerlink" title="异步消费示例"></a>异步消费示例</h2><p>相较于前一个示例的同步方式，我们也对应有异步方式，代码如代码 11 所示。</p><p>代码 11 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenAcceptAsyncExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    CompletableFuture&lt;Void&gt;cf = CompletableFuture.completedFuture(<span class="string">"thenAcceptAsync message"</span>)</span><br><span class="line">    .thenAcceptAsync(s -&gt;result.append(s));</span><br><span class="line">    cf.join();</span><br><span class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="计算过程中的异常示例"><a href="#计算过程中的异常示例" class="headerlink" title="计算过程中的异常示例"></a>计算过程中的异常示例</h2><p>接下来介绍异步操作过程中的异常情况处理。下面这个示例中我们会在字符转换异步请求中刻意延迟 1 秒钟，然后才会提交到 ForkJoinPool 里面去执行。</p><p>代码 12 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completeExceptionallyExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt;cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApplyAsync(String::toUpperCase,</span><br><span class="line">        CompletableFuture.delayedExecutor(<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">        CompletableFuture&lt;String&gt;exceptionHandler = cf.handle((s, th) -&gt; &#123; <span class="keyword">return</span> (th != <span class="keyword">null</span>) ? <span class="string">"message upon cancel"</span> : <span class="string">""</span>; &#125;);</span><br><span class="line">        cf.completeExceptionally(<span class="keyword">new</span> RuntimeException(<span class="string">"completed exceptionally"</span>));</span><br><span class="line">        assertTrue(<span class="string">"Was not completed exceptionally"</span>, cf.isCompletedExceptionally());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cf.join();</span><br><span class="line">        fail(<span class="string">"Should have thrown an exception"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(CompletionException ex) &#123; <span class="comment">// just for testing</span></span><br><span class="line">            assertEquals(<span class="string">"completed exceptionally"</span>, ex.getCause().getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">     assertEquals(<span class="string">"message upon cancel"</span>, exceptionHandler.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>示例代码中，首先我们创建一个 CompletableFuture（计算完毕），然后调用 thenApplyAsync 返回一个新的 CompletableFuture，接着通过使用 delayedExecutor(timeout, timeUnit) 方法延迟 1 秒钟执行。然后我们创建一个 handler（exceptionHandler），它会处理异常，返回另一个字符串 “message upon cancel”。接下来进入 join() 方法，执行大写转换操作，并且抛出 CompletionException 异常。</p><h2 id="取消计算任务"><a href="#取消计算任务" class="headerlink" title="取消计算任务"></a>取消计算任务</h2><p>与前面一个异常处理的示例类似，我们可以通过调用 cancel(boolean mayInterruptIfRunning) 方法取消计算任务。此外，cancel() 方法与 completeExceptionally(new CancellationException()) 等价。</p><p>代码 13 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cancelExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApplyAsync(String::toUpperCase,</span><br><span class="line">    CompletableFuture.delayedExecutor(<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">    CompletableFuture cf2 = cf.exceptionally(throwable -&gt; <span class="string">"canceled message"</span>);</span><br><span class="line">    assertTrue(<span class="string">"Was not canceled"</span>, cf.cancel(<span class="keyword">true</span>));</span><br><span class="line">    assertTrue(<span class="string">"Was not completed exceptionally"</span>, cf.isCompletedExceptionally());</span><br><span class="line">    assertEquals(<span class="string">"canceled message"</span>, cf2.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一个-CompletableFuture-VS-两个异步计算"><a href="#一个-CompletableFuture-VS-两个异步计算" class="headerlink" title="一个 CompletableFuture VS 两个异步计算"></a>一个 CompletableFuture VS 两个异步计算</h2><p>我们可以创建一个 CompletableFuture 接收两个异步计算的结果，下面代码首先创建了一个 String 对象，接下来分别创建了两个 CompletableFuture 对象 cf1 和 cf2，cf2 通过调用 applyToEither 方法实现我们的需求。</p><p>代码 14 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applyToEitherExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String original = <span class="string">"Message"</span>;</span><br><span class="line">    CompletableFuture cf1 = CompletableFuture.completedFuture(original)</span><br><span class="line">    .thenApplyAsync(s -&gt; delayedUpperCase(s));</span><br><span class="line">    CompletableFuture cf2 = cf1.applyToEither(</span><br><span class="line">    CompletableFuture.completedFuture(original).thenApplyAsync(s -&gt; delayedLowerCase(s)),</span><br><span class="line">    s -&gt; s + <span class="string">"from applyToEither"</span>);</span><br><span class="line">    assertTrue(cf2.join().endsWith(<span class="string">"from applyToEither"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们想要使用消费者替换代码 14 的方法方式用于处理异步计算结果，代码如代码 15 所示。</p><p>代码 15 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptEitherExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String original = <span class="string">"Message"</span>;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    CompletableFuture cf = CompletableFuture.completedFuture(original)</span><br><span class="line">    .thenApplyAsync(s -&gt; delayedUpperCase(s))</span><br><span class="line">    .acceptEither(CompletableFuture.completedFuture(original).thenApplyAsync(s -&gt; delayedLowerCase(s)),</span><br><span class="line">    s -&gt; result.append(s).append(<span class="string">"acceptEither"</span>));</span><br><span class="line">    cf.join();</span><br><span class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.toString().endsWith(<span class="string">"acceptEither"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="运行两个阶段后执行"><a href="#运行两个阶段后执行" class="headerlink" title="运行两个阶段后执行"></a>运行两个阶段后执行</h2><p>下面这个示例程序两个阶段执行完毕后返回结果，首先将字符转为大写，然后将字符转为小写，在两个计算阶段都结束之后触发 CompletableFuture。</p><p>代码 16 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAfterBothExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String original = <span class="string">"Message"</span>;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    CompletableFuture.completedFuture(original).thenApply(String::toUpperCase).runAfterBoth(</span><br><span class="line">    CompletableFuture.completedFuture(original).thenApply(String::toLowerCase),</span><br><span class="line">    () -&gt; result.append(<span class="string">"done"</span>));</span><br><span class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以通过以下方式处理异步计算结果，</p><p>代码 17 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenAcceptBothExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String original = <span class="string">"Message"</span>;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    CompletableFuture.completedFuture(original).thenApply(String::toUpperCase).thenAcceptBoth(</span><br><span class="line">    CompletableFuture.completedFuture(original).thenApply(String::toLowerCase),</span><br><span class="line">    (s1, s2) -&gt; result.append(s1 + s2));</span><br><span class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, result.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="整合两个计算结果"><a href="#整合两个计算结果" class="headerlink" title="整合两个计算结果"></a>整合两个计算结果</h2><p>我们可以通过 thenCombine() 方法整合两个异步计算的结果，注意，以下代码的整个程序过程是同步的，getNow() 方法最终会输出整合后的结果，也就是说大写字符和小写字符的串联值。</p><p>代码 18 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenCombineExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String original = <span class="string">"Message"</span>;</span><br><span class="line">    CompletableFuture cf = CompletableFuture.completedFuture(original).thenApply(s -&gt; delayedUpperCase(s))</span><br><span class="line">    .thenCombine(CompletableFuture.completedFuture(original).thenApply(s -&gt; delayedLowerCase(s)),</span><br><span class="line">    (s1, s2) -&gt; s1 + s2);</span><br><span class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, cf.getNow(<span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个示例是按照同步方式执行两个方法后再合成字符串，以下代码采用异步方式同步执行两个方法，由于异步方式情况下不能够确定哪一个方法最终执行完毕，所以我们需要调用 join() 方法等待后一个方法结束后再合成字符串，这一点和线程的 join() 方法是一致的，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到 join() 方法了，即 join() 的作用是：”等待该线程终止”。</p><p>代码 19 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenCombineAsyncExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String original = <span class="string">"Message"</span>;</span><br><span class="line">    CompletableFuture cf = CompletableFuture.completedFuture(original)</span><br><span class="line">    .thenApplyAsync(s -&gt; delayedUpperCase(s))</span><br><span class="line">    .thenCombine(CompletableFuture.completedFuture(original).thenApplyAsync(s -&gt; delayedLowerCase(s)),</span><br><span class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, cf.join());</span><br><span class="line">    (s1, s2) -&gt; s1 + s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了 thenCombine() 方法以外，还有另外一种方法 - thenCompose()，这个方法也会实现两个方法执行后的返回结果的连接。</p><p>代码 20 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenComposeExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String original = <span class="string">"Message"</span>;</span><br><span class="line">    CompletableFuture cf = CompletableFuture.completedFuture(original).thenApply(s -&gt; delayedUpperCase(s))</span><br><span class="line">    .thenCompose(upper -&gt; CompletableFuture.completedFuture(original).thenApply(s -&gt; delayedLowerCase(s))</span><br><span class="line">    .thenApply(s -&gt; upper + s));</span><br><span class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, cf.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="anyOf-方法"><a href="#anyOf-方法" class="headerlink" title="anyOf() 方法"></a>anyOf() 方法</h2><p>以下代码模拟了如何在几个计算过程中任意一个完成后创建 CompletableFuture，在这个例子中，我们创建了几个计算过程，然后转换字符串到大写字符。由于这些 CompletableFuture 是同步执行的（下面这个例子使用的是 thenApply() 方法，而不是 thenApplyAsync() 方法），使用 anyOf() 方法后返回的任何一个值都会立即触发 CompletableFuture。然后我们使用 whenComplete(BiConsumer&lt;? super Object, ? super Throwable&gt; action) 方法处理结果。</p><p>代码 21 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyOfExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    List messages = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">    List&lt;CompletableFuture&gt; futures = messages.stream()</span><br><span class="line">    .map(msg -&gt; CompletableFuture.completedFuture(msg).thenApply(s -&gt; delayedUpperCase(s)))</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">    CompletableFuture.anyOf(futures.toArray(<span class="keyword">new</span> CompletableFuture[futures.size()])).whenComplete((res, th) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(th == <span class="keyword">null</span>) &#123;</span><br><span class="line">        assertTrue(isUpperCase((String) res));</span><br><span class="line">        result.append(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="当所有的-CompletableFuture-完成后创建-CompletableFuture"><a href="#当所有的-CompletableFuture-完成后创建-CompletableFuture" class="headerlink" title="当所有的 CompletableFuture 完成后创建 CompletableFuture"></a>当所有的 CompletableFuture 完成后创建 CompletableFuture</h2><p>代码 22 所示我们会以同步方式执行多个异步计算过程，在所有计算过程都完成后，创建一个 CompletableFuture。</p><p>代码 22 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allOfExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    List messages = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">    List&lt;CompletableFuture&gt; futures = messages.stream()</span><br><span class="line">    .map(msg -&gt; CompletableFuture.completedFuture(msg).thenApply(s -&gt; delayedUpperCase(s)))</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">    CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> CompletableFuture[futures.size()])).whenComplete((v, th) -&gt; &#123;</span><br><span class="line">        futures.forEach(cf -&gt; assertTrue(isUpperCase(cf.getNow(<span class="keyword">null</span>))));</span><br><span class="line">        result.append(<span class="string">"done"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相较于前一个同步示例，我们也可以异步执行，如代码 23 所示。</p><p>代码 23 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allOfAsyncExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    List messages = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">    List&lt;CompletableFuture&gt; futures = messages.stream()</span><br><span class="line">    .map(msg -&gt; CompletableFuture.completedFuture(msg).thenApplyAsync(s -&gt; delayedUpperCase(s)))</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">    CompletableFuture allOf = CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> CompletableFuture[futures.size()]))</span><br><span class="line">.whenComplete((v, th) -&gt; &#123;</span><br><span class="line">    futures.forEach(cf -&gt; assertTrue(isUpperCase(cf.getNow(<span class="keyword">null</span>))));</span><br><span class="line">    result.append(<span class="string">"done"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    allOf.join();</span><br><span class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><p>以下代码完成的操作包括：</p><ol><li>首先异步地通过调用 cars() 方法获取 Car 对象，返回一个 CompletionStage<list> 实例。Cars() 方法可以在内部使用调用远端服务器上的 REST 服务等类似场景。</list></li><li>然后和其他的 CompletionStage<list> 组合，通过调用 rating(manufacturerId) 方法异步地返回 CompletionStage 实例。</list></li><li>当所有的 Car 对象都被填充了 rating 后，调用 allOf() 方法获取最终值。</li><li>调用 whenComplete() 方法打印最终的评分（rating）。</li></ol><p>代码 24 示例代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cars().thenCompose(cars -&gt; &#123;</span><br><span class="line">    List&lt;CompletionStage&gt; updatedCars = cars.stream()</span><br><span class="line">    .map(car -&gt; rating(car.manufacturerId).thenApply(r -&gt; &#123;</span><br><span class="line">    car.setRating(r);</span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">     &#125;)).collect(Collectors.toList());</span><br><span class="line">    CompletableFuture done = CompletableFuture</span><br><span class="line">    .allOf(updatedCars.toArray(<span class="keyword">new</span> CompletableFuture[updatedCars.size()]));</span><br><span class="line">    <span class="keyword">return</span> done.thenApply(v -&gt; updatedCars.stream().map(CompletionStage::toCompletableFuture)</span><br><span class="line">    .map(CompletableFuture::join).collect(Collectors.toList()));</span><br><span class="line">    &#125;).whenComplete((cars, th) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (th == <span class="keyword">null</span>) &#123;</span><br><span class="line">    cars.forEach(System.out::println);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(th);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).toCompletableFuture().join();</span><br></pre></td></tr></table></figure></p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>Completable 类为我们提供了丰富的异步计算调用方式，我们可以通过上述基本操作描述及 20 个示例程序进一步了解如果使用 CompletableFuture 类实现我们的需求，期待 JDK10 会有持续更新。</p><h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><p>参考 developerWorks 上的 Java 8 文章，了解更多 Java 8 知识。</p><p>参考书籍 Java 8 in Action Raoul-Gabriel Urma</p><p>参考书籍 Mastering Lambdas: Java Programming in a Multicore World Maurice Naftalin</p><p>参考文章 <a href="http://codingjunkie.net/completable-futures-part1/" target="_blank" rel="noopener">Java 8 CompletableFutures</a>，这篇文章从基础介绍了 CompletableFuture 类的使用方式。</p>]]></content>
    
    <summary type="html">
    
      本文是针对 JDK8 的 CompletableFuture 类进行解读的示例文章，我们知道不是所有的问题都适合这种风格的并行处理，例如我们所需要处理的元素必须是独立的，数据集要足够大，并且在并行加速方面，每个元素的处理成本要足够高，这样才能补偿建立 fork/join 框架所消耗的成本。本文将通过对 Future 类的解释、对 CompletableFuture 类的解释，以及使用 CompletableFuture 类的若干示例代码完成解读。
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
      <category term="JDK8" scheme="http://localhost/categories/Java/JDK8/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
      <category term="JDK8" scheme="http://localhost/tags/JDK8/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 web 网站架构演变过程</title>
    <link href="http://localhost/2018/03/31/%E6%94%B6%E9%9B%86/%E6%B5%85%E8%B0%88web%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/"/>
    <id>http://localhost/2018/03/31/收集/浅谈web网站架构演变过程/</id>
    <published>2018-03-31T03:23:19.115Z</published>
    <updated>2018-03-31T05:40:54.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们以 javaweb 为例，来搭建一个简单的电商系统，看看这个系统可以如何一步步演变。</p><p>该系统具备的功能： </p><ul><li>用户模块：用户注册和管理</li><li>商品模块：商品展示和管理</li><li>交易模块：创建交易和管理</li></ul><h1 id="阶段一、单机构建网站"><a href="#阶段一、单机构建网站" class="headerlink" title="阶段一、单机构建网站"></a>阶段一、单机构建网站</h1><p>网站的初期，我们经常会在单机上跑我们所有的程序和软件。此时我们使用一个容器，如 tomcat 、 jetty 、 jboos ，然后直接使用 JSP / servlet 技术，或者使用一些开源的框架如 maven + spring + struct + hibernate 、 maven + spring + springmvc + mybatis ；最后再选择一个数据库管理系统来存储数据，如 mysql 、 sqlserver 、 oracle ，然后通过 JDBC 进行数据库的连接和操作。</p><p>把以上的所有软件都装载同一台机器上，应用跑起来了，也算是一个小系统了。此时系统结果如下：<br><img src="http://ot0en8caw.bkt.clouddn.com/20180331123508.png" alt="单机构建网站"></p><h1 id="阶段二、应用服务器与数据库分离"><a href="#阶段二、应用服务器与数据库分离" class="headerlink" title="阶段二、应用服务器与数据库分离"></a>阶段二、应用服务器与数据库分离</h1><p>随着网站的上线，访问量逐步上升，服务器的负载慢慢提高，在服务器还没有超载的时候，我们应该就要做好准备，提升网站的负载能力。假如我们代码层面已难以优化，在不提高单台机器的性能的情况下，增加机器是一个不错的方式，不仅可以有效地提高系统的负载能力，而且性价比高。</p><p>增加的机器用来做什么呢？此时我们可以把数据库， web 服务器拆分开来，这样不仅提高了单台机器的负载能力，也提高了容灾能力。</p><p>应用服务器与数据库分开后的架构如下图所示：</p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180331123552.png" alt="应用服务器与数据库分离"></p><h1 id="阶段三、应用服务器集群"><a href="#阶段三、应用服务器集群" class="headerlink" title="阶段三、应用服务器集群"></a>阶段三、应用服务器集群</h1><p>随着访问量继续增加，单台应用服务器已经无法满足需求了。在假设数据库服务器没有压力的情况下，我们可以把应用服务器从一台变成了两台甚至多台，把用户的请求分散到不同的服务器中，从而提高负载能力。多台应用服务器之间没有直接的交互，他们都是依赖数据库各自对外提供服务。著名的做故障切换的软件有 keepalived ， keepalived 是一个类似于 layer3、4、7 交换机制的软件，他不是某个具体软件故障切换的专属品，而是可以适用于各种软件的一款产品。 keepalived 配合上 ipvsadm 又可以做负载均衡，可谓是神器。</p><p>我们以增加了一台应用服务器为例，增加后的系统结构图如下：</p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180331123712.png" alt="应用服务器集群 01"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>系统演变到这里，将会出现下面四个问题：</p><ol><li>用户的请求由谁来转发到到具体的应用服务器</li><li>有什么转发的算法</li><li>应用服务器如何返回用户的请求</li><li>用户如果每次访问到的服务器不一样，那么如何维护 session 的一致性</li></ol><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>我们来看看解决问题的方案：</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>第一个问题即是负载均衡的问题，一般有 5 种解决方案：</p><ol><li><p><strong>http 重定向 </strong>。 HTTP 重定向就是应用层的请求转发。用户的请求其实已经到了 HTTP 重定向负载均衡服务器，服务器根据算法要求用户重定向，用户收到重定向请求后，再次请求真正的集群</p><ul><li><strong>优点</strong>：简单。</li><li><strong>缺点</strong>：性能较差。</li></ul></li><li><p><strong>DNS 域名解析负载均衡 </strong>。 DNS 域名解析负载均衡就是在用户请求 DNS 服务器，获取域名对应的 IP 地址时， DNS 服务器直接给出负载均衡后的服务器 IP 。</p><ul><li><strong>优点</strong>：交给 DNS ，不用我们去维护负载均衡服务器。</li><li><strong>缺点</strong>：当一个应用服务器挂了，不能及时通知 DNS ，而且 DNS 负载均衡的控制权在域名服务商那里，网站无法做更多的改善和更强大的管理。</li></ul></li><li><p><strong>反向代理服务器</strong>。在用户的请求到达反向代理服务器时（已经到达网站机房），由反向代理服务器根据算法转发到具体的服务器。常用的 apache ， nginx 都可以充当反向代理服务器。</p><ul><li><strong>优点</strong>：部署简单。</li><li><strong>缺点</strong>：代理服务器可能成为性能的瓶颈，特别是一次上传大文件。</li></ul></li><li><p><strong>IP 层负载均衡</strong>。在请求到达负载均衡器后，负载均衡器通过修改请求的目的 IP 地址，从而实现请求的转发，做到负载均衡。</p><ul><li><strong>优点</strong>：性能更好。</li><li><strong>缺点</strong>：负载均衡器的宽带成为瓶颈。</li></ul></li><li><p><strong>数据链路层负载均衡</strong>。在请求到达负载均衡器后，负载均衡器通过修改请求的 mac 地址，从而做到负载均衡，与 IP 负载均衡不一样的是，当请求访问完服务器之后，直接返回客户。而无需再经过负载均衡器。</p></li></ol><h3 id="集群调度算法"><a href="#集群调度算法" class="headerlink" title="集群调度算法"></a>集群调度算法</h3><p>第二个问题即是集群调度算法问题，常见的调度算法有 10 种。</p><ol><li><p><strong>rr 轮询调度算法</strong>。顾名思义，轮询分发请求。</p><ul><li>优点：实现简单</li><li>缺点：不考虑每台服务器的处理能力</li></ul></li><li><p><strong>wrr 加权调度算法</strong>。我们给每个服务器设置权值 weight ，负载均衡调度器根据权值调度服务器，服务器被调用的次数跟权值成正比。</p><ul><li>优点：考虑了服务器处理能力的不同</li></ul></li><li><p><strong>sh 原地址散列</strong>：提取用户 IP ，根据散列函数得出一个 key ，再根据静态映射表，查处对应的 value ，即目标服务器 IP 。过目标机器超负荷，则返回空。</p></li><li><p><strong>dh 目标地址散列</strong>：同上，只是现在提取的是目标地址的 IP 来做哈希。</p><ul><li>优点：以上两种算法的都能实现同一个用户访问同一个服务器。</li></ul></li><li><p><strong>lc 最少连接</strong>。优先把请求转发给连接数少的服务器。</p><ul><li>优点：使得集群中各个服务器的负载更加均匀。</li></ul></li><li><p><strong>wlc 加权最少连接</strong>。在 lc 的基础上，为每台服务器加上权值。算法为：（ 活动连接数 * 256 + 非活动连接数 ）÷ 权重 ，计算出来的值小的服务器优先被选择。</p><ul><li>优点：可以根据服务器的能力分配请求。</li></ul></li><li><p><strong>sed 最短期望延迟</strong>。其实 sed 跟 wlc 类似，区别是不考虑非活动连接数。算法为：（ 活动连接数 + 1 ) * 256 ÷ 权重，同样计算出来的值小的服务器优先被选择。</p></li><li><p><strong>nq 永不排队</strong>。改进的 sed 算法。我们想一下什么情况下才能“永不排队”，那就是服务器的连接数为 0 的时候，那么假如有服务器连接数为 0 ，均衡器直接把请求转发给它，无需经过 sed 的计算。</p></li><li><p><strong>LBLC 基于局部性的最少连接</strong>。均衡器根据请求的目的 IP 地址，找出该 IP 地址最近被使用的服务器，把请求转发之，若该服务器超载，最采用最少连接数算法。</p></li><li><p><strong>LBLCR 带复制的基于局部性的最少连接</strong>。均衡器根据请求的目的 IP 地址，找出该 IP 地址最近使用的“服务器组”，注意，并不是具体某个服务器，然后采用最少连接数从该组中挑出具体的某台服务器出来，把请求转发之。若该服务器超载，那么根据最少连接数算法，在集群的非本服务器组的服务器中，找出一台服务器出来，加入本服务器组，然后把请求转发之。</p></li></ol><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>第三个问题是集群模式问题，一般 3 种解决方案：</p><ol><li><p><strong>NAT</strong>：负载均衡器接收用户的请求，转发给具体服务器，服务器处理完请求返回给均衡器，均衡器再重新返回给用户。</p></li><li><p><strong>DR</strong>：负载均衡器接收用户的请求，转发给具体服务器，服务器出来玩请求后直接返回给用户。需要系统支持 IP Tunneling 协议，难以跨平台。</p></li><li><p><strong>TUN</strong>：同上，但无需 IP Tunneling 协议，跨平台性好，大部分系统都可以支持。</p></li></ol><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>第四个问题是 <strong>session</strong> 问题，一般有 4 种解决方案：</p><ol><li><p><strong>Session Sticky</strong>。 session sticky 就是把同一个用户在某一个会话中的请求，都分配到固定的某一台服务器中，这样我们就不需要解决跨服务器的 session 问题了，常见的算法有 ip_hash 法，即上面提到的两种散列算法。</p><ul><li>优点：实现简单。</li><li>缺点：应用服务器重启则 session 消失。</li></ul></li><li><p><strong>Session Replication</strong>。 session replication 就是在集群中复制 session ，使得每个服务器都保存有全部用户的 session 数据。</p><ul><li>优点：减轻负载均衡服务器的压力，不需要要实现 ip_hasp 算法来转发请求。</li><li>缺点：复制时宽带开销大，访问量大的话 session 占用内存大且浪费。</li></ul></li><li><p><strong>Session 数据集中存储 </strong>： session 数据集中存储就是利用数据库来存储 session 数据，实现了 session 和应用服务器的解耦。</p><ul><li>优点：相比 session replication 的方案，集群间对于宽带和内存的压力减少了很多。</li><li>缺点：需要维护存储 session 的数据库。</li></ul></li><li><p><strong>Cookie Base</strong>： cookie base 就是把 session 存在 cookie 中，有浏览器来告诉应用服务器我的 session 是什么，同样实现了 session 和应用服务器的解耦。</p><ul><li>优点：实现简单，基本免维护。</li><li>缺点： cookie 长度限制，安全性低，宽带消耗。</li></ul></li></ol><p><strong>值得一提的是</strong>：</p><p>nginx 目前支持的负载均衡算法有 wrr 、 sh （支持一致性哈希）、 fair （本人觉得可以归结为 lc ）。但 nginx 作为均衡器的话，还可以一同作为静态资源服务器。</p><p>keepalived + ipvsadm 比较强大，目前支持的算法有： rr 、 wrr 、 lc 、 wlc 、 lblc 、 sh 、 dh</p><p>keepalived 支持集群模式有： NAT 、 DR 、 TUN</p><p>nginx 本身并没有提供 session 同步的解决方案，而 apache 则提供了 session 共享的支持。</p><p>好了，解决了以上的问题之后，系统的结构如下：</p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180331123750.png" alt="应用服务器集群 02"></p><h1 id="阶段四、数据库读写分离化"><a href="#阶段四、数据库读写分离化" class="headerlink" title="阶段四、数据库读写分离化"></a>阶段四、数据库读写分离化</h1><p>上面我们总是假设数据库负载正常，但随着访问量的的提高，数据库的负载也在慢慢增大。那么可能有人马上就想到跟应用服务器一样，把数据库一份为二再负载均衡即可。但对于数据库来说，并没有那么简单。假如我们简单的把数据库一分为二，然后对于数据库的请求，分别负载到 A 机器和 B 机器，那么显而易见会造成两台数据库数据不统一的问题。那么对于这种情况，我们可以先考虑使用读写分离的方式。</p><p>读写分离后的数据库系统结构如下：</p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180331123812.png" alt="数据库读写分离化"></p><p><strong> 这个结构变化后也会带来两个问题 </strong>：</p><ol><li>主从数据库之间数据同步问题</li><li>应用对于数据源的选择问题　</li></ol><p><strong> 解决问题方案 </strong>：</p><ol><li>我们可以使用 MYSQL 自带的 master + slave 的方式实现主从复制。</li><li>采用第三方数据库中间件，例如 mycat 。 mycat 是从 cobar 发展而来的，而 cobar 是阿里开源的数据库中间件，后来停止开发。 mycat 是国内比较好的 mysql 开源数据库分库分表中间件。</li></ol><h1 id="阶段五、用搜索引擎缓解读库的压力"><a href="#阶段五、用搜索引擎缓解读库的压力" class="headerlink" title="阶段五、用搜索引擎缓解读库的压力"></a>阶段五、用搜索引擎缓解读库的压力</h1><p>数据库做读库的话，常常对模糊查找力不从心，即使做了读写分离，这个问题还未能解决。以我们所举的交易网站为例，发布的商品存储在数据库中，用户最常使用的功能就是查找商品，尤其是根据商品的标题来查找对应的商品。对于这种需求，一般我们都是通过 like 功能来实现的，但是这种方式的代价非常大。此时我们可以使用搜索引擎的倒排索引来完成。<br><strong> 搜索引擎具有以下优点 </strong>：</p><ul><li>它能够大大提高查询速度。</li></ul><p><strong> 引入搜索引擎后也会带来以下的开销 </strong>：</p><ul><li>带来大量的维护工作，我们需要自己实现索引的构建过程，设计全量 / 增加的构建方式来应对非实时与实时的查询需求。</li><li><p>需要维护搜索引擎集群</p><p>搜索引擎并不能替代数据库，他解决了某些场景下的 “读” 的问题，是否引入搜索引擎，需要综合考虑整个系统的需求。引入搜索引擎后的系统结构如下：</p></li></ul><p><img src="http://ot0en8caw.bkt.clouddn.com/20180331123824.png" alt="用搜索引擎缓解读库的压力"></p><h1 id="阶段六、用缓存缓解读库的压力"><a href="#阶段六、用缓存缓解读库的压力" class="headerlink" title="阶段六、用缓存缓解读库的压力"></a>阶段六、用缓存缓解读库的压力</h1><ol><li><p>后台应用层和数据库层的缓存</p><p> 随着访问量的增加，逐渐出现了许多用户访问同一部分内容的情况，对于这些比较热门的内容，没必要每次都从数据库读取。我们可以使用缓存技术，例如可以使用 google 的开源缓存技术 guava 或者使用 memcacahe 作为应用层的缓存，也可以使用 redis 作为数据库层的缓存。</p><p> 另外，在某些场景下，关系型数据库并不是很适合，例如我想做一个 “每日输入密码错误次数限制” 的功能，思路大概是在用户登录时，如果登录错误，则记录下该用户的 IP 和错误次数，那么这个数据要放在哪里呢？假如放在内存中，那么显然会占用太大的内容；假如放在关系型数据库中，那么既要建立数据库表，还要简历对应的 java bean ，还要写 SQL 等等。而分析一下我们要存储的数据，无非就是类似 {ip:errorNumber} 这样的 key : value 数据。对于这种数据，我们可以用 NOSQL 数据库来代替传统的关系型数据库。</p></li><li><p>页面缓存</p><p> 除了数据缓存，还有页面缓存。比如使用 HTML5 的 localstroage 或者 cookie。</p></li></ol><ul><li><strong>优点</strong>：<ul><li>减轻数据库的压力</li><li>大幅度提高访问速度</li></ul></li><li><strong>缺点</strong>：<ul><li>需要维护缓存服务器</li><li>提高了编码的复杂性</li></ul></li></ul><p><strong>值得一提的是</strong>：<br>缓存集群的调度算法不同与上面提到的应用服务器和数据库。最好采用“一致性哈希算法”，这样才能提高命中率。这个就不展开讲了，有兴趣的可以查阅相关资料。</p><p><strong>加入缓存后的结构</strong>：</p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180331123903.png" alt="加入缓存后的结构"></p><h1 id="阶段七、数据库水平拆分与垂直拆分"><a href="#阶段七、数据库水平拆分与垂直拆分" class="headerlink" title="阶段七、数据库水平拆分与垂直拆分"></a>阶段七、数据库水平拆分与垂直拆分</h1><p>我们的网站演进到现在，交易、商品、用户的数据都还在同一个数据库中。尽管采取了增加缓存，读写分离的方式，但随着数据库的压力继续增加，数据库的瓶颈越来越突出，此时，我们可以有数据垂直拆分和水平拆分两种选择。</p><h2 id="数据垂直拆分"><a href="#数据垂直拆分" class="headerlink" title="数据垂直拆分"></a>数据垂直拆分</h2><p>垂直拆分的意思是把数据库中不同的业务数据拆分道不同的数据库中，结合现在的例子，就是把交易、商品、用户的数据分开。</p><ul><li><p><strong>优点</strong>：<br>解决了原来把所有业务放在一个数据库中的压力问题。<br>可以根据业务的特点进行更多的优化</p></li><li><p><strong>缺点</strong>：<br>需要维护多个数据库</p></li><li><p><strong>问题</strong>：<br>需要考虑原来跨业务的事务<br>跨数据库的 join</p></li><li><p><strong>解决问题方案</strong>：<br>我们应该在应用层尽量避免跨数据库的事物，如果非要跨数据库，尽量在代码中控制。<br>我们可以通过第三方应用来解决，如上面提到的 mycat ， mycat 提供了丰富的跨库 join 方案，详情可参考 mycat 官方文档。</p></li></ul><p>垂直拆分后的结构如下：<br><img src="http://ot0en8caw.bkt.clouddn.com/20180331123918.png" alt="垂直拆分后"></p><h2 id="数据水平拆分"><a href="#数据水平拆分" class="headerlink" title="数据水平拆分"></a>数据水平拆分</h2><p>数据水平拆分就是把同一个表中的数据拆分到两个甚至多个数据库中。产生数据水平拆分的原因是某个业务的数据量或者更新量到达了单个数据库的瓶颈，这时就可以把这个表拆分到两个或更多个数据库中。</p><ul><li><p><strong>优点</strong>：<br>如果我们能客服以上问题，那么我们将能够很好地对数据量及写入量增长的情况。</p></li><li><p><strong>问题</strong>：<br>访问用户信息的应用系统需要解决 SQL 路由的问题，因为现在用户信息分在了两个数据库中，需要在进行数据操作时了解需要操作的数据在哪里。<br>主键的处理也变得不同，例如原来自增字段，现在不能简单地继续使用了。<br>如果需要分页，就麻烦了。</p></li><li><p><strong>解决问题方案</strong>：<br>我们还是可以通过可以解决第三方中间件，如 mycat。mycat 可以通过 SQL 解析模块对我们的 SQL 进行解析，再根据我们的配置，把请求转发到具体的某个数据库。<br>我们可以通过 UUID 保证唯一或自定义 ID 方案来解决。<br>mycat 也提供了丰富的分页查询方案，比如先从每个数据库做分页查询，再合并数据做一次分页查询等等。<br>数据水平拆分后的结构：</p></li></ul><p><img src="http://ot0en8caw.bkt.clouddn.com/20180331123928.png" alt="水平拆分后"></p><h1 id="阶段八、应用的拆分"><a href="#阶段八、应用的拆分" class="headerlink" title="阶段八、应用的拆分"></a>阶段八、应用的拆分</h1><h2 id="拆分应用"><a href="#拆分应用" class="headerlink" title="拆分应用"></a>拆分应用</h2><p>随着业务的发展，业务越来越多，应用越来越大。我们需要考虑如何避免让应用越来越臃肿。这就需要把应用拆开，从一个应用变为俩个甚至更多。还是以我们上面的例子，我们可以把用户、商品、交易拆分开。变成 “用户、商品” 和“用户，交易”两个子系统。　　</p><p>拆分后的结构：<br><img src="http://ot0en8caw.bkt.clouddn.com/20180331123946.png" alt=""></p><ul><li><p><strong>问题</strong>：<br>这样拆分后，可能会有一些相同的代码，如用户相关的代码，商品和交易都需要用户信息，所以在两个系统中都保留差不多的操作用户信息的代码。如何保证这些代码可以复用是一个需要解决的问题。</p></li><li><p><strong>解决问题</strong>：<br>通过走服务化的路线来解决</p></li></ul><h2 id="走服务化的道路"><a href="#走服务化的道路" class="headerlink" title="走服务化的道路"></a>走服务化的道路</h2><p>为了解决上面拆分应用后所出现的问题，我们把公共的服务拆分出来，形成一种服务化的模式，简称 SOA。</p><p>采用服务化之后的系统结构：<br><img src="http://ot0en8caw.bkt.clouddn.com/20180331123955.png" alt=""></p><ul><li><p><strong>优点</strong>：<br>相同的代码不会散落在不同的应用中了，这些实现放在了各个服务中心，使代码得到更好的维护。<br>我们把对数据库的交互放在了各个服务中心，让”前端“的 web 应用更注重与浏览器交互的工作。</p></li><li><p><strong>问题</strong>：<br>如何进行远程的服务调用</p></li><li><p><strong>解决方法</strong>：<br>我们可以通过下面的引入消息中间件来解决</p></li></ul><h1 id="阶段九、引入消息中间件"><a href="#阶段九、引入消息中间件" class="headerlink" title="阶段九、引入消息中间件"></a>阶段九、引入消息中间件</h1><p>随着网站的继续发展，我们的系统中可能出现不同语言开发的子模块和部署在不同平台的子系统。此时我们需要一个平台来传递可靠的，与平台和语言无关的数据，并且能够把负载均衡透明化，能在调用过程中收集调用数据并分析之，推测出网站的访问增长率等等一系列需求，对于网站应该如何成长做出预测。开源消息中间件有阿里的 dubbo，可以搭配 Google 开源的分布式程序协调服务 zookeeper 实现服务器的注册与发现。</p><p>引入消息中间件后的结构：</p><p><img src="http://ot0en8caw.bkt.clouddn.com/20180331124003.png" alt=""></p><h1 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h1><p>以上的演变过程只是一个例子，并不适合所有的网站，实际中网站演进过程与自身业务和不同遇到的问题有密切的关系，没有固定的模式。只有认真的分析和不断地探究，才能发现适合自己网站的架构。</p><p>本文有什么说错的地方，希望大家指出，让我好改正过来，多谢。<br>本文转载自</p>]]></content>
    
    <summary type="html">
    
      以一个简单的电商系统，看看这个系统如何一步步演变。
    
    </summary>
    
      <category term="随笔" scheme="http://localhost/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://localhost/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="web" scheme="http://localhost/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Google Java编程风格指南</title>
    <link href="http://localhost/2018/03/31/Java/Google%20Java%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
    <id>http://localhost/2018/03/31/Java/Google Java编程风格指南/</id>
    <published>2018-03-31T01:42:10.432Z</published>
    <updated>2018-03-31T02:30:39.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。</p><p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。</p><h2 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h2><p>在本文档中，除非另有说明：</p><p>术语class可表示一个普通类，枚举类，接口或是annotation类型(<code>@interface</code>)<br>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。<br>其他的术语说明会偶尔在后面的文档出现。</p><h2 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h2><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p><h1 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h1><h2 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h2><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p><h2 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h2><p>源文件编码格式为UTF-8。</p><h2 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h2><h3 id="2-3-1-空白字符"><a href="#2-3-1-空白字符" class="headerlink" title="2.3.1 空白字符"></a>2.3.1 空白字符</h3><p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p><ul><li>所有其它字符串中的空白字符都要进行转义。</li><li>制表符不用于缩进。</li></ul><h3 id="2-3-2-特殊转义序列"><a href="#2-3-2-特殊转义序列" class="headerlink" title="2.3.2 特殊转义序列"></a>2.3.2 特殊转义序列</h3><p>对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, “, ‘及\)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。</p><h3 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h3><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p><blockquote><p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p></blockquote><p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String unitAbbrev = <span class="string">"μs"</span>;                                 | 赞，即使没有注释也非常清晰</span><br><span class="line">String unitAbbrev = <span class="string">"\u03bcs"</span>; <span class="comment">// "μs"                    | 允许，但没有理由要这样做</span></span><br><span class="line">String unitAbbrev = <span class="string">"\u03bcs"</span>; <span class="comment">// Greek letter mu, "s"    | 允许，但这样做显得笨拙还容易出错</span></span><br><span class="line">String unitAbbrev = <span class="string">"\u03bcs"</span>;                            | 很糟，读者根本看不出这是什么</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\ufeff'</span> + content; <span class="comment">// byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释</span></span><br></pre></td></tr></table></figure></p><blockquote><p>Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)</p></blockquote><h1 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h1><p>一个源文件包含(按顺序地)：</p><ol><li>许可证或版权信息(如有需要)</li><li>package语句</li><li>import语句</li><li>一个顶级类(只有一个)</li></ol><p>以上每个部分之间用一个空行隔开。</p><h2 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h2><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h2 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h2><p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p><h2 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h2><h3 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h3><p>即，不要出现类似这样的import语句：<code>import java.util.*</code>;</p><h3 id="3-3-2-不要换行"><a href="#3-3-2-不要换行" class="headerlink" title="3.3.2 不要换行"></a>3.3.2 不要换行</h3><p>import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)</p><h3 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h3><p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p><p>所有的静态导入独立成组<br><code>com.google</code> imports(仅当这个源文件是在<code>com.google</code>包下)<br>第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun<br><code>java</code> imports<br><code>javax</code> imports<br>组内不空行，按字典序排列。</p><h2 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h2><h3 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h3><p>每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。</p><p>例外：package-info.java，该文件中可没有package-info类。</p><h3 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h3><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h3 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h3><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p>术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p><h2 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h2><h3 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h3><p>大括号与<code>if, else, for, do, while</code>语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p><h3 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h3><p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (<a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html" target="_blank" rel="noopener">Egyptian brackets</a>):</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyClass() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        something();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ProblemException e) &#123;</span><br><span class="line">        recover();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4.8.1节给出了enum类的一些例外。</p><h3 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h3><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成<code>{}</code>，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。</p><p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothing</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-2-块缩进：2个空格"><a href="#4-2-块缩进：2个空格" class="headerlink" title="4.2 块缩进：2个空格"></a>4.2 块缩进：2个空格</h2><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p><h2 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h2><p>每个语句后要换行。</p><h2 id="4-4-列限制：80或100"><a href="#4-4-列限制：80或100" class="headerlink" title="4.4 列限制：80或100"></a>4.4 列限制：80或100</h2><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p><p>例外：</p><ol><li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。</li><li>package和import语句(见3.2节和3.3节)。</li><li>注释中那些可能被剪切并粘贴到shell中的命令行。</li></ol><h2 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h2><p>术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p><p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p><blockquote><p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p></blockquote><h3 id="4-5-1-从哪里断开"><a href="#4-5-1-从哪里断开" class="headerlink" title="4.5.1 从哪里断开"></a>4.5.1 从哪里断开</h3><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p><ol><li>如果在<code>非赋值运算符</code>处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<code>&lt;T extends Foo &amp; Bar&gt;</code>)，catch块中的管道符号(<code>catch (FooException | BarException e</code>)</li><li>如果在<code>赋值运算符处</code>断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于<code>foreach</code>语句中的分号。</li><li>方法名或构造函数名与左括号留在同一行。</li><li>逗号(,)与其前面的内容留在同一行。</li></ol><h3 id="4-5-2-自动换行时缩进至少-4个空格"><a href="#4-5-2-自动换行时缩进至少-4个空格" class="headerlink" title="4.5.2 自动换行时缩进至少+4个空格"></a>4.5.2 自动换行时缩进至少+4个空格</h3><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p><p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p><p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p><h2 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h2><h3 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h3><p>以下情况需要使用一个空行：</p><ol><li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。<ul><li><strong>例外：</strong>两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li></ul></li><li>在函数体内，语句的逻辑分组间使用空行。</li><li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li><li>要满足本文档中其他节的空行要求(比如3.3节：import语句)<br>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</li></ol><h3 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h3><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p><ol><li>分隔任何保留字与紧随其后的左括号(<code>(</code>)(如<code>if, for catch</code>等)。</li><li>分隔任何保留字与其前面的右大括号(<code>}</code>)(如<code>else, catch</code>)。</li><li>在任何左大括号前({)，两个例外：<ul><li><code>@SomeAnnotation({a, b})</code>(不使用空格)。</li><li><code>String[][] x = foo;</code>(大括号间没有空格，见下面的Note)。</li></ul></li><li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul><li>类型界限中的&amp;(<code>&lt;T extends Foo &amp; Bar&gt;</code>)。</li><li>catch块中的管道符号(<code>catch (FooException | BarException e</code>)。</li><li><code>foreach</code>语句中的分号。</li></ul></li><li>在<code>, : ;</code>及右括号(<code>)</code>)后</li><li>如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。</li><li>类型和变量之间：List list。</li><li>数组初始化中，大括号内的空格是可选的，即<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>都是可以的。</li></ol><blockquote><p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p></blockquote><h3 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h3><p><strong>术语说明</strong>：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p><p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p><p>以下示例先展示未对齐的代码，然后是对齐的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x; <span class="comment">// this is fine</span></span><br><span class="line"><span class="keyword">private</span> Color color; <span class="comment">// this too</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>   x;      <span class="comment">// permitted, but future edits</span></span><br><span class="line"><span class="keyword">private</span> Color color;  <span class="comment">// may leave it unaligned</span></span><br></pre></td></tr></table></figure></p><blockquote><p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p></blockquote><h2 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h2><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p><h1 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h1><h3 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h3><p>枚举常量间用逗号隔开，换行可选。</p><p>没有方法和文档的枚举类可写成数组初始化的格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</span><br></pre></td></tr></table></figure></p><p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p><h3 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h3><h4 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h4><p>不要使用组合声明，比如<code>int a, b</code>;。</p><h4 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h4><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p><h3 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h3><h4 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h4><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h4><p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p><h3 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h3><p><strong>术语说明</strong>：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。</p><h4 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h4><p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p><p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p><h4 id="4-8-4-2-Fall-through：注释"><a href="#4-8-4-2-Fall-through：注释" class="headerlink" title="4.8.4.2 Fall-through：注释"></a>4.8.4.2 Fall-through：注释</h4><p>在一个switch块内，每个语句组要么通过<code>break, continue, return</code>或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    prepareOneOrTwo();</span><br><span class="line">    <span class="comment">// fall through</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    handleOneTwoOrThree();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    handleLargeNumber(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4-8-4-3-default的情况要写出来"><a href="#4-8-4-3-default的情况要写出来" class="headerlink" title="4.8.4.3 default的情况要写出来"></a>4.8.4.3 default的情况要写出来</h4><p>每个switch语句都包含一个<code>default</code>语句组，即使它什么代码也不包含。</p><h3 id="4-8-5-注解-Annotations"><a href="#4-8-5-注解-Annotations" class="headerlink" title="4.8.5 注解(Annotations)"></a>4.8.5 注解(Annotations)</h3><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNameIfPresent</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>例外：单个的注解可以和签名的第一行出现在同一行。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Partial</span> <span class="meta">@Mock</span> DataLoader loader;</span><br></pre></td></tr></table></figure></p><p>参数和局部变量注解没有特定规则。</p><h3 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h3><h4 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h4><p>块注释与其周围的代码在同一缩进级别。它们可以是<code>/* ... *</code>/风格，也可以是<code>// ...</code>风格。对于多行的<code>/* ... */</code>注释，后续行必须从<em>开始， 并且与前一行的</em>对齐。以下示例注释都是OK的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is          // And so           /* Or you can</span></span><br><span class="line"><span class="comment"> * okay.            // is this.          * even do this. */</span></span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p>注释不要封闭在由星号或其它字符绘制的框架里。</p><p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用<code>/* ... */</code>。</p><h3 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h3><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">synchronized</span> <span class="keyword">native</span> <span class="keyword">strictfp</span></span><br></pre></td></tr></table></figure></p><p>命名约定</p><h2 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h2><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p><p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p><h2 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h2><h3 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h3><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p><h3 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h3><p>类名都以<code>UpperCamelCase</code>风格编写。</p><p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以<code>Test</code>结束。例如，<code>HashTest</code>或<code>HashIntegrationTest</code>。</p><h3 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h3><p>方法名都以<code>lowerCamelCase</code>风格编写。</p><p>方法名通常是动词或动词短语。</p><p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如<code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p><h3 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h3><p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p><p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远<code>不打算</code>改变对象一般是不够的，它要真的一直不变才能将它示为常量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableList&lt;String&gt; NAMES = ImmutableList.of(<span class="string">"Ed"</span>, <span class="string">"Ann"</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Joiner COMMA_JOINER = Joiner.on(<span class="string">','</span>);  <span class="comment">// because Joiner is immutable</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</span><br><span class="line"><span class="keyword">enum</span> SomeEnum &#123; ENUM_CONSTANT &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not constants</span></span><br><span class="line"><span class="keyword">static</span> String nonFinal = <span class="string">"non-final"</span>;</span><br><span class="line"><span class="keyword">final</span> String nonStatic = <span class="string">"non-static"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; mutableCollection = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(MyClass.getName());</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] nonEmptyArray = &#123;<span class="string">"these"</span>, <span class="string">"can"</span>, <span class="string">"change"</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>这些名字通常是名词或名词短语。</p><h3 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h3><p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p><p>这些名字通常是名词或名词短语。</p><h3 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h3><p>参数名以<code>lowerCamelCase</code>风格编写。</p><p>参数应该避免用单个字符命名。</p><h3 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h3><p>局部变量名以<code>lowerCamelCase</code>风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p><p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p><p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p><h3 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h3><p>类型变量可用以下两种风格之一进行命名：</p><ul><li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li><li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。<h2 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h2><a href="http://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB" target="_blank" rel="noopener">驼峰式命名法</a>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</li></ul><p>名字从<code>散文形式</code>(prose form)开始:</p><ol><li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li><li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。</li></ol><ul><li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul><ol><li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：</li></ol><ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li><li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul><ol><li>最后将所有的单词连接起来得到一个标识符。<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Prose form                Correct               Incorrect</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">&quot;XML HTTP request&quot;        XmlHttpRequest        XMLHTTPRequest</span><br><span class="line">&quot;new customer ID&quot;         newCustomerId         newCustomerID</span><br><span class="line">&quot;inner stopwatch&quot;         innerStopwatch        innerStopWatch</span><br><span class="line">&quot;supports IPv6 on iOS?&quot;   supportsIpv6OnIos     supportsIPv6OnIOS</span><br><span class="line">&quot;YouTube importer&quot;        YouTubeImporter</span><br><span class="line">                          YoutubeImporter*</span><br></pre></td></tr></table></figure></li></ol><p>加星号处表示可以，但不推荐。</p><blockquote><p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p></blockquote><h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><h2 id="6-1-Override：能用则用"><a href="#6-1-Override：能用则用" class="headerlink" title="6.1 @Override：能用则用"></a>6.1 @Override：能用则用</h2><p>只要是合法的，就把<code>@Override</code>注解给用上。</p><h2 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h2><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p><p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> i = Integer.parseInt(response);</span><br><span class="line">  <span class="keyword">return</span> handleNumericResponse(i);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException ok) &#123;</span><br><span class="line">  <span class="comment">// it's not numeric; that's fine, just continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handleTextResponse(response);</span><br></pre></td></tr></table></figure></p><p>例外：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  emptyStack.pop();</span><br><span class="line">  fail();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException expected) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h2><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo aFoo = ...;</span><br><span class="line">Foo.aStaticMethod(); <span class="comment">// good</span></span><br><span class="line">aFoo.aStaticMethod(); <span class="comment">// bad</span></span><br><span class="line">somethingThatYieldsAFoo().aStaticMethod(); <span class="comment">// very bad</span></span><br></pre></td></tr></table></figure></p><h2 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h2><p>极少会去重写<code>Object.finalize</code>。</p><blockquote><p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解<a href="http://books.google.com/books?isbn=8131726592" target="_blank" rel="noopener">Effective Java</a> 第7条款：“Avoid Finalizers”，然后不要使用它。</p></blockquote><h1 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h1><h2 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h2><h3 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h3><p>Javadoc块的基本格式如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Multiple lines of Javadoc text are written here,</span></span><br><span class="line"><span class="comment"> * wrapped normally...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(String p1)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>或者是以下单行形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** An especially short bit of Javadoc. */</span></span><br></pre></td></tr></table></figure></p><p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p><h3 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h3><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签<code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p><h3 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h3><p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p><h2 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h2><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p><p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p><blockquote><p>Tip：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p></blockquote><h2 id="7-3-哪里需要使用Javadoc"><a href="#7-3-哪里需要使用Javadoc" class="headerlink" title="7.3 哪里需要使用Javadoc"></a>7.3 哪里需要使用Javadoc</h2><p>至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：</p><h3 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h3><p>对于简单明显的方法如<code>getFoo</code>，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p><p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p><blockquote><p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>， 就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p></blockquote><h3 id="7-3-2-例外：重写"><a href="#7-3-2-例外：重写" class="headerlink" title="7.3.2 例外：重写"></a>7.3.2 例外：重写</h3><p>如果一个方法重写了超类中的方法，那么Javadoc并非必需的。</p><h3 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h3><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p><p>后记<br>本文档翻译自<a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html" target="_blank" rel="noopener">Google Java Style</a>， 译者<a href="http://weibo.com/hawstein" target="_blank" rel="noopener">@Hawstein</a>,转载自<a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener">Hawstein’s Blog</a>。</p>]]></content>
    
    <summary type="html">
    
      这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>全能型开源远程终端：MobaXterm</title>
    <link href="http://localhost/2018/03/28/soft/MobaXterm/"/>
    <id>http://localhost/2018/03/28/soft/MobaXterm/</id>
    <published>2018-03-28T14:42:39.297Z</published>
    <updated>2018-03-29T05:33:22.215Z</updated>
    
    <summary type="html">
    
      破解Securecrt怕中毒，Xshell 用着不爽，Putty太单薄，手头没Mac用不了iterm2。那就试试这个全能开源的终端吧(MobaXterm)!下面就介绍下MobaXterm的主要功能
    
    </summary>
    
      <category term="软件" scheme="http://localhost/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="MobaXterm" scheme="http://localhost/tags/MobaXterm/"/>
    
      <category term="软件" scheme="http://localhost/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 2018.1 更新内容</title>
    <link href="http://localhost/2018/03/28/soft/IDEA2018.1/"/>
    <id>http://localhost/2018/03/28/soft/IDEA2018.1/</id>
    <published>2018-03-28T12:09:47.686Z</published>
    <updated>2018-03-28T14:23:32.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Enhancements-in-code-completion"><a href="#Enhancements-in-code-completion" class="headerlink" title="Enhancements in code completion"></a>Enhancements in code completion</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaCodeCompletion.gif" alt=""><br>Completion in the Stream API chains is now aware of type casting. Code completion can not only suggest a completion item according to the existing call filter (String.class::isInstance), but also for an automatically typecast completion item.</p><h2 id="Data-flow-analysis"><a href="#Data-flow-analysis" class="headerlink" title="Data flow analysis"></a>Data flow analysis</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaDataFlow1.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaDataFlow3.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaDataFlow2.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaImmutableCollections.png" alt=""><br>We’ve improved our <strong>data flow analysis</strong> so it can now track the relationships between variables like “greater than” and “less than.” The IDE detects when a condition is always true (or false) in all the possible code paths when the variables are compared.</p><p>The IDE will now warn you when you try to assign a variable to the same value it already contains. This may help you detect and then remove some redundant code.</p><p>The <strong>data flow analysis</strong> now works for non-terminated stream API chains.</p><p>The IDE will also warn you about modifications to immutable collections.</p><p><a href="https://blog.jetbrains.com/idea/2018/01/fumigating-the-idea-ultimate-code-using-dataflow-analysis/" target="_blank" rel="noopener">learn more</a></p><h2 id="Missing-ServiceLoader-declaration"><a href="#Missing-ServiceLoader-declaration" class="headerlink" title="Missing ServiceLoader declaration"></a>Missing ServiceLoader declaration</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Java9ServiceLoader.gif" alt=""><br>IntelliJ IDEA 2018.1 has new <strong>Java 9</strong> inspections and quick-fixes. The IDE now checks that a service loaded by <strong>ServiceLoader</strong> is declared in the module-info.java file, and will offer a quick-fix to add a missing statement to the <strong>module-info.java</strong> file.</p><p><a href="https://blog.jetbrains.com/idea/2018/03/advanced-support-for-java-9-modules-in-intellij-idea-2018-1/" target="_blank" rel="noopener">learn more</a></p><h2 id="Creating-missing-class"><a href="#Creating-missing-class" class="headerlink" title="Creating missing class"></a>Creating missing class</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Java9CreateMissingClass.gif" alt=""><br>For an unresolved class mentioned in <strong>module-info.java</strong>, the IDE will suggest creating the missing class, and create missing exported packages as well. Note the IDE creates the package with the class in the required directory, as you can’t export an empty package in <strong>Java 9</strong>.</p><h2 id="Idempotent-body-detection"><a href="#Idempotent-body-detection" class="headerlink" title="Idempotent body detection"></a>Idempotent body detection</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaIdempotentBodyDetection.png" alt=""><br>The IDE will detect and warn you about the while-loops with an idempotent body, as in most cases this indicates a programming error and can lead to a program hang.</p><h2 id="Move-break-condition-of-infinite-loop-to-loop-condition"><a href="#Move-break-condition-of-infinite-loop-to-loop-condition" class="headerlink" title="Move break-condition of infinite loop to loop condition"></a>Move break-condition of infinite loop to loop condition</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaLoopTransformation.gif" alt=""><br>For while-loops, now you get a notification about a conditional break at the end or beginning of an infinite loop. The IDE will suggest moving a break condition to a loop condition and offer a quick-fix to modify your loop. Usually replacing a conditional break with a loop condition makes the code clearer.</p><h2 id="Explicitly-redundant-close-call"><a href="#Explicitly-redundant-close-call" class="headerlink" title="Explicitly redundant close() call"></a>Explicitly redundant close() call</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaRedundantClose.gif" alt=""><br>IntelliJ IDEA now detects an explicitly redundant close() call of the resource at the end of a try-with-resources block.</p><h2 id="Infinite-Stream-detection"><a href="#Infinite-Stream-detection" class="headerlink" title="Infinite Stream detection"></a>Infinite Stream detection</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaInfiniteStream.png" alt=""><br>IntelliJ IDEA will warn you about any infinite streams that weren’t short-circuited, as such operations can be completed only by throwing an exception. Such code may result in an infinite loop or a running out of memory issue.</p><h2 id="Copy-constructor-with-missing-fields-detection"><a href="#Copy-constructor-with-missing-fields-detection" class="headerlink" title="Copy constructor with missing fields detection"></a>Copy constructor with missing fields detection</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaCopyConstructor.png" alt=""><br>In IntelliJ IDEA 2018.1 you’ll get a notification if there is a copy constructor that doesn’t copy all the fields in a class. The IDE considers fields with a transient modifier unnecessary to copy.</p><h2 id="Sort-array-content"><a href="#Sort-array-content" class="headerlink" title="Sort array content"></a>Sort array content</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaSortContent.gif" alt=""><br>A new Sort content action is available in array initializers and varargs. This new action sorts content alphabetically.</p><h2 id="User-Postfix-Completion-template"><a href="#User-Postfix-Completion-template" class="headerlink" title="User Postfix Completion template"></a>User Postfix Completion template</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaPostfixCompletion.gif" alt=""><br>The <strong>postfix code completion</strong> has been improved. The IDE now lets you create your own Java templates or edit and rename some of the predefined Java templates through <strong>Preferences | Editor | General | Postfix Completion</strong>.</p><h2 id="Fix-partially-in-Inspection-Results"><a href="#Fix-partially-in-Inspection-Results" class="headerlink" title="Fix partially in Inspection Results"></a>Fix partially in Inspection Results</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaFixPartially.png" alt=""><br>A new <strong>Fix partially</strong> button has been added to the right-hand pane of the <strong>Inspection Results Tool</strong> Window. It appears when you have several options for fixing possible problems in the chosen scope. All the suggested quick-fixes are grouped by the quick-fix type under the <strong>Fix partially</strong> button. This new feature allows you to apply the required quick-fix to the chosen scope, and fix all affected cases in one go.</p><h2 id="Test-prefix-in-Code-Generation"><a href="#Test-prefix-in-Code-Generation" class="headerlink" title="Test prefix in Code Generation"></a>Test prefix in Code Generation</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaTestPrefix.png" alt=""><br>In IntelliJ IDEA you can generate a test class using the intention action. With IntelliJ IDEA 2018.1, you can customize a test class template and create a test class with <strong>Test</strong> as a prefix. Go to <strong>Preferences | Editor | Code Style | Java | Code Generation</strong>, and choose how the test class name should be generated. By default, the IDE creates a test class with the <strong>Test</strong> as a suffix.</p><h2 id="JUnit-5-Tag-annotation-support"><a href="#JUnit-5-Tag-annotation-support" class="headerlink" title="JUnit 5 @Tag annotation support"></a>JUnit 5 @Tag annotation support</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaJUnit5.png" alt=""><br>IntelliJ IDEA 2018.1 now supports the <strong>JUnit5 @Tag</strong> annotation so now you can include tagged classes and tagged methods, in the testing scope. Select the Tags (JUnit 5) option in the test kind field in the Run/Debug Configuration dialog. Use the <strong>Uniqueld</strong> field to filter tests according to their id.</p><h1 id="JVM-Debugger"><a href="#JVM-Debugger" class="headerlink" title="JVM Debugger"></a>JVM Debugger</h1><h2 id="Throw-Exception"><a href="#Throw-Exception" class="headerlink" title="Throw Exception"></a>Throw Exception</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DebuggerRaiseException.gif" alt=""><br>IntelliJ IDEA 2018.1 has a new <strong>Throw Exception</strong> action that allows you to throw an exception from a certain location in your program without changing the code. It is available from the <strong>Run | Throw Exception</strong> menu, or from the frame context menu during a debugging session.</p><h2 id="Logging-stacktrace-to-console"><a href="#Logging-stacktrace-to-console" class="headerlink" title="Logging stacktrace to console"></a>Logging stacktrace to console</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DebuggerLogConsole.gif" alt=""><br>The IDE now allows you to print breakpoints stack traces to the console. You can enable the stack trace option in the <strong>Breakpoints</strong> dialog box. In IntelliJ IDEA, you can now observe multiple breakpoints stack traces at the same time in the <strong>Console</strong> log.</p><h2 id="Copy-current-thread-stacktrace"><a href="#Copy-current-thread-stacktrace" class="headerlink" title="Copy current thread stacktrace"></a>Copy current thread stacktrace</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DebuggerCopyStack.png" alt=""><br>You can now copy the current thread stack trace via a new <strong>Copy Stack</strong> action which is available from the frame context menu.</p><h2 id="Annotations-for-Async-stack-traces"><a href="#Annotations-for-Async-stack-traces" class="headerlink" title="Annotations for Async stack traces"></a>Annotations for Async stack traces</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DebuggerAnnotations1.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DebuggerAnnotations2.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DebuggerAnnotations3.png" alt=""><br>With IntelliJ IDEA 2018.1 we’ve extended the Async stack traces feature so that you can now use the <a href="mailto:**@Async.Schedule" target="_blank" rel="noopener">**@Async.Schedule</a><strong> and </strong>@Async.Execute** annotations to set up capture points that are not included in the default configuration. You just need to add <a href="https://mvnrepository.com/artifact/org.jetbrains/annotations/16.0.1" target="_blank" rel="noopener">Maven artifact</a>  as a dependency.</p><h1 id="Java-Compiler"><a href="#Java-Compiler" class="headerlink" title="Java Compiler"></a>Java Compiler</h1><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaCompiler.png" alt=""><br>There is a new <strong>Use –release option for cross-compilation (Java 9 and later)</strong> checkbox on the <strong>Java Compiler</strong> page at <strong>Preferences | Build, Execution, Deployment | Compiler | Java Compiler</strong> that is enabled by default. When you need to use the <strong>–source</strong> and <strong>–target</strong> options with Java 9 and link against Java 9 classes at the same time, you can disable this checkbox.</p><p>You can also use a specific version of the <strong>ECJ compiler</strong>. Select Eclipse from the <strong>Use Compiler</strong> drop-down menu, and specify the path to jar with the chosen compiler.</p><h1 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h1><h2 id="Folded-code-highlighting"><a href="#Folded-code-highlighting" class="headerlink" title="Folded code highlighting"></a>Folded code highlighting</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/EditorHighlightsFoldedCode.gif" alt=""><br>If any issues have been detected in your code, now you can find them quicker than before. The IDE now highlights the folded code regions that contain errors or warnings, and colors such blocks according to their validation status.</p><h2 id="Highlights-the-folded-code-regions-with-the-search-results"><a href="#Highlights-the-folded-code-regions-with-the-search-results" class="headerlink" title="Highlights the folded code regions with the search results"></a>Highlights the folded code regions with the search results</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/EditorHighlightsSearch.gif" alt=""><br>The IDE also highlights folded code regions if they contain any matches when you search through the current file.</p><h2 id="Inline-external-annotations"><a href="#Inline-external-annotations" class="headerlink" title="Inline external annotations"></a>Inline external annotations</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/EditorExternalAnnotation.png" alt=""><br>In IntelliJ IDEA you can annotate your code with external annotations even when direct annotation of the source code is not possible (library classes). You can configure your annotations in the <strong>annotations.xml</strong> files, which are stored outside of your source code. Previously the IDE only showed the @ icon in the gutter near the externally annotated code; now the IDE shows these external annotations inline in your code.</p><h2 id="Inferred-Annotation-Hints"><a href="#Inferred-Annotation-Hints" class="headerlink" title="Inferred Annotation Hints"></a>Inferred Annotation Hints</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/EditorInferredAnnotation.png" alt=""><br>IntelliJ IDEA now lets you view the automatic inferences of <strong>@NotNull</strong> or <strong>@Nullable</strong> annotations right in your source code (not only in the gutter icon near the inferred annotation, as it was before). You can enable the <strong>Show inferred annotations inline</strong> checkbox in the <strong>Preferences | Editor | General | Appearance</strong>.</p><h1 id="Project-Configuration"><a href="#Project-Configuration" class="headerlink" title="Project Configuration"></a>Project Configuration</h1><h2 id="Add-“provided”-dependencies-to-classpath"><a href="#Add-“provided”-dependencies-to-classpath" class="headerlink" title="Add “provided” dependencies to classpath"></a>Add “provided” dependencies to classpath</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/ProjectConfiguration.png" alt=""><br>A new <strong>Include dependencies with “Provided” scope</strong> checkbox has been added in the <strong>Run/Debug Configurations</strong> for the <strong>Application</strong> and <strong>Spring Boot</strong> configurations. This new option will be useful if you have the <strong>provided</strong> dependencies for the scope in your project, but you run your application both inside a container (where <strong>provided</strong> dependencies are supplied by the container) and outside a container (where <strong>provided</strong> dependencies are not automatically supplied).</p><p>For the <strong>Spring Boot</strong> applications, the <strong>Include dependencies with “Provided” scope</strong> option is enabled by default.</p><h2 id="New-Change-Module-Names…-action"><a href="#New-Change-Module-Names…-action" class="headerlink" title="New Change Module Names… action"></a>New Change Module Names… action</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/ProjectConfigurationRename.png" alt=""><br>With IntelliJ IDEA, you can now change qualified names for multiple modules all at once. This is done via the new <strong>Change Module Names…</strong> action, from the context menu of the <strong>Project Structure</strong> dialog.</p><h1 id="Search-and-Replace"><a href="#Search-and-Replace" class="headerlink" title="Search and Replace"></a>Search and Replace</h1><h2 id="Structural-Search-enhancement"><a href="#Structural-Search-enhancement" class="headerlink" title="Structural Search enhancement"></a>Structural Search enhancement</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/StructuralSearch1.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/StructuralSearch2.png" alt=""><br>With IntelliJ IDEA 2018.1, you can find method calls to annotated methods using <strong>Structural Search</strong>. You can select them from the existing search templates or create your own.</p><h2 id="Replace-in-Path-improvements"><a href="#Replace-in-Path-improvements" class="headerlink" title="Replace in Path improvements"></a>Replace in Path improvements</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Replace.png" alt=""><br>IntelliJ IDEA 2018.1 has the ability to preview a regex replacement in the <strong>Replace in Path</strong> dialog.</p><h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><p>The Kotlin plugin bundled with the IDE has been updated to <a href="https://blog.jetbrains.com/kotlin/2018/03/kotlin-1-2-30-is-out/" target="_blank" rel="noopener">Kotlin 1.2.30</a></p><h2 id="Pasting-Kotlin-code-into-a-package"><a href="#Pasting-Kotlin-code-into-a-package" class="headerlink" title="Pasting Kotlin code into a package"></a>Pasting Kotlin code into a package</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Kotlin1.gif" alt=""><br>Now, in the <strong>Project Tool Window</strong>, you can paste a code fragment directly into a package, and the IDE will create a new Kotlin file with the pasted code.</p><h2 id="Intentions-for-converting-the-scoping-function-calls"><a href="#Intentions-for-converting-the-scoping-function-calls" class="headerlink" title="Intentions for converting the scoping function calls"></a>Intentions for converting the scoping function calls</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Kotlin2.gif" alt=""><br>The Kotlin Plugin now offers new intentions that convert the scoping function calls <strong>let</strong> and <strong>run</strong> into each other, as well as <strong>also</strong> into <strong>apply</strong> and vice versa.</p><h1 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h1><h2 id="New-Convert-to-CompileStatic-refactoring-action"><a href="#New-Convert-to-CompileStatic-refactoring-action" class="headerlink" title="New Convert to @CompileStatic refactoring action"></a>New Convert to @CompileStatic refactoring action</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/GroovyConvert-1.gif" alt=""><br>Now you have a new action that’s very useful when you want to keep your code in Groovy and at the same time benefit from static compilation. To save you a lot of time migrating from existing Groovy code, this new refactoring annotates every groovy class in the scope with the <strong>@CompileStatic</strong> annotation.</p><p>This new refactoring action is available from the context menu <strong>Refactor | Convert to @CompileStatic</strong>.</p><p><a href="https://blog.jetbrains.com/idea/2018/03/whats-groovy-about-intellij-idea-2018-1/" target="_blank" rel="noopener">learn more</a></p><h2 id="Unnecessary-import-alias"><a href="#Unnecessary-import-alias" class="headerlink" title="Unnecessary import alias"></a>Unnecessary import alias</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/GroovyAliasInspection.gif" alt=""><br>IntelliJ IDEA 2018.1 reports unnecessary import alias for Groovy files. This new warning also works on static imports.</p><h1 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h1><h2 id="Inline-hints"><a href="#Inline-hints" class="headerlink" title="Inline hints"></a>Inline hints</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/ScalaInlineHints.png" alt=""><br>The editor can now show <strong>inline hints</strong> for parameter names, method result types, and variable types. You can also easily use the settings to customize when such a hint should be shown.</p><h2 id="Structure-View-improvement"><a href="#Structure-View-improvement" class="headerlink" title="Structure View improvement"></a>Structure View improvement</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/ScalaStructureView.png" alt=""><br>The <strong>Structure View</strong> now shows much more information about code. It displays final, abstract and access modifiers, nested definitions, primary constructor types, case class parameters as members, etc. The <strong>Structure View</strong> also provides you with an option to show all inherited members with their original class.</p><h2 id="Refactoring-Inline-function-parameters"><a href="#Refactoring-Inline-function-parameters" class="headerlink" title="Refactoring: Inline function parameters"></a>Refactoring: Inline function parameters</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Scala3-1.gif" alt=""><br>The refactoring is now capable of inlining functions with parameters. It correctly substitutes them with actual values.</p><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p>IntelliJ IDEA 2018.1 merges the changes from <a href="https://developer.android.com/studio/releases/index.html" target="_blank" rel="noopener">Android Studio 3.0</a> and includes dozens of new features, with the following major new ones</p><h2 id="Layout-Editor-improvements"><a href="#Layout-Editor-improvements" class="headerlink" title="Layout Editor improvements"></a>Layout Editor improvements</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Android1.png" alt=""><br>The <strong>Layout Editor</strong> has been improved: there is a new toolbar layout and icons, updated layouts in the component tree, a new error panel, and more.</p><p>For methods with <strong>@GetMapping</strong> annotations, you have a choice to open the mapped URLs in a browser, or open a request in the <strong>HTTP Request Editor</strong>.</p><h2 id="Brand-new-profiling-tools"><a href="#Brand-new-profiling-tools" class="headerlink" title="Brand new profiling tools"></a>Brand new profiling tools</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Android4.gif" alt=""><br>IntelliJ IDEA 2018.1 now includes Android Profiler, a brand new suite of profiling tools that provide real-time data for your app’s CPU, memory, and network activity.</p><h2 id="Device-File-Explorer-Tool-Window"><a href="#Device-File-Explorer-Tool-Window" class="headerlink" title="Device File Explorer Tool Window"></a>Device File Explorer Tool Window</h2><p>The new <strong>Device File Explorer Tool Window</strong> displays the file and directory structure of your Android device or emulator. Use this tool window to view, copy, and delete files on an Android device. You can access it through <strong>View | Tool Windows | Device File Explorer</strong>.</p><h2 id="Build-Instant-Apps"><a href="#Build-Instant-Apps" class="headerlink" title="Build Instant Apps"></a>Build Instant Apps</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/AndroidInstantApp1.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/AndroidInstantApp.png" alt=""><br>The IDE now supports the ability to build <strong>Instant Apps</strong> – lightweight Android apps that can be run without installation. To start building <strong>Instant Apps</strong>, make sure that the <strong>Instant Apps Development SDK</strong> is installed. You can check which <strong>SDK</strong> tools are installed in <strong>Preferences | Appearance &amp; Behavior | System Settings | Android SDK</strong> in the <strong>SDK</strong> tab.</p><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><h2 id="Access-HTTP-request-mappings-from-the-editor-via-the-new-REST-client"><a href="#Access-HTTP-request-mappings-from-the-editor-via-the-new-REST-client" class="headerlink" title="Access HTTP request mappings from the editor via the new REST client"></a>Access HTTP request mappings from the editor via the new REST client</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/SpringBootREST.gif" alt=""><br>Now, after you run a <strong>Spring Boot web application</strong>, a new icon is shown in the gutter for methods with <strong>@RequestMapping</strong> annotations that handle incoming <strong>HTTP requests</strong>. Click this gutter icon to open all the mappings in a scratch file with an .http extension and perform an <strong>HTTP request</strong> in the editor via the new <strong>REST client</strong>.</p><p>For methods with <strong>@GetMapping</strong> annotations, you have the choice to open the mapped URLs in a browser, or open a request in the <strong>HTTP Request Editor</strong>.</p><p>Note, that you need to add the dependency for the <strong>spring-boot-starter-actuator</strong> to your <strong>pom.xml</strong> or <strong>build.gradle</strong> file.</p><h2 id="New-gutter-icons-for-beans-registered-in-the-application-context"><a href="#New-gutter-icons-for-beans-registered-in-the-application-context" class="headerlink" title="New gutter icons for beans registered in the application context"></a>New gutter icons for beans registered in the application context</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/SpringBootBeans.png" alt=""><br>IntelliJ IDEA shows all the beans that are registered in the application context in the <strong>Beans</strong> tab in the <strong>Run Dashboard</strong> (or in the <strong>Run Tool Window</strong>). We’ve extended this functionality, and now this information is also available in the editor. The new gutter icons are shown next to the beans that are used at runtime.</p><p>Click these new gutter icons to navigate to the dependent beans.</p><h1 id="Version-Control"><a href="#Version-Control" class="headerlink" title="Version Control"></a>Version Control</h1><h2 id="Partial-Git-commits"><a href="#Partial-Git-commits" class="headerlink" title="Partial Git commits"></a>Partial Git commits</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSPartialCommit1.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSPartialCommits2.png" alt=""><br>IntelliJ IDEA 2018.1 supports <strong>partial Git commits</strong> (git add -p). The IDE lets you associate the code chunks with a changelist. Create a changelist, put all the needed code chunks there, and then commit it. The IDE will now only commit the selected changes from the file and will skip all other changes. To add the code chunks to a commit, use the checkboxes in the gutter in the <strong>Diff</strong> pane of the <strong>Commit Changes</strong> dialog.</p><p>To move the code chunks between changelists, use the <strong>Move to Another Changelist…</strong> action from the context menu of the <strong>Diff</strong> pane in the <strong>Commit Changes</strong> dialog.</p><p>Alternatively, add code chunks to a changelist from the editor by clicking on a change marker in the gutter.</p><h2 id="Toggle-grouping-of-local-changes-by-directory-module-or-repository"><a href="#Toggle-grouping-of-local-changes-by-directory-module-or-repository" class="headerlink" title="Toggle grouping of local changes by directory, module, or repository"></a>Toggle grouping of local changes by directory, module, or repository</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSGroupBy.png" alt=""><br>With IntelliJ IDEA 2018.1, you can choose how to display your local changes by grouping them according to their directory, module, or repository. Use the new <strong>Group by</strong> icon available in the <strong>Local Changes</strong> tab in the <strong>Version Control Tool Window</strong>. Note that now you can select one of the grouping options or all three at once if needed.</p><h2 id="Navigate-by-clicking-on-the-commit-hash"><a href="#Navigate-by-clicking-on-the-commit-hash" class="headerlink" title="Navigate by clicking on the commit hash"></a>Navigate by clicking on the commit hash</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSLogTab.gif" alt=""><br>In the <strong>Log</strong> tab inside the commit detail panes, the IDE now highlights hashes of the commits you are referring to. By simply clicking commit hashes you can jump to that commit in the <strong>Log</strong> tab. This works for <strong>Git</strong> and <strong>Mercurial</strong>. Also, the <strong>Commit Details</strong> pane of the <strong>Log</strong> tab has been redesigned</p><h2 id="History-for-revision-tab-enhancement"><a href="#History-for-revision-tab-enhancement" class="headerlink" title="History for revision tab enhancement"></a>History for revision tab enhancement</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSHistoryForRevision.gif" alt=""><br>IntelliJ IDEA lets you view detailed information about file changes by invoking the <strong>Show History for a Revision</strong> action on a file in the <strong>Log</strong> tab (available for <strong>Git</strong> integration). In 2018.1, we’ve updated the <strong>History for revision</strong> tab so that now it works much faster. In addition to better performance, this tab has a refreshed UI resembling the <strong>Log</strong> tab.</p><h2 id="Clone-Repository"><a href="#Clone-Repository" class="headerlink" title="Clone Repository"></a>Clone Repository</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSCloneRepository.png" alt=""><br>Moreover, the <strong>Clone Repository</strong> dialogs for <strong>Git</strong> and <strong>GitHub</strong> have been merged into one.</p><p>Autocompletion for <strong>GitHub</strong> repositories also works in the new <strong>Clone Repository</strong> dialog. You just need to log in to your <strong>GitHub</strong> account by clicking <strong>Log in to GitHub</strong>.</p><h2 id="New-shortcut-for-the-Commit-and-Push…-action"><a href="#New-shortcut-for-the-Commit-and-Push…-action" class="headerlink" title="New shortcut for the Commit and Push… action"></a>New shortcut for the Commit and Push… action</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSShortCut-1.png" alt=""><br>The IDE has a new default shortcut to perform the <strong>Commit and Push…</strong> action from the <strong>Commit Changes</strong> dialog. Please use <strong>Alt + Cmd + K (on macOS)</strong> or <strong>Alt + Ctrl + K (on Windows and Linux)</strong>.</p><h2 id="Git-Branches-pop-up"><a href="#Git-Branches-pop-up" class="headerlink" title="Git Branches pop-up"></a>Git Branches pop-up</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSGitBranches.png" alt=""><br>The <strong>Abort Rebase</strong>, <strong>Continue Rebase</strong>, and <strong>Skip Commit</strong> actions are now available from the <strong>Git Branches</strong> pop-up if there is an ongoing rebase process.</p><h1 id="User-Interface"><a href="#User-Interface" class="headerlink" title="User Interface"></a>User Interface</h1><h2 id="New-documentation-UI"><a href="#New-documentation-UI" class="headerlink" title="New documentation UI"></a>New documentation UI</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DocumentationUI.png" alt=""><br>We’ve updated the Quick Documentation pop-up and made it clearer and more compact. Information about the method’s parameters, type, and return type is now available for Java, JavaScript, and TypeScript in the updated Quick Documentation pop-up</p><h1 id="Better-HiDPI-support"><a href="#Better-HiDPI-support" class="headerlink" title="Better HiDPI support"></a>Better HiDPI support</h1><p>When you run the IntelliJ IDEA 2018.1 on Windows 8.1 (or higher), the IDE starts in per-monitor DPI-aware mode, with implemented support for the fractional scale factors of the monitor. Previously only integral scale factors were supported in the IDE. To switch back to the default mode, you need to set-up the VM option <strong>-Dsun.java2d.uiScale.enabled = false</strong></p><h1 id="JavaScript-amp-TypeScript"><a href="#JavaScript-amp-TypeScript" class="headerlink" title="JavaScript &amp; TypeScript"></a>JavaScript &amp; TypeScript</h1><h2 id="TypeScript-improvements"><a href="#TypeScript-improvements" class="headerlink" title="TypeScript improvements"></a>TypeScript improvements</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/typescript-surround-with-the-type-alias.png" alt=""><br>IntelliJ IDEA now supports the latest <strong>TypeScript 2.7</strong> features, improves the <strong>Implement Members</strong> action, and adds the new <strong>Surround with type guard</strong> quick-fix for unresolved properties.</p><h2 id="Create-a-new-Vue-project"><a href="#Create-a-new-Vue-project" class="headerlink" title="Create a new Vue project"></a>Create a new Vue project</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VueCrop.png" alt=""><br>With the <a href="https://plugins.jetbrains.com/plugin/9442-vue-js" target="_blank" rel="noopener">Vue.js</a> plugin installed in IntelliJ IDEA, you can use Vue CLI, an official tool for scaffolding Vue apps, to create new Vue projects. To install Vue CLI, run <strong>npm install –g vue-cli</strong> in the terminal.</p><h2 id="Reformat-with-Prettier"><a href="#Reformat-with-Prettier" class="headerlink" title="Reformat with Prettier"></a>Reformat with Prettier</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/PrettierReformat.png" alt=""><br>IntelliJ IDEA supports <a href="https://prettier.io/" target="_blank" rel="noopener">Prettier</a>, an opinionated code formatter via <a href="https://plugins.jetbrains.com/plugin/10456-prettier" target="_blank" rel="noopener">Prettier</a> plugin. After you have the prettier package installed, the new <strong>Reformat with Prettier</strong> action will become available in IntelliJ IDEA. You can format the selected code, a file, or a whole directory using Prettier.</p><h1 id="Hunspell"><a href="#Hunspell" class="headerlink" title="Hunspell"></a>Hunspell</h1><h2 id="Hunspell-dictionary-support"><a href="#Hunspell-dictionary-support" class="headerlink" title="Hunspell dictionary support"></a>Hunspell dictionary support</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Hunspell.png" alt=""><br>The Hunspell plugin that provides Hunspell dictionary support is now compatible with IntelliJ IDEA. Compared to a plain list of words, Hunspell provides significantly faster and much more accurate misprint detection, with far fewer false positives.</p><p><a href="https://blog.jetbrains.com/phpstorm/2018/01/hunspell-dictionaries-support/" target="_blank" rel="noopener">learn more</a></p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="Enhancement-in-Docker-compose"><a href="#Enhancement-in-Docker-compose" class="headerlink" title="Enhancement in Docker compose"></a>Enhancement in Docker compose</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Docker1.png" alt=""><br>The <strong>Docker</strong> plugin now supports <strong>Multiple Docker Compose</strong> files and respects not only a <strong>docker-compose.yml</strong> but also an optional <strong>docker-compose.override.yml</strong> file. You can add <strong>docker-compose.override.yml</strong> as you would any other override file, right after the base configuration file.</p><h2 id="Docker-compose-services"><a href="#Docker-compose-services" class="headerlink" title="Docker compose services"></a>Docker compose services</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DockerCompose.png" alt=""><br>The <strong>Docker</strong> plugin allows you to choose the services to run just after choosing the configuration files in the <strong>Docker-compose</strong> run configuration.</p><p>The plugin shows all the existing <strong>Compose projects</strong>, not only the ones deployed via the <strong>Docker-Compose</strong> run configuration.</p><h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="Support-for-YAML-Kubernetes-resource-files"><a href="#Support-for-YAML-Kubernetes-resource-files" class="headerlink" title="Support for YAML Kubernetes resource files"></a>Support for YAML Kubernetes resource files</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesLiveTemplate.gif" alt=""><br>The brand new <strong>Kubernetes</strong> plugin supports the <strong>Kubernetes resource</strong> files from v1.5 up to the recently released v1.9. The new plugin will look for the presence of <strong>apiVersion</strong> and other fields of this kind in the files, and if these are present, it will consider such files as <strong>Kubernetes resource</strong> files.</p><p><a href="https://blog.jetbrains.com/idea/2018/03/intellij-idea-2018-1-kubernetes-support/" target="_blank" rel="noopener">learn more</a></p><h2 id="Completion-in-YAML-Kubernetes-resource-files"><a href="#Completion-in-YAML-Kubernetes-resource-files" class="headerlink" title="Completion in YAML Kubernetes resource files"></a>Completion in YAML Kubernetes resource files</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesCompletion.gif" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesSmartCompletion.gif" alt=""><br>To help you really quickly create the required <strong>YAML</strong> definition file for <strong>Kubernetes</strong>, start typing the required key and invoke <strong>Smart Completion</strong>. The new plugin will auto-complete all the required keys from all the levels below.</p><p>Code completion now works for <strong>YAML Kubernetes resource</strong> files. The <strong>Kubernetes</strong> plugin offers the correct values you can use within the resources.</p><h2 id="Kubernetes-Live-Template"><a href="#Kubernetes-Live-Template" class="headerlink" title="Kubernetes Live Template"></a>Kubernetes Live Template</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesLiveTemplate.gif" alt=""><br>The <strong>Kubernetes</strong> plugin has a built-in <strong>Live Template</strong> that allows you to quickly create the type of <strong>YAML Kubernetes resource</strong> file that you need. The new plugin now contains several predefined <strong>Kubernetes</strong> templates, and you can invoke the necessary <strong>Live Template</strong> by typing its abbreviation.</p><h2 id="Navigation-in-YAML-Kubernetes-files"><a href="#Navigation-in-YAML-Kubernetes-files" class="headerlink" title="Navigation in YAML Kubernetes files"></a>Navigation in YAML Kubernetes files</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesNavigation.gif" alt=""><br>Use gutter icons to quickly navigate between a label definition and a label selector.</p><p>Jump from a label selector to a label definition inside the editor if there is a direct match for a label, both for the key and for the value.</p><h2 id="Inspections-for-YAML-Kubernetes-files"><a href="#Inspections-for-YAML-Kubernetes-files" class="headerlink" title="Inspections for YAML Kubernetes files"></a>Inspections for YAML Kubernetes files</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesInspection1.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesInspection2.png" alt=""><br>The Kubernetes plugin will alert you whenever you select deprecated Kubernetes properties.</p><p>Also, you’ll get a warning for YAML files if you try to use properties that are not applicable for the specified elements with the applied apiVersion and kind of field.</p><h2 id="Quick-fixes-for-YAML-Kubernetes-files"><a href="#Quick-fixes-for-YAML-Kubernetes-files" class="headerlink" title="Quick-fixes for YAML Kubernetes files"></a>Quick-fixes for YAML Kubernetes files</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesQuickFix1.gif" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesQuickFix2.gif" alt=""><br>The plugin highlights elements with missing keys in YAML Kubernetes resource definition files and provides a quick-fix to add the required keys.</p><p>Also, you’ll get a warning about redundant keys. Use the provided quick-fix to remove redundant keys in YAML Kubernetes resource files.</p><p>The new plugin also detects non-editable keys in YAML Kubernetes resource files and highlights them in the editor. Note that there’s an easy way to remove all such read-only keys from the current YAML file – with a handy quick-fix.</p><h2 id="Support-for-JSON-Kubernetes-resource-files"><a href="#Support-for-JSON-Kubernetes-resource-files" class="headerlink" title="Support for JSON Kubernetes resource files"></a>Support for JSON Kubernetes resource files</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesJSONCodeCompletion.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesQuickDocumentation.png" alt=""><br>The new plugin provides some support for JSON Kubernetes resource files based on the JSON schema functionality.</p><p>Code completion and the Quick Documentation Popup are also available for JSON Kubernetes resource files.</p><h2 id="Inspections-for-JSON-Kubernetes-resource-files"><a href="#Inspections-for-JSON-Kubernetes-resource-files" class="headerlink" title="Inspections for JSON Kubernetes resource files"></a>Inspections for JSON Kubernetes resource files</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesJSONInspection1.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesJSONInspection2.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesJSONInspection3.png" alt=""><br>The new Kubernetes plugin validates the current keys according to the JSON schema and alerts you when incorrect properties or values are used.</p><p>Also, the plugin highlights elements with any missing required properties and then advises you about the appropriate properties that should be added.</p><p>Duplicated properties are also detected in JSON Kubernetes files.</p>]]></content>
    
    <summary type="html">
    
      IDEA 2018.1 更新内容 更新时间2018.1 Mar 27
    
    </summary>
    
      <category term="软件" scheme="http://localhost/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="IDE" scheme="http://localhost/tags/IDE/"/>
    
      <category term="IDEA" scheme="http://localhost/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>学习清单</title>
    <link href="http://localhost/2018/03/28/%E5%AD%A6%E4%B9%A0%E6%B8%85%E5%8D%95/"/>
    <id>http://localhost/2018/03/28/学习清单/</id>
    <published>2018-03-28T12:06:38.203Z</published>
    <updated>2018-03-28T12:09:19.415Z</updated>
    
    <content type="html"><![CDATA[<ol><li>JDK9</li><li>JDK10</li><li>Google AutoValue</li><li>Weex</li><li>Kotlin</li></ol>]]></content>
    
    <summary type="html">
    
      小米自己的学习清单
    
    </summary>
    
      <category term="学习" scheme="http://localhost/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://localhost/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JDK各个版本的新特性</title>
    <link href="http://localhost/2018/03/27/Java/JDK%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://localhost/2018/03/27/Java/JDK各个版本的新特性/</id>
    <published>2018-03-27T06:11:56.376Z</published>
    <updated>2018-03-31T08:59:57.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-5新特性："><a href="#JDK1-5新特性：" class="headerlink" title="JDK1.5新特性："></a>JDK1.5新特性：</h1><ol><li><p>自动装箱与拆箱：</p><blockquote><p><strong>自动装箱的过程</strong>：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中。</p><p><strong>自动拆箱的过程</strong>：每当需要一个值时，被装箱对象中的值就被自动地提取出来，没必要再去调用<code>intValue()</code>和<code>doubleValue()</code>方法。</p><p><strong>自动装箱</strong>，只需将该值赋给一个类型包装器引用，java会自动创建一个对象。</p><p><strong>自动拆箱</strong>，只需将该对象值赋给一个基本类型即可。</p><p>java——类的包装器</p><p>类型包装器有：<code>Double</code>,<code>Float</code>,<code>Long</code>,<code>Integer</code>,<code>Short</code>,<code>Character</code>和<code>Boolean</code></p></blockquote></li><li><p>枚举</p><blockquote><p>把集合里的对象元素一个一个提取出来。枚举类型使代码更具可读性，理解清晰，易于维护。枚举类型是强类型的，从而保证了系统安全性。而以类的静态字段实现的类似替代模型，不具有枚举的简单性和类型安全性。</p><p><strong>简单的用法</strong>：JavaEnum简单的用法一般用于代表一组常用常量，可用来代表一类相同类型的常量值。</p><p><strong>复杂用法</strong>：Java为枚举类型提供了一些内置的方法，同事枚举常量还可以有自己的方法。可以很方便的遍历枚举对象。</p></blockquote></li><li><p>静态导入</p><blockquote><p>通过使用 <code>import static</code>，就可以不用指定 <code>Constants</code> 类名而直接使用静态成员，包括静态方法。</p><p><code>import xxxx</code> 和 <code>import static xxxx</code>的区别是前者一般导入的是类文件如<code>import java.util.Scanner;</code>后者一般是导入静态的方法，<code>import static java.lang.System.out</code>。</p></blockquote></li><li><p>可变参数（Varargs）</p><blockquote><p>可变参数的简单语法格式为：<br><code>methodName([argumentList], dataType...argumentName);</code></p></blockquote></li><li><p>内省（Introspector）</p><blockquote><p>是 Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性<code>name</code>,那我们可以通过<code>getName,setName</code>来得到其值或者设置新 的值。通过<code>getName/setName</code>来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的<code>getter /setter</code>方法，通过这些API可以使你不需要了解这个规则（但你最好还是要搞清楚），这些API存放于包<code>java.beans</code>中。</p><p>一般的做法是通过类<code>Introspector</code>来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器 （PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来 调用这些方法。</p></blockquote></li><li><p>泛型(Generic)</p><blockquote><p>C++ 通过模板技术可以指定集合的元素类型，而Java在1.5之前一直没有相对应的功能。一个集合可以放任何类型的对象，相应地从集合里面拿对象的时候我们也 不得不对他们进行强制得类型转换。猛虎引入了泛型，它允许指定集合里元素的类型，这样你可以得到强类型在编译时刻进行类型检查的好处。</p></blockquote></li><li><p>For-Each循环</p><blockquote><p>For-Each循环得加入简化了集合的遍历。假设我们要遍历一个集合对其中的元素进行一些处理。</p></blockquote></li></ol><h1 id="JDK-1-6新特性（转）"><a href="#JDK-1-6新特性（转）" class="headerlink" title="JDK 1.6新特性（转）"></a>JDK 1.6新特性（转）</h1><p>有关JDK1.6的新特性reamerit的博客文章已经说的很详细了。</p><ol><li><p><code>Desktop</code>类和<code>SystemTray</code>类</p><blockquote><p>在JDK6中 ,AWT新增加了两个类:<code>Desktop</code>和<code>SystemTray</code>。</p><p>前者可以用来打开系统默认浏览器浏览指定的URL,打开系统默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件),用系统默认的打印机打印文档;</p><p>后者可以用来在系统托盘区创建一个托盘程序.</p></blockquote></li><li><p>使用JAXB2来实现对象与XML之间的映射</p><blockquote><p>JAXB是Java Architecture for XML Binding的缩写，可以将一个Java对象转变成为XML格式，反之亦然。</p><p>我们把对象与关系数据库之间的映射称为ORM, 其实也可以把对象与XML之间的映射称为OXM(Object XML Mapping). 原来JAXB是Java EE的一部分，在JDK6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。JDK6中自带的这个JAXB版本是2.0, 比起1.0(JSR 31)来，JAXB2(JSR 222)用JDK5的新特性Annotation来标识要作绑定的类和属性等，这就极大简化了开发的工作量。</p><p>实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外,JAXB2在底层是用StAX(JSR 173)来处理XML文档。除了JAXB之外，我们还可以通过XMLBeans和Castor等来实现同样的功能。</p></blockquote></li><li><p>理解StAX</p><blockquote><p>StAX(JSR 173)是JDK6.0中除了DOM和SAX之外的又一种处理XML文档的API。</p><p>StAX 的来历 ：在JAXP1.3(JSR 206)有两种处理XML文档的方法:DOM(Document Object Model)和SAX(Simple API for XML).</p><p>由于JDK6.0中的JAXB2(JSR 222)和JAX-WS 2.0(JSR 224)都会用到StAX所以Sun决定把StAX加入到JAXP家族当中来，并将JAXP的版本升级到1.4(JAXP1.4是JAXP1.3的维护版 本). JDK6里面JAXP的版本就是1.4. 。</p><p>StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件 然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；</p><p>SAX也是基于事件处理xml文档，但却 是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。</p></blockquote></li><li><p>使用Compiler API</p><blockquote><p>现在我 们可以用JDK6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。</p><p>这个特性对于某些需要用到动态编译的应用程序相当有用， 比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件，当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去 做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译,而且是跨平台的。</p></blockquote></li><li><p>轻量级Http Server API</p><blockquote><p>JDK6 提供了一个简单的Http Server API,据此我们可以构建自己的嵌入式Http Server,它支持Http和Https协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现,程序员必须自己实现<code>HttpHandler</code>接口,HttpServer会调用<code>HttpHandler</code>实现类的回调方法来处理客户端请求,在 这里,我们把一个Http请求和它的响应称为一个交换,包装成<code>HttpExchange</code>类,HttpServer负责将<code>HttpExchange</code>传给 <code>HttpHandler</code>实现类的回调方法.</p></blockquote></li><li><p>插入式注解处理API(Pluggable Annotation Processing API)</p><blockquote><p>插入式注解处理API(JSR 269)提供一套标准API来处理Annotations(JSR 175)</p><p>实 际上JSR 269不仅仅用来处理Annotation,我觉得更强大的功能是它建立了Java 语言本身的一个模型,它把method, package, constructor, type, variable, enum, annotation等Java语言元素映射为Types和Elements(两者有什么区别?), 从而将Java语言的语义映射成为对象, 我们可以在javax.lang.model包下面可以看到这些类. 所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境.</p><p>JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器的一个插件,所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码,编译器会再调用一次Annotation Processor,如果第二次处理还有新代码产生,就会接着调用Annotation Processor,直到没有新代码产生为止.每执行一次process()方法被称为一个”round”,这样整个Annotation processing过程可以看作是一个round的序列.</p><p>JSR 269主要被设计成为针对Tools或者容器的API. 举个例子,我们想建立一套基于Annotation的单元测试框架(如TestNG),在测试类里面用Annotation来标识测试期间需要执行的测试方法。</p></blockquote></li><li><p>用Console开发控制台程序</p><blockquote><p>JDK6 中提供了java.io.Console 类专用来访问基于字符的控制台设备. 你的程序如果要与Windows下的cmd或者Linux下的Terminal交互,就可以用Console类代劳. 但我们不总是能得到可用的Console, 一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用. 如果JVM是在交互式命令行(比如Windows的cmd)中启动的,并且输入输出没有重定向到另外的地方,那么就可以得到一个可用的Console实 例.</p></blockquote></li><li><p>对脚本语言的支持如: ruby, groovy, javascript.</p></li><li><p>Common Annotations</p></li></ol><p>Common annotations原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中.<br>随 着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB,Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务）, 如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性.</p><p>下面列举出Common Annotations 1.0里面的10个Annotations Common Annotations<br>Annotation Retention Target Description<br>Generated Source <code>ANNOTATION_TYPE</code>, <code>CONSTRUCTOR</code>, <code>FIELD</code>, <code>LOCAL_VARIABLE</code>, <code>METHOD</code>, <code>PACKAGE</code>, <code>PARAMETER</code>, <code>TYPE</code> 用于标注生成的源代码<br>Resource Runtime <code>TYPE</code>, <code>METHOD</code>, <code>FIELD</code> 用于标注所依赖的资源,容器据此注入外部资源依赖，有基于字段的注入和基于setter方法的注入两种方式<br>Resources Runtime TYPE 同时标注多个外部依赖，容器会把所有这些外部依赖注入<br>PostConstruct Runtime METHOD 标注当容器注入所有依赖之后运行的方法，用来进行依赖注入后的初始化工作，只有一个方法可以标注为PostConstruct<br>PreDestroy Runtime METHOD 当对象实例将要被从容器当中删掉之前，要执行的回调方法要标注为PreDestroy RunAs Runtime TYPE 用于标注用什么安全角色来执行被标注类的方法，这个安全角色必须和Container 的Security角色一致的。RolesAllowed Runtime TYPE, METHOD 用于标注允许执行被标注类或方法的安全角色，这个安全角色必须和Container 的Security角色一致的<br>PermitAll Runtime TYPE, METHOD 允许所有角色执行被标注的类或方法<br>DenyAll Runtime TYPE, METHOD 不允许任何角色执行被标注的类或方法，表明该类或方法不能在Java EE容器里面运行<br>DeclareRoles Runtime TYPE 用来定义可以被应用程序检验的安全角色，通常用isUserInRole来检验安全角色</p><p>注意:</p><ol><li><p>RolesAllowed,PermitAll,DenyAll不能同时应用到一个类或方法上</p></li><li><p>标注在方法上的RolesAllowed,PermitAll,DenyAll会覆盖标注在类上的RolesAllowed,PermitAll,DenyAll</p></li><li><p>RunAs,RolesAllowed,PermitAll,DenyAll和DeclareRoles还没有加到Java SE 6.0上来</p></li><li><p>处理以上Annotations的工作是由Java EE容器来做, Java SE 6.0只是包含了上面表格的前五种Annotations的定义类,并没有包含处理这些Annotations的引擎,这个工作可以由Pluggable Annotation Processing API(JSR 269)来做</p></li></ol><p>改动的地方最大的就是java GUI界面的显示了，JDK6.0（也就是JDK1.6）支持最新的windows vista系统的Windows Aero视窗效果，而JDK1.5不支持！！！<br>你要在vista环境下编程的话最好装jdk6.0，否则它总是换到windows basic视窗效果.</p><h1 id="JDK-1-7-新特性-（转）"><a href="#JDK-1-7-新特性-（转）" class="headerlink" title="JDK 1.7 新特性 （转）"></a>JDK 1.7 新特性 （转）</h1><ol><li><p>switch中可以使用字串了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"test"</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"test"</span> :</span><br><span class="line">        System.out.println(<span class="string">"test"</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"test1"</span> :</span><br><span class="line">        System.out.println(<span class="string">"test1"</span>);</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        System.out.println(<span class="string">"break"</span>);</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>“<code>&lt;&gt;</code>“这个玩意儿的运用<code>List tempList = new ArrayList&lt;&gt;();</code> 即泛型实例化类型自动推断。 </p></li><li><p>语法上支持集合，而不一定是数组 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List piDigits = [ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span> ];</span><br></pre></td></tr></table></figure></li><li><p>新增一些取环境信息的工具方法 </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File System.getJavaIoTempDir() <span class="comment">// IO临时文件夹 </span></span><br><span class="line"></span><br><span class="line">File System.getJavaHomeDir() <span class="comment">// JRE的安装目录 </span></span><br><span class="line"></span><br><span class="line">File System.getUserHomeDir() <span class="comment">// 当前用户目录 </span></span><br><span class="line"></span><br><span class="line">File System.getUserDir() <span class="comment">// 启动java进程时所在的目录 </span></span><br><span class="line"></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><ol><li><p>Boolean类型反转，空指针安全,参与位运算 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Boolean Booleans.negate(Boolean booleanObj) </span><br><span class="line"></span><br><span class="line">True =&gt; False , False =&gt; True, Null =&gt; Null </span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> Booleans.and(<span class="keyword">boolean</span>[] array) </span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> Booleans.or(<span class="keyword">boolean</span>[] array) </span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> Booleans.xor(<span class="keyword">boolean</span>[] array) </span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> Booleans.and(Boolean[] array) </span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> Booleans.or(Boolean[] array) </span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> Booleans.xor(Boolean[] array)</span><br></pre></td></tr></table></figure></li><li><p>两个char间的equals </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> Character.equalsIgnoreCase(<span class="keyword">char</span> ch1, <span class="keyword">char</span> ch2)</span><br></pre></td></tr></table></figure></li></ol><p>7，安全的加减乘除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Math.safeToInt(<span class="keyword">long</span> value) </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Math.safeNegate(<span class="keyword">int</span> value) </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> Math.safeSubtract(<span class="keyword">long</span> value1, <span class="keyword">int</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> Math.safeSubtract(<span class="keyword">long</span> value1, <span class="keyword">long</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Math.safeMultiply(<span class="keyword">int</span> value1, <span class="keyword">int</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> Math.safeMultiply(<span class="keyword">long</span> value1, <span class="keyword">int</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> Math.safeMultiply(<span class="keyword">long</span> value1, <span class="keyword">long</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> Math.safeNegate(<span class="keyword">long</span> value) </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Math.safeAdd(<span class="keyword">int</span> value1, <span class="keyword">int</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> Math.safeAdd(<span class="keyword">long</span> value1, <span class="keyword">int</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> Math.safeAdd(<span class="keyword">long</span> value1, <span class="keyword">long</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Math.safeSubtract(<span class="keyword">int</span> value1, <span class="keyword">int</span> value2)</span><br></pre></td></tr></table></figure></p><p>1.对Java集合（Collections）的增强支持<br>在JDK1.7之前的版本中，Java集合容器中存取元素的形式如下：<br>以List、Set、Map集合容器为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建List接口对象</span></span><br><span class="line">List list=<span class="keyword">new</span> ArrayList (); </span><br><span class="line">list.add(<span class="string">"item"</span>); <span class="comment">//用add()方法获取对象 </span></span><br><span class="line">String Item=list.get(<span class="number">0</span>); <span class="comment">//用get()方法获取对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Set接口对象</span></span><br><span class="line">Set set=<span class="keyword">new</span> HashSet (); </span><br><span class="line">set.add(<span class="string">"item"</span>); <span class="comment">//用add()方法添加对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Map接口对象</span></span><br><span class="line">Map map=<span class="keyword">new</span> HashMap (); </span><br><span class="line">map.put(<span class="string">"key"</span>,<span class="number">1</span>); <span class="comment">//用put()方法添加对象 </span></span><br><span class="line"><span class="keyword">int</span> value=map.get(<span class="string">"key"</span>);</span><br></pre></td></tr></table></figure></p><p>在JDK1.7中，摒弃了Java集合接口的实现类，如：<code>ArrayList</code>、<code>HashSet</code>和<code>HashMap</code>。而是直接采用[]、{}的形式存入对象，采用[]的形式按照索引、键值来获取集合中的对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List list=[<span class="string">"item"</span>]; <span class="comment">//向List集合中添加元素 </span></span><br><span class="line">String item=list[<span class="number">0</span>]; <span class="comment">//从List集合中获取元素</span></span><br><span class="line">Set set=&#123;<span class="string">"item"</span>&#125;; <span class="comment">//向Set集合对象中添加元素</span></span><br><span class="line">Map map=&#123;<span class="string">"key"</span>:<span class="number">1</span>&#125;; <span class="comment">//向Map集合中添加对象 </span></span><br><span class="line"><span class="keyword">int</span> value=map[<span class="string">"key"</span>]; <span class="comment">//从Map集合中获取对象</span></span><br></pre></td></tr></table></figure><p>2.在Switch中可用String<br>在之前的版本中是不支持在Switch语句块中用String类型的数据的，这个功能在C#语言中早已被支持，好在JDK1.7中加入了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"test"</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"test"</span> :</span><br><span class="line">        System.out.println(<span class="string">"test"</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"test1"</span> :</span><br><span class="line">        System.out.println(<span class="string">"test1"</span>);</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        System.out.println(<span class="string">"break"</span>);</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p>数值可加下划线<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> one_million = <span class="number">1_000_000</span>;</span><br></pre></td></tr></table></figure></li><li><p>支持二进制文字<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> binary = <span class="number">0b1001_1001</span>;</span><br></pre></td></tr></table></figure></li><li><p>简化了可变参数方法的调用<br>当程序员试图使用一个不可具体化的可变参数并调用一个varargs（可变）方法时，编辑器会生成一个“非安全操作”的警告。<br>原文：<a href="http://iteye.blog.163.com/blog/static/18630809620127136516641/?suggestedreading&amp;wumii" target="_blank" rel="noopener">http://iteye.blog.163.com/blog/static/18630809620127136516641/?suggestedreading&amp;wumii</a></p></li></ol><h1 id="Java8-十大新特性"><a href="#Java8-十大新特性" class="headerlink" title="Java8 十大新特性"></a>Java8 十大新特性</h1><p>本教程将Java8的新特新逐一列出，并将使用简单的代码示例来指导你如何使用默认接口方法，<strong>lambda</strong>表达式，方法引用以及多重Annotation，之后你将会学到最新的API上的改进，比如流，函数式接口，Map以及全新的日期API</p><p>“Java is still not dead—and people are starting to figure that out.”<br>本教程将用带注释的简单代码来描述新特性，你将看不到大片吓人的文字。</p><p>一、接口的默认方法<br>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下：<br> 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。<br>代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">formula.calculate(<span class="number">100</span>); <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);  <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure></p><p>文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。<br>译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。<br>二、Lambda 表达式<br>首先看看在老版本的Java中是如何排列字符串的：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator () &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。<br>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123; </span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure></p><p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure></p><p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来： </p><p>三、函数式接口<br>Lambda 表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。<br>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。<br>示例如下：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span> </span>&#123; </span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>; </span><br><span class="line">&#125; </span><br><span class="line">Converter converter = (from) -&gt; Integer.valueOf(from); </span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>); </span><br><span class="line">System.out.println(converted); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></p><p>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。<br>译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。<br>四、方法与构造函数引用<br>前一节中的代码还可以通过静态方法引用来表示：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter converter = Integer::valueOf; </span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>); </span><br><span class="line">System.out.println(converted); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></p><p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">converter = something::startsWith; </span><br><span class="line">String converted = converter.convert(<span class="string">"Java"</span>); </span><br><span class="line">System.out.println(converted); <span class="comment">// "J"</span></span><br></pre></td></tr></table></figure></p><p>接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    String firstName; </span><br><span class="line">    String lastName;</span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们指定一个用来创建Person对象的对象工厂接口：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PersonFactory personFactory = Person::<span class="keyword">new</span>; </span><br><span class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</span><br></pre></td></tr></table></figure></p><p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。<br>五、Lambda 作用域<br>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。<br>六、访问局部变量<br>我们可以直接在lambda表达式中访问外层的局部变量：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>; </span><br><span class="line">Converter stringConverter = (from) -&gt; String.valueOf(from + num);</span><br><span class="line">stringConverter.convert(<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>; </span><br><span class="line">Converter stringConverter = (from) -&gt; String.valueOf(from + num);</span><br><span class="line">stringConverter.convert(<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>; </span><br><span class="line">Converter stringConverter = (from) -&gt; String.valueOf(from + num); </span><br><span class="line">num = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><p>在lambda表达式中试图修改num同样是不允许的。<br>七、访问对象字段与静态变量<br>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum; </span><br><span class="line">    <span class="keyword">int</span> outerNum;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Converter stringConverter1 = (from) -&gt; &#123; </span><br><span class="line">            outerNum = <span class="number">23</span>; </span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from); </span><br><span class="line">        &#125;;</span><br><span class="line">        Converter stringConverter2 = (from) -&gt; &#123; </span><br><span class="line">            outerStaticNum = <span class="number">72</span>; </span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from); </span><br><span class="line">        &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>八、访问接口的默认方法<br>还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。<br>Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt( a * <span class="number">100</span>); </span><br><span class="line">Built-in Functional Interfaces</span><br></pre></td></tr></table></figure></p><p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。<br>Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。<br>Predicate接口<br>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Predicate predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line">predicate.test(<span class="string">"foo"</span>); <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">"foo"</span>); <span class="comment">// false</span></span><br><span class="line">Predicate nonNull = Objects::nonNull; </span><br><span class="line">Predicate isNull = Objects::isNull;</span><br><span class="line">Predicate isEmpty = String::isEmpty; </span><br><span class="line">Predicate isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure></p><p>Function 接口<br>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：<br>复制代码 代码如下:</p><p>Function toInteger = Integer::valueOf;<br>Function backToString = toInteger.andThen(String::valueOf);<br>backToString.apply(“123”);     // “123”</p><p>Supplier 接口<br>Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数<br>复制代码 代码如下:</p><p>Supplier personSupplier = Person::new;<br>personSupplier.get();   // new Person</p><p>Consumer 接口<br>Consumer 接口表示执行在单个参数上的操作。<br>复制代码 代码如下:</p><p>Consumer greeter = (p) -&gt; System.out.println(“Hello, “ + p.firstName);<br>greeter.accept(new Person(“Luke”, “Skywalker”));</p><p>Comparator 接口<br>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：<br>复制代码 代码如下:</p><p>Comparator comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);<br>Person p1 = new Person(“John”, “Doe”);<br>Person p2 = new Person(“Alice”, “Wonderland”);<br>comparator.compare(p1, p2);             // &gt; 0<br>comparator.reversed().compare(p1, p2);  // &lt; 0</p><p>Optional 接口<br>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：<br>Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。<br>复制代码 代码如下:</p><p>Optional optional = Optional.of(“bam”);<br>optional.isPresent();           // true<br>optional.get();                 // “bam”<br>optional.orElse(“fallback”);    // “bam”<br>optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // “b”</p><p>Stream 接口<br>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。 Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。<br>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">stringCollection.add(<span class="string">"ddd2"</span>); </span><br><span class="line">stringCollection.add(<span class="string">"aaa2"</span>); </span><br><span class="line">stringCollection.add(<span class="string">"bbb1"</span>); </span><br><span class="line">stringCollection.add(<span class="string">"aaa1"</span>); </span><br><span class="line">stringCollection.add(<span class="string">"bbb3"</span>); </span><br><span class="line">stringCollection.add(<span class="string">"ccc"</span>); </span><br><span class="line">stringCollection.add(<span class="string">"bbb2"</span>); </span><br><span class="line">stringCollection.add(<span class="string">"ddd1"</span>);</span><br></pre></td></tr></table></figure></p><p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：<br>Filter 过滤<br>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stringCollection.stream().filter((s) -&gt; s.startsWith(<span class="string">"a"</span>)).forEach(System.out::println); </span><br><span class="line"><span class="comment">// "aaa2", "aaa1"</span></span><br></pre></td></tr></table></figure></p><p>Sort 排序<br>排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stringCollection.stream().sorted().filter((s) -&gt; s.startsWith(<span class="string">"a"</span>)).forEach(System.out::println);</span><br><span class="line"><span class="comment">// "aaa1", "aaa2"</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(stringCollection); </span><br><span class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></span><br></pre></td></tr></table></figure></p><p>Map 映射<br>中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stringCollection.stream().map(String::toUpperCase).sorted((a, b) -&gt; b.compareTo(a)).forEach(System.out::println);</span><br><span class="line"><span class="comment">// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"</span></span><br></pre></td></tr></table></figure></p><p>Match 匹配<br>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> anyStartsWithA = stringCollection.stream().anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line">System.out.println(anyStartsWithA); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> allStartsWithA = stringCollection.stream().allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line">System.out.println(allStartsWithA); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> noneStartsWithZ = stringCollection.stream().noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</span><br><span class="line">System.out.println(noneStartsWithZ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>Count 计数<br>计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> startsWithB = stringCollection.stream().filter((s) -&gt; s.startsWith(<span class="string">"b"</span>)).count();</span><br><span class="line">System.out.println(startsWithB); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>Reduce 规约<br>这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional reduced = stringCollection.stream() .sorted().reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></span><br></pre></td></tr></table></figure></p><p>并行Streams<br>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。<br>下面的例子展示了是如何通过并行Stream来提升性能：<br>首先我们创建一个没有重复元素的大表：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">1000000</span>; </span><br><span class="line">List values = <span class="keyword">new</span> ArrayList&lt;&gt;(max); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123; </span><br><span class="line">    UUID uuid = UUID.randomUUID(); </span><br><span class="line">    values.add(uuid.toString()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们计算一下排序这个Stream要耗时多久，<br>串行排序：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"sequential sort took: %d ms"</span>, millis));</span><br><span class="line"><span class="comment">// 串行耗时: 899 ms</span></span><br></pre></td></tr></table></figure></p><p>并行排序：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"parallel sort took: %d ms"</span>, millis));</span><br><span class="line"><span class="comment">// 并行排序耗时: 472 ms</span></span><br></pre></td></tr></table></figure></p><p>上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。<br>Map<br>前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。<br>复制代码 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map map = new HashMap&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    map.putIfAbsent(i, &quot;val&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">map.forEach((id, val) -&gt; System.out.println(val));</span><br></pre></td></tr></table></figure></p><p>以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。<br>下面的例子展示了map上的其他有用的函数：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num); </span><br><span class="line">map.get(<span class="number">3</span>); <span class="comment">// val33</span></span><br><span class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</span><br><span class="line">map.containsKey(<span class="number">9</span>); <span class="comment">// false</span></span><br><span class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">"val"</span> + num);</span><br><span class="line">map.containsKey(<span class="number">23</span>); <span class="comment">// true</span></span><br><span class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">"bam"</span>);</span><br><span class="line">map.get(<span class="number">3</span>); <span class="comment">// val33</span></span><br></pre></td></tr></table></figure></p><p>接下来展示如何在Map里删除一个键值全都匹配的项：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.remove(<span class="number">3</span>, <span class="string">"val3"</span>); </span><br><span class="line">map.get(<span class="number">3</span>); <span class="comment">// val33</span></span><br><span class="line">map.remove(<span class="number">3</span>, <span class="string">"val33"</span>);</span><br><span class="line">map.get(<span class="number">3</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><p>另外一个有用的方法：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">"not found"</span>); <span class="comment">// not found</span></span><br></pre></td></tr></table></figure></p><p>对Map的元素做合并也变得很容易了：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.merge(<span class="number">9</span>, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue)); </span><br><span class="line">map.get(<span class="number">9</span>); <span class="comment">// val9</span></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>); <span class="comment">// val9concat</span></span><br></pre></td></tr></table></figure></p><p>Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。<br>九、Date API<br>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：<br>Clock 时钟<br>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone(); </span><br><span class="line"><span class="keyword">long</span> millis = clock.millis();</span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);<span class="comment">// legacy java.util.Date</span></span><br></pre></td></tr></table></figure></p><p>Timezones 时区<br>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ZoneId.getAvailableZoneIds()); </span><br><span class="line"><span class="comment">// prints all available timezone ids</span></span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></span><br></pre></td></tr></table></figure></p><p>LocalTime 本地时间<br>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1); </span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line">System.out.println(now1.isBefore(now2)); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line">System.out.println(hoursBetween); <span class="comment">// -3</span></span><br><span class="line">System.out.println(minutesBetween);  <span class="comment">// -239</span></span><br></pre></td></tr></table></figure></p><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>); </span><br><span class="line">System.out.println(late);  <span class="comment">// 23:59:59</span></span><br><span class="line">DateTimeFormatter germanFormatter = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).withLocale(Locale.GERMAN);</span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime); <span class="comment">// 13:37</span></span><br></pre></td></tr></table></figure></p><p>LocalDate 本地日期<br>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now(); </span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS); </span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</span><br><span class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek); <span class="comment">// FRIDAY</span></span><br></pre></td></tr></table></figure></p><p>从字符串解析一个LocalDate类型和解析LocalTime一样简单：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM).withLocale(Locale.GERMAN);</span><br><span class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</span><br><span class="line">System.out.println(xmas);  <span class="comment">// 2014-12-24</span></span><br></pre></td></tr></table></figure></p><p>LocalDateTime 本地日期时间<br>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);  <span class="comment">// WEDNESDAY</span></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month); <span class="comment">// DECEMBER</span></span><br><span class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay); <span class="comment">// 1439</span></span><br></pre></td></tr></table></figure></p><p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = sylvester.atZone(ZoneId.systemDefault()).toInstant();</span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);  <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br></pre></td></tr></table></figure></p><p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>);</span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);  <span class="comment">// Nov 03, 2014 - 07:13</span></span><br></pre></td></tr></table></figure></p><p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。<br>关于时间日期格式的详细信息：<a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener">http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html</a><br>十、Annotation 注解<br>在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。<br>首先定义一个包装类Hints注解用来放置一组具体的Hint注解：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Hints &#123; </span><br><span class="line">    Hint[] value(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repeatable</span>(Hints.class)</span><br><span class="line"><span class="meta">@interface</span> Hint &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。<br>例 1: 使用包装类当容器来存多个注解（老方法）<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hints</span>(&#123;<span class="meta">@Hint</span>(<span class="string">"hint1"</span>), <span class="meta">@Hint</span>(<span class="string">"hint2"</span>)&#125;) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>例 2：使用多重注解（新方法）<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint1"</span>) </span><br><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint2"</span>) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hint hint = Person.class.getAnnotation(Hint.class); </span><br><span class="line">System.out.println(hint); <span class="comment">// null</span></span><br><span class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</span><br><span class="line">System.out.println(hints1.value().length); <span class="comment">// 2</span></span><br><span class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</span><br><span class="line">System.out.println(hints2.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。<br>另外Java 8的注解还增加到两种新的target上了：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;) </span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      对于很多刚接触java语言的初学者来说，要了解一门语言，最好的方式就是要能从基础的版本进行了解，升级的过程，以及升级的新特性，这样才能循序渐进的学好一门语言。今天先为大家介绍一下 JDK5 版本到 JDK10 版本的特性。希望能给予帮助。
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JSP九大内置对象及四个作用域</title>
    <link href="http://localhost/2018/03/27/Java/JSP%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%9B%9B%E4%B8%AA%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://localhost/2018/03/27/Java/JSP九大内置对象及四个作用域/</id>
    <published>2018-03-27T05:26:47.373Z</published>
    <updated>2018-03-31T09:00:01.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="九大对象"><a href="#九大对象" class="headerlink" title="九大对象"></a>九大对象</h2><p>　　内置对象（又叫隐含对象，有9个内置对象）:不需要预先声明就可以在脚本代码和表达式中随意使用　　</p><ol><li><p>out:</p><blockquote><p>javax.servlet.jsp.JspWriter类型，代表输出流的对象。作用域为page（页面执行期）</p></blockquote></li><li><p>request：</p><blockquote><p>javax.servlet.ServletRequest的子类型，此对象封装了由WEB浏览器或其它客户端生成地HTTP请求的细节（参数，属性，头标和数据）。作用域为request(用户请求期）。方法由可查看API</p></blockquote></li><li><p>response：</p><blockquote><p>javax.servlet.ServletResponse的子类型，此对象封装了返回到HTTP客户端的输出，向页面作者提供设置响应头标和状态码的方式。经常用来设置HTTP标题，添加cookie，设置响应内容的类型和状态，发送HTTP重定向和编码URL。作用域为page（页面执行期）。</p></blockquote></li><li><p>pageContext：</p><blockquote><p>javax.servlet.jsp.PageContext（抽象类）类型，作用域为page（页面执行期）。此对象提供所有四个作用域层次的属性查询和修改能力，它也提供了转发请求到其它资源和包含其他资源的方法：<br>　　该对象的方法都是抽象方法</p></blockquote></li><li><p>session：javax.servlet.http.HttpSession类型，主要用于跟踪对话。作用域session(会话期—）。<br>　　HttpSession是一个类似哈希表的与单一WEB浏览器会话相关的对象，它存在于HTTP请求之间，可以存储任<br>　　何类型的命名对象。<br>　　如果不需要在请求之间跟踪会话对象，可以通过在page指令中指定session=”false”<br>　　需要记住的是pageContext对象也可以与session.getAttribute(),session.setAttribute()一样的方式取得并设置会话属性。</p></li><li>application：javax.servlet.ServletContext类型，servlet的环境通过调用getServletConfig<br>　　().getContext()方法获得。作用域是application(整个程序运行期）。它提供了关于服务器版本，应用级初始化参数和应用内资源绝对路径，注册信息的方式</li><li>config：javax.servlet.ServletConfig,作用域为page（页面执行期）</li><li>exception:java.lang.Throwable,通过JSP错误页面中一个catch块已经益出但没有捕获的<br>　　java.lang.Throwable的任意实例，传向了errorPage的URI。作用域为page（页面执行期）。注意<br>　　exception只有在page指令中具有属性isErrorPage=”true”时才有效。</li><li>page:java.lang.Object类型，指向页面自身的方式。作用域为page（页面执行期）</li></ol><p>JSP中九大内置对象为：</p><table><thead><tr><th>名称</th><th>中文</th><th>类型</th><th>作用域</th></tr></thead><tbody><tr><td>request</td><td>请求对象</td><td>javax.servlet.ServletRequest</td><td>Request</td></tr><tr><td>response</td><td>响应对象</td><td>javax.servlet.SrvletResponse</td><td>Page</td></tr><tr><td>pageContext</td><td>页面上下文对象</td><td>javax.servlet.jsp.PageContext</td><td>Page</td></tr><tr><td>session</td><td>会话对象</td><td>javax.servlet.http.HttpSession</td><td>Session</td></tr><tr><td>application</td><td>应用程序对象</td><td>javax.servlet.ServletContext</td><td>Application</td></tr><tr><td>out</td><td>输出对象</td><td>javax.servlet.jsp.JspWriter</td><td>Page</td></tr><tr><td>config</td><td>配置对象</td><td>javax.servlet.ServletConfig</td><td>Page</td></tr><tr><td>page</td><td>页面对象</td><td>javax.lang.Object</td><td>Page</td></tr><tr><td>exception</td><td>例外对象</td><td>javax.lang.Throwable</td><td>page</td></tr></tbody></table><p>　　request 对象代表的是来自客户端的请求，例如我们在FORM表单中填写的信息等，是最常用的对象常用的方法有：getParameter、getParameterNames 和getParameterValues 通过调用这几个方法来获取请求对象中所包含的参数的值。<br>　　response 对象代表的是对客户端的响应，也就是说可以通过response 对象来组织发送到客户端的数据。但是由于组织方式比较底层，所以不建议普通读者使用，需要向客户端发送文字时直接使用<br>　　pageContext 对象直译时可以称作“页面上下文”对象，代表的是当前页面运行的一些属性<br>　　常用的方法有 ：findAttribute、getAttribute、getAttributesScope 和getAttributeNamesInScope<br>　　一般情况下pageContext对象用到得也不是很多，只有在项目所面临的情况比较复杂的情况下，才会利用到页面属性来辅助处理。<br>　　session    对象代表服务器与客户端所建立的会话，当需要在不同的JSP页面中保留客户信息的情况下使用，比如在线购物、客户轨迹跟踪等。“session” 对象建立在cookie的基础上，所以使用时应注意判断一下客户端是否打开了cookie。常用的方法包括getId、 getValue、 getValueNames和putValue等。<br>　　概要<br>　　HTTP是无状态（stateless）协议；<br>　　Web Server 对每一个客户端请求都没有历史记忆；<br>　　Session用来保存客户端状态信息；<br>　　由Web Server 写入；<br>　　存于客户端；<br>　　客户端的每次访问都把上次的session记录传递给Web Server；<br>　　Web Server读取客户端提交的session来获取客户端的状态信息<br>　　application 对象负责提供应用程序在服务器中运行时的一些全局信息，常用的方法有getMimeType和getRealPath等。<br>　　out 对象代表了向客户端发送数据的对象，与“response” 对象不同，通过“out” 对象发送的内容将是浏览器需要显示的内容，是文本一级的，可以通过“out” 对象直接向客户端写一个由程序动态生成HTML文件。常用的方法除了pirnt和println之外，还包括clear、clearBuffer、 flush、getBufferSize和getRemaining，这是因为“out” 对象内部包含了一个缓冲区，所以需要一些对缓冲区进行操作的方法<br>　　“config” 对象提供一些配置信息，常用的方法有getInitParameter和getInitParameterNames，以获得Servlet初始化时的参数。<br>　　“page” 对象代表了正在运行的由JSP文件产生的类对象，不建议一般读者使用。<br>　　“exception” 对象则代表了JSP文件运行时所产生的例外对象，此对象不能在一般JSP文件中直接使用，而只能在使用了“&lt; page isErrorPage=”true “ &gt;”的JSP文件中使用四个作用域：　　</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>   何为作用域<br>　　先让我们看看效果：<br>　　大概流程是这样的，我们访问04-01/index.jsp的时候，分别对pageContext, request, session,<br>　　application四个作用域中的变量进行累加。（当然先判断这个变量是不是存在，如果变量不存在，则要把变量初始化成1。）计算完成后就从index.jsp执行forward跳转到test.jsp。在test.jsp里再进行一次累加，然后显示出这四个整数来。<br>　　从显示的结果来看，我们可以直观的得出结论：<br>　　page里的变量没法从index.jsp传递到test.jsp。只要页面跳转了，它们就不见了。<br>　　request里的变量可以跨越forward前后的两页。但是只要刷新页面，它们就重新计算了。<br>　　session和application里的变量一直在累加，开始还看不出区别，只要关闭浏览器，再次重启浏览器访问这页，session里的变量就重新计算了。 来源:考试大-Java认证<br>       application里的变量一直在累加，除非你重启tomcat，否则它会一直变大。<br>　　而作用域规定的是变量的有效期限。<br>　　如果把变量放到pageContext里，就说明它的作用域是page，它的有效范围只在当前jsp页面里。<br>　　从把变量放到pageContext开始，到jsp页面结束，你都可以使用这个变量。<br>　　如果把变量放到request里，就说明它的作用域是request，它的有效范围是当前请求周期。<br>　　所谓请求周期，就是指从http请求发起，到服务器处理结束，返回响应的整个过程。在这个过程中可能使用forward的方式跳转了多个jsp页面，在这些页面里你都可以使用这个变量。<br>　　如果把变量放到session里，就说明它的作用域是session，它的有效范围是当前会话。<br>　　所谓当前会话，就是指从用户打开浏览器开始，到用户关闭浏览器这中间的过程。这个过程可能包含多个请求响应。也就是说，只要用户不关浏览器，服务器就有办法知道这些请求是一个人发起的，整个过程被称为一个会话（session），而放到会话中的变量，就可以在当前会话的所有请求里使用。<br>　　如果把变量放到application里，就说明它的作用域是application，它的有效范围是整个应用。<br>　　整个应用是指从应用启动，到应用结束。我们没有说“从服务器启动，到服务器关闭”，是因为一个服务器可能部署多个应用，当然你关闭了服务器，就会把上面所有的应用都关闭了。<br>　　application作用域里的变量，它们的存活时间是最长的，如果不进行手工删除，它们就一直可以使用。<br>　　与上述三个不同的是，application里的变量可以被所有用户共用。如果用户甲的操作修改了application中的变量，用户乙访问时得到的是修改后的值。这在其他scope中都是不会发生的，page, request,session都是完全隔离的，无论如何修改都不会影响其他人的数据。<br>　　我们使用public Object getAttribute(String name)获得变量值，使用public void setAttribute(String name, Object value)将变量值保存到对应作用域中。举个pageContext的例子就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page</span></span><br><span class="line">Integer countPage = (Integer) pageContext.getAttribute(<span class="string">"countPage"</span>);</span><br><span class="line"><span class="keyword">if</span> (countPage == <span class="keyword">null</span>) &#123;</span><br><span class="line">    pageContext.setAttribute(<span class="string">"countPage"</span>, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pageContext.setAttribute(<span class="string">"countPage"</span>, countPage + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　<br>　　这里先从pageContext中取出名为countPage的整数，因为返回的都是java.lang.Object类型，所以需要强制转换成我们需要的整形。这里取得的变量如果不存在就会返回null，通过判断countPage == null来辨别变量是否存在，如果不存在就设置为1，如果存在就进行累加，最后使用setAttribute()方法将修改后的变量值放入pageContext。<br>　　将其中的pageContext换成request, session, application就可以操作其他三个作用域中的变量。来源:</p>]]></content>
    
    <summary type="html">
    
      JSP九大内置对象及四个作用域，不需要预先声明就可以在脚本代码和表达式中随意使用
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
  </entry>
  
</feed>
