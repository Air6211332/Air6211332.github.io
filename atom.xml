<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小米的HEXO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://localhost/"/>
  <updated>2018-03-31T02:30:39.077Z</updated>
  <id>http://localhost/</id>
  
  <author>
    <name>小米</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Google Java编程风格指南</title>
    <link href="http://localhost/2018/03/31/Java/Google%20Java%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
    <id>http://localhost/2018/03/31/Java/Google Java编程风格指南/</id>
    <published>2018-03-31T01:42:10.432Z</published>
    <updated>2018-03-31T02:30:39.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。</p><p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。</p><h2 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h2><p>在本文档中，除非另有说明：</p><p>术语class可表示一个普通类，枚举类，接口或是annotation类型(<code>@interface</code>)<br>术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。<br>其他的术语说明会偶尔在后面的文档出现。</p><h2 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h2><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。</p><h1 id="源文件基础"><a href="#源文件基础" class="headerlink" title="源文件基础"></a>源文件基础</h1><h2 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h2><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为<code>.java</code>。</p><h2 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h2><p>源文件编码格式为UTF-8。</p><h2 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h2><h3 id="2-3-1-空白字符"><a href="#2-3-1-空白字符" class="headerlink" title="2.3.1 空白字符"></a>2.3.1 空白字符</h3><p>除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p><ul><li>所有其它字符串中的空白字符都要进行转义。</li><li>制表符不用于缩进。</li></ul><h3 id="2-3-2-特殊转义序列"><a href="#2-3-2-特殊转义序列" class="headerlink" title="2.3.2 特殊转义序列"></a>2.3.2 特殊转义序列</h3><p>对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, “, ‘及\)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。</p><h3 id="2-3-3-非ASCII字符"><a href="#2-3-3-非ASCII字符" class="headerlink" title="2.3.3 非ASCII字符"></a>2.3.3 非ASCII字符</h3><p>对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。</p><blockquote><p>Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。</p></blockquote><p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String unitAbbrev = <span class="string">"μs"</span>;                                 | 赞，即使没有注释也非常清晰</span><br><span class="line">String unitAbbrev = <span class="string">"\u03bcs"</span>; <span class="comment">// "μs"                    | 允许，但没有理由要这样做</span></span><br><span class="line">String unitAbbrev = <span class="string">"\u03bcs"</span>; <span class="comment">// Greek letter mu, "s"    | 允许，但这样做显得笨拙还容易出错</span></span><br><span class="line">String unitAbbrev = <span class="string">"\u03bcs"</span>;                            | 很糟，读者根本看不出这是什么</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\ufeff'</span> + content; <span class="comment">// byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释</span></span><br></pre></td></tr></table></figure></p><blockquote><p>Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)</p></blockquote><h1 id="源文件结构"><a href="#源文件结构" class="headerlink" title="源文件结构"></a>源文件结构</h1><p>一个源文件包含(按顺序地)：</p><ol><li>许可证或版权信息(如有需要)</li><li>package语句</li><li>import语句</li><li>一个顶级类(只有一个)</li></ol><p>以上每个部分之间用一个空行隔开。</p><h2 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h2><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h2 id="3-2-package语句"><a href="#3-2-package语句" class="headerlink" title="3.2 package语句"></a>3.2 package语句</h2><p>package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)</p><h2 id="3-3-import语句"><a href="#3-3-import语句" class="headerlink" title="3.3 import语句"></a>3.3 import语句</h2><h3 id="3-3-1-import不要使用通配符"><a href="#3-3-1-import不要使用通配符" class="headerlink" title="3.3.1 import不要使用通配符"></a>3.3.1 import不要使用通配符</h3><p>即，不要出现类似这样的import语句：<code>import java.util.*</code>;</p><h3 id="3-3-2-不要换行"><a href="#3-3-2-不要换行" class="headerlink" title="3.3.2 不要换行"></a>3.3.2 不要换行</h3><p>import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)</p><h3 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h3><p>import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：</p><p>所有的静态导入独立成组<br><code>com.google</code> imports(仅当这个源文件是在<code>com.google</code>包下)<br>第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun<br><code>java</code> imports<br><code>javax</code> imports<br>组内不空行，按字典序排列。</p><h2 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h2><h3 id="3-4-1-只有一个顶级类声明"><a href="#3-4-1-只有一个顶级类声明" class="headerlink" title="3.4.1 只有一个顶级类声明"></a>3.4.1 只有一个顶级类声明</h3><p>每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。</p><p>例外：package-info.java，该文件中可没有package-info类。</p><h3 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h3><p>类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h3 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h3><p>当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。</p><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p>术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p><h2 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h2><h3 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h3><p>大括号与<code>if, else, for, do, while</code>语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。</p><h3 id="4-1-2-非空块：K-amp-R-风格"><a href="#4-1-2-非空块：K-amp-R-风格" class="headerlink" title="4.1.2 非空块：K &amp; R 风格"></a>4.1.2 非空块：K &amp; R 风格</h3><p>对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (<a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html" target="_blank" rel="noopener">Egyptian brackets</a>):</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyClass() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        something();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ProblemException e) &#123;</span><br><span class="line">        recover();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4.8.1节给出了enum类的一些例外。</p><h3 id="4-1-3-空块：可以用简洁版本"><a href="#4-1-3-空块：可以用简洁版本" class="headerlink" title="4.1.3 空块：可以用简洁版本"></a>4.1.3 空块：可以用简洁版本</h3><p>一个空的块状结构里什么也不包含，大括号可以简洁地写成<code>{}</code>，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。</p><p>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothing</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-2-块缩进：2个空格"><a href="#4-2-块缩进：2个空格" class="headerlink" title="4.2 块缩进：2个空格"></a>4.2 块缩进：2个空格</h2><p>每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)</p><h2 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h2><p>每个语句后要换行。</p><h2 id="4-4-列限制：80或100"><a href="#4-4-列限制：80或100" class="headerlink" title="4.4 列限制：80或100"></a>4.4 列限制：80或100</h2><p>一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。</p><p>例外：</p><ol><li>不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。</li><li>package和import语句(见3.2节和3.3节)。</li><li>注释中那些可能被剪切并粘贴到shell中的命令行。</li></ol><h2 id="4-5-自动换行"><a href="#4-5-自动换行" class="headerlink" title="4.5 自动换行"></a>4.5 自动换行</h2><p>术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。</p><p>我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。</p><blockquote><p>Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)</p></blockquote><h3 id="4-5-1-从哪里断开"><a href="#4-5-1-从哪里断开" class="headerlink" title="4.5.1 从哪里断开"></a>4.5.1 从哪里断开</h3><p>自动换行的基本准则是：更倾向于在更高的语法级别处断开。</p><ol><li>如果在<code>非赋值运算符</code>处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（<code>&lt;T extends Foo &amp; Bar&gt;</code>)，catch块中的管道符号(<code>catch (FooException | BarException e</code>)</li><li>如果在<code>赋值运算符处</code>断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于<code>foreach</code>语句中的分号。</li><li>方法名或构造函数名与左括号留在同一行。</li><li>逗号(,)与其前面的内容留在同一行。</li></ol><h3 id="4-5-2-自动换行时缩进至少-4个空格"><a href="#4-5-2-自动换行时缩进至少-4个空格" class="headerlink" title="4.5.2 自动换行时缩进至少+4个空格"></a>4.5.2 自动换行时缩进至少+4个空格</h3><p>自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。</p><p>当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p><p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p><h2 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h2><h3 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h3><p>以下情况需要使用一个空行：</p><ol><li>类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。<ul><li><strong>例外：</strong>两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。</li></ul></li><li>在函数体内，语句的逻辑分组间使用空行。</li><li>类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。</li><li>要满足本文档中其他节的空行要求(比如3.3节：import语句)<br>多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。</li></ol><h3 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h3><p>除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：</p><ol><li>分隔任何保留字与紧随其后的左括号(<code>(</code>)(如<code>if, for catch</code>等)。</li><li>分隔任何保留字与其前面的右大括号(<code>}</code>)(如<code>else, catch</code>)。</li><li>在任何左大括号前({)，两个例外：<ul><li><code>@SomeAnnotation({a, b})</code>(不使用空格)。</li><li><code>String[][] x = foo;</code>(大括号间没有空格，见下面的Note)。</li></ul></li><li>在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：<ul><li>类型界限中的&amp;(<code>&lt;T extends Foo &amp; Bar&gt;</code>)。</li><li>catch块中的管道符号(<code>catch (FooException | BarException e</code>)。</li><li><code>foreach</code>语句中的分号。</li></ul></li><li>在<code>, : ;</code>及右括号(<code>)</code>)后</li><li>如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。</li><li>类型和变量之间：List list。</li><li>数组初始化中，大括号内的空格是可选的，即<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>都是可以的。</li></ol><blockquote><p>Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p></blockquote><h3 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h3><p><strong>术语说明</strong>：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。</p><p>这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。</p><p>以下示例先展示未对齐的代码，然后是对齐的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x; <span class="comment">// this is fine</span></span><br><span class="line"><span class="keyword">private</span> Color color; <span class="comment">// this too</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>   x;      <span class="comment">// permitted, but future edits</span></span><br><span class="line"><span class="keyword">private</span> Color color;  <span class="comment">// may leave it unaligned</span></span><br></pre></td></tr></table></figure></p><blockquote><p>Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。</p></blockquote><h2 id="4-7-用小括号来限定组：推荐"><a href="#4-7-用小括号来限定组：推荐" class="headerlink" title="4.7 用小括号来限定组：推荐"></a>4.7 用小括号来限定组：推荐</h2><p>除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。</p><h1 id="4-8-具体结构"><a href="#4-8-具体结构" class="headerlink" title="4.8 具体结构"></a>4.8 具体结构</h1><h3 id="4-8-1-枚举类"><a href="#4-8-1-枚举类" class="headerlink" title="4.8.1 枚举类"></a>4.8.1 枚举类</h3><p>枚举常量间用逗号隔开，换行可选。</p><p>没有方法和文档的枚举类可写成数组初始化的格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;</span><br></pre></td></tr></table></figure></p><p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p><h3 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h3><h4 id="4-8-2-1-每次只声明一个变量"><a href="#4-8-2-1-每次只声明一个变量" class="headerlink" title="4.8.2.1 每次只声明一个变量"></a>4.8.2.1 每次只声明一个变量</h4><p>不要使用组合声明，比如<code>int a, b</code>;。</p><h4 id="4-8-2-2-需要时才声明，并尽快进行初始化"><a href="#4-8-2-2-需要时才声明，并尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，并尽快进行初始化"></a>4.8.2.2 需要时才声明，并尽快进行初始化</h4><p>不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p><h3 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h3><h4 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h4><p>数组初始化可以写成块状结构，比如，下面的写法都是OK的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h4><p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p><h3 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h3><p><strong>术语说明</strong>：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。</p><h4 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h4><p>与其它块状结构一致，switch块中的内容缩进为2个空格。</p><p>每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。</p><h4 id="4-8-4-2-Fall-through：注释"><a href="#4-8-4-2-Fall-through：注释" class="headerlink" title="4.8.4.2 Fall-through：注释"></a>4.8.4.2 Fall-through：注释</h4><p>在一个switch块内，每个语句组要么通过<code>break, continue, return</code>或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是<code>default</code>)中出现。示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (input) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    prepareOneOrTwo();</span><br><span class="line">    <span class="comment">// fall through</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    handleOneTwoOrThree();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    handleLargeNumber(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4-8-4-3-default的情况要写出来"><a href="#4-8-4-3-default的情况要写出来" class="headerlink" title="4.8.4.3 default的情况要写出来"></a>4.8.4.3 default的情况要写出来</h4><p>每个switch语句都包含一个<code>default</code>语句组，即使它什么代码也不包含。</p><h3 id="4-8-5-注解-Annotations"><a href="#4-8-5-注解-Annotations" class="headerlink" title="4.8.5 注解(Annotations)"></a>4.8.5 注解(Annotations)</h3><p>注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getNameIfPresent</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>例外：单个的注解可以和签名的第一行出现在同一行。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Partial</span> <span class="meta">@Mock</span> DataLoader loader;</span><br></pre></td></tr></table></figure></p><p>参数和局部变量注解没有特定规则。</p><h3 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h3><h4 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h4><p>块注释与其周围的代码在同一缩进级别。它们可以是<code>/* ... *</code>/风格，也可以是<code>// ...</code>风格。对于多行的<code>/* ... */</code>注释，后续行必须从<em>开始， 并且与前一行的</em>对齐。以下示例注释都是OK的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is          // And so           /* Or you can</span></span><br><span class="line"><span class="comment"> * okay.            // is this.          * even do this. */</span></span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p>注释不要封闭在由星号或其它字符绘制的框架里。</p><p>Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用<code>/* ... */</code>。</p><h3 id="4-8-7-Modifiers"><a href="#4-8-7-Modifiers" class="headerlink" title="4.8.7 Modifiers"></a>4.8.7 Modifiers</h3><p>类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protected</span> <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">synchronized</span> <span class="keyword">native</span> <span class="keyword">strictfp</span></span><br></pre></td></tr></table></figure></p><p>命名约定</p><h2 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h2><p>标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式<code>\w+</code>。</p><p>在Google其它编程语言风格中使用的特殊前缀或后缀，如<code>name_</code>, <code>mName</code>, <code>s_name</code>和<code>kName</code>，在Java编程风格中都不再使用。</p><h2 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h2><h3 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h3><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。</p><h3 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h3><p>类名都以<code>UpperCamelCase</code>风格编写。</p><p>类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以<code>Test</code>结束。例如，<code>HashTest</code>或<code>HashIntegrationTest</code>。</p><h3 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h3><p>方法名都以<code>lowerCamelCase</code>风格编写。</p><p>方法名通常是动词或动词短语。</p><p>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如<code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p><h3 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h3><p>常量名命名模式为<code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？</p><p>每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远<code>不打算</code>改变对象一般是不够的，它要真的一直不变才能将它示为常量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableList&lt;String&gt; NAMES = ImmutableList.of(<span class="string">"Ed"</span>, <span class="string">"Ann"</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Joiner COMMA_JOINER = Joiner.on(<span class="string">','</span>);  <span class="comment">// because Joiner is immutable</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;</span><br><span class="line"><span class="keyword">enum</span> SomeEnum &#123; ENUM_CONSTANT &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Not constants</span></span><br><span class="line"><span class="keyword">static</span> String nonFinal = <span class="string">"non-final"</span>;</span><br><span class="line"><span class="keyword">final</span> String nonStatic = <span class="string">"non-static"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; mutableCollection = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(MyClass.getName());</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] nonEmptyArray = &#123;<span class="string">"these"</span>, <span class="string">"can"</span>, <span class="string">"change"</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>这些名字通常是名词或名词短语。</p><h3 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h3><p>非常量字段名以<code>lowerCamelCase</code>风格编写。</p><p>这些名字通常是名词或名词短语。</p><h3 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h3><p>参数名以<code>lowerCamelCase</code>风格编写。</p><p>参数应该避免用单个字符命名。</p><h3 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h3><p>局部变量名以<code>lowerCamelCase</code>风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。</p><p>虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。</p><p>即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。</p><h3 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h3><p>类型变量可用以下两种风格之一进行命名：</p><ul><li>单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。</li><li>以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。<h2 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h2><a href="http://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB" target="_blank" rel="noopener">驼峰式命名法</a>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。</li></ul><p>名字从<code>散文形式</code>(prose form)开始:</p><ol><li>把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。</li><li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。</li></ol><ul><li>推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul><ol><li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：</li></ol><ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li><li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul><ol><li>最后将所有的单词连接起来得到一个标识符。<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Prose form                Correct               Incorrect</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">&quot;XML HTTP request&quot;        XmlHttpRequest        XMLHTTPRequest</span><br><span class="line">&quot;new customer ID&quot;         newCustomerId         newCustomerID</span><br><span class="line">&quot;inner stopwatch&quot;         innerStopwatch        innerStopWatch</span><br><span class="line">&quot;supports IPv6 on iOS?&quot;   supportsIpv6OnIos     supportsIPv6OnIOS</span><br><span class="line">&quot;YouTube importer&quot;        YouTubeImporter</span><br><span class="line">                          YoutubeImporter*</span><br></pre></td></tr></table></figure></li></ol><p>加星号处表示可以，但不推荐。</p><blockquote><p>Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名<code>checkNonempty</code>和<code>checkNonEmpty</code>也都是正确的。</p></blockquote><h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><h2 id="6-1-Override：能用则用"><a href="#6-1-Override：能用则用" class="headerlink" title="6.1 @Override：能用则用"></a>6.1 @Override：能用则用</h2><p>只要是合法的，就把<code>@Override</code>注解给用上。</p><h2 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h2><p>除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个<code>AssertionError</code>重新抛出。)</p><p>如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> i = Integer.parseInt(response);</span><br><span class="line">  <span class="keyword">return</span> handleNumericResponse(i);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException ok) &#123;</span><br><span class="line">  <span class="comment">// it's not numeric; that's fine, just continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handleTextResponse(response);</span><br></pre></td></tr></table></figure></p><p>例外：在测试中，如果一个捕获的异常被命名为<code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  emptyStack.pop();</span><br><span class="line">  fail();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchElementException expected) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="6-3-静态成员：使用类进行调用"><a href="#6-3-静态成员：使用类进行调用" class="headerlink" title="6.3 静态成员：使用类进行调用"></a>6.3 静态成员：使用类进行调用</h2><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo aFoo = ...;</span><br><span class="line">Foo.aStaticMethod(); <span class="comment">// good</span></span><br><span class="line">aFoo.aStaticMethod(); <span class="comment">// bad</span></span><br><span class="line">somethingThatYieldsAFoo().aStaticMethod(); <span class="comment">// very bad</span></span><br></pre></td></tr></table></figure></p><h2 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 Finalizers: 禁用</h2><p>极少会去重写<code>Object.finalize</code>。</p><blockquote><p>Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解<a href="http://books.google.com/books?isbn=8131726592" target="_blank" rel="noopener">Effective Java</a> 第7条款：“Avoid Finalizers”，然后不要使用它。</p></blockquote><h1 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h1><h2 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h2><h3 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h3><p>Javadoc块的基本格式如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Multiple lines of Javadoc text are written here,</span></span><br><span class="line"><span class="comment"> * wrapped normally...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(String p1)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>或者是以下单行形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** An especially short bit of Javadoc. */</span></span><br></pre></td></tr></table></figure></p><p>基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。</p><h3 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h3><p>空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签<code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p><h3 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h3><p>标准的Javadoc标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。</p><h2 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h2><p>每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p><p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以<code>A {@code Foo} is a...</code>或<code>This method returns...</code>开头, 它也不会是一个完整的祈使句，如<code>Save the record...</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p><blockquote><p>Tip：一个常见的错误是把简单的Javadoc写成<code>/** @return the customer ID */</code>，这是不正确的。它应该写成<code>/** Returns the customer ID. */</code>。</p></blockquote><h2 id="7-3-哪里需要使用Javadoc"><a href="#7-3-哪里需要使用Javadoc" class="headerlink" title="7.3 哪里需要使用Javadoc"></a>7.3 哪里需要使用Javadoc</h2><p>至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：</p><h3 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h3><p>对于简单明显的方法如<code>getFoo</code>，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。</p><p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p><blockquote><p>Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名<code>getCanonicalName</code>， 就不应该忽视文档说明，因为读者很可能不知道词语<code>canonical name</code>指的是什么。</p></blockquote><h3 id="7-3-2-例外：重写"><a href="#7-3-2-例外：重写" class="headerlink" title="7.3.2 例外：重写"></a>7.3.2 例外：重写</h3><p>如果一个方法重写了超类中的方法，那么Javadoc并非必需的。</p><h3 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h3><p>对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。</p><p>后记<br>本文档翻译自<a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html" target="_blank" rel="noopener">Google Java Style</a>， 译者<a href="http://weibo.com/hawstein" target="_blank" rel="noopener">@Hawstein</a>,转载自<a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener">Hawstein’s Blog</a>。</p>]]></content>
    
    <summary type="html">
    
      这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Centos7安装RabbitMq</title>
    <link href="http://localhost/2018/03/30/Linux/Centos7%E5%AE%89%E8%A3%85RabbitMq/"/>
    <id>http://localhost/2018/03/30/Linux/Centos7安装RabbitMq/</id>
    <published>2018-03-30T08:32:06.000Z</published>
    <updated>2018-03-30T05:13:50.340Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="Linux" scheme="http://localhost/categories/Linux/"/>
    
      <category term="Shell" scheme="http://localhost/categories/Linux/Shell/"/>
    
    
      <category term="Linux" scheme="http://localhost/tags/Linux/"/>
    
      <category term="Centos7" scheme="http://localhost/tags/Centos7/"/>
    
  </entry>
  
  <entry>
    <title>全能型开源远程终端：MobaXterm</title>
    <link href="http://localhost/2018/03/28/soft/MobaXterm/"/>
    <id>http://localhost/2018/03/28/soft/MobaXterm/</id>
    <published>2018-03-28T14:42:39.297Z</published>
    <updated>2018-03-29T05:33:22.215Z</updated>
    
    <summary type="html">
    
      破解Securecrt怕中毒，Xshell 用着不爽，Putty太单薄，手头没Mac用不了iterm2。那就试试这个全能开源的终端吧(MobaXterm)!下面就介绍下MobaXterm的主要功能
    
    </summary>
    
      <category term="软件" scheme="http://localhost/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="MobaXterm" scheme="http://localhost/tags/MobaXterm/"/>
    
      <category term="软件" scheme="http://localhost/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 2018.1 更新内容</title>
    <link href="http://localhost/2018/03/28/soft/IDEA2018.1/"/>
    <id>http://localhost/2018/03/28/soft/IDEA2018.1/</id>
    <published>2018-03-28T12:09:47.686Z</published>
    <updated>2018-03-28T14:23:32.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Enhancements-in-code-completion"><a href="#Enhancements-in-code-completion" class="headerlink" title="Enhancements in code completion"></a>Enhancements in code completion</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaCodeCompletion.gif" alt=""><br>Completion in the Stream API chains is now aware of type casting. Code completion can not only suggest a completion item according to the existing call filter (String.class::isInstance), but also for an automatically typecast completion item.</p><h2 id="Data-flow-analysis"><a href="#Data-flow-analysis" class="headerlink" title="Data flow analysis"></a>Data flow analysis</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaDataFlow1.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaDataFlow3.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaDataFlow2.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaImmutableCollections.png" alt=""><br>We’ve improved our <strong>data flow analysis</strong> so it can now track the relationships between variables like “greater than” and “less than.” The IDE detects when a condition is always true (or false) in all the possible code paths when the variables are compared.</p><p>The IDE will now warn you when you try to assign a variable to the same value it already contains. This may help you detect and then remove some redundant code.</p><p>The <strong>data flow analysis</strong> now works for non-terminated stream API chains.</p><p>The IDE will also warn you about modifications to immutable collections.</p><p><a href="https://blog.jetbrains.com/idea/2018/01/fumigating-the-idea-ultimate-code-using-dataflow-analysis/" target="_blank" rel="noopener">learn more</a></p><h2 id="Missing-ServiceLoader-declaration"><a href="#Missing-ServiceLoader-declaration" class="headerlink" title="Missing ServiceLoader declaration"></a>Missing ServiceLoader declaration</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Java9ServiceLoader.gif" alt=""><br>IntelliJ IDEA 2018.1 has new <strong>Java 9</strong> inspections and quick-fixes. The IDE now checks that a service loaded by <strong>ServiceLoader</strong> is declared in the module-info.java file, and will offer a quick-fix to add a missing statement to the <strong>module-info.java</strong> file.</p><p><a href="https://blog.jetbrains.com/idea/2018/03/advanced-support-for-java-9-modules-in-intellij-idea-2018-1/" target="_blank" rel="noopener">learn more</a></p><h2 id="Creating-missing-class"><a href="#Creating-missing-class" class="headerlink" title="Creating missing class"></a>Creating missing class</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Java9CreateMissingClass.gif" alt=""><br>For an unresolved class mentioned in <strong>module-info.java</strong>, the IDE will suggest creating the missing class, and create missing exported packages as well. Note the IDE creates the package with the class in the required directory, as you can’t export an empty package in <strong>Java 9</strong>.</p><h2 id="Idempotent-body-detection"><a href="#Idempotent-body-detection" class="headerlink" title="Idempotent body detection"></a>Idempotent body detection</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaIdempotentBodyDetection.png" alt=""><br>The IDE will detect and warn you about the while-loops with an idempotent body, as in most cases this indicates a programming error and can lead to a program hang.</p><h2 id="Move-break-condition-of-infinite-loop-to-loop-condition"><a href="#Move-break-condition-of-infinite-loop-to-loop-condition" class="headerlink" title="Move break-condition of infinite loop to loop condition"></a>Move break-condition of infinite loop to loop condition</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaLoopTransformation.gif" alt=""><br>For while-loops, now you get a notification about a conditional break at the end or beginning of an infinite loop. The IDE will suggest moving a break condition to a loop condition and offer a quick-fix to modify your loop. Usually replacing a conditional break with a loop condition makes the code clearer.</p><h2 id="Explicitly-redundant-close-call"><a href="#Explicitly-redundant-close-call" class="headerlink" title="Explicitly redundant close() call"></a>Explicitly redundant close() call</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaRedundantClose.gif" alt=""><br>IntelliJ IDEA now detects an explicitly redundant close() call of the resource at the end of a try-with-resources block.</p><h2 id="Infinite-Stream-detection"><a href="#Infinite-Stream-detection" class="headerlink" title="Infinite Stream detection"></a>Infinite Stream detection</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaInfiniteStream.png" alt=""><br>IntelliJ IDEA will warn you about any infinite streams that weren’t short-circuited, as such operations can be completed only by throwing an exception. Such code may result in an infinite loop or a running out of memory issue.</p><h2 id="Copy-constructor-with-missing-fields-detection"><a href="#Copy-constructor-with-missing-fields-detection" class="headerlink" title="Copy constructor with missing fields detection"></a>Copy constructor with missing fields detection</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaCopyConstructor.png" alt=""><br>In IntelliJ IDEA 2018.1 you’ll get a notification if there is a copy constructor that doesn’t copy all the fields in a class. The IDE considers fields with a transient modifier unnecessary to copy.</p><h2 id="Sort-array-content"><a href="#Sort-array-content" class="headerlink" title="Sort array content"></a>Sort array content</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaSortContent.gif" alt=""><br>A new Sort content action is available in array initializers and varargs. This new action sorts content alphabetically.</p><h2 id="User-Postfix-Completion-template"><a href="#User-Postfix-Completion-template" class="headerlink" title="User Postfix Completion template"></a>User Postfix Completion template</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaPostfixCompletion.gif" alt=""><br>The <strong>postfix code completion</strong> has been improved. The IDE now lets you create your own Java templates or edit and rename some of the predefined Java templates through <strong>Preferences | Editor | General | Postfix Completion</strong>.</p><h2 id="Fix-partially-in-Inspection-Results"><a href="#Fix-partially-in-Inspection-Results" class="headerlink" title="Fix partially in Inspection Results"></a>Fix partially in Inspection Results</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaFixPartially.png" alt=""><br>A new <strong>Fix partially</strong> button has been added to the right-hand pane of the <strong>Inspection Results Tool</strong> Window. It appears when you have several options for fixing possible problems in the chosen scope. All the suggested quick-fixes are grouped by the quick-fix type under the <strong>Fix partially</strong> button. This new feature allows you to apply the required quick-fix to the chosen scope, and fix all affected cases in one go.</p><h2 id="Test-prefix-in-Code-Generation"><a href="#Test-prefix-in-Code-Generation" class="headerlink" title="Test prefix in Code Generation"></a>Test prefix in Code Generation</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaTestPrefix.png" alt=""><br>In IntelliJ IDEA you can generate a test class using the intention action. With IntelliJ IDEA 2018.1, you can customize a test class template and create a test class with <strong>Test</strong> as a prefix. Go to <strong>Preferences | Editor | Code Style | Java | Code Generation</strong>, and choose how the test class name should be generated. By default, the IDE creates a test class with the <strong>Test</strong> as a suffix.</p><h2 id="JUnit-5-Tag-annotation-support"><a href="#JUnit-5-Tag-annotation-support" class="headerlink" title="JUnit 5 @Tag annotation support"></a>JUnit 5 @Tag annotation support</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaJUnit5.png" alt=""><br>IntelliJ IDEA 2018.1 now supports the <strong>JUnit5 @Tag</strong> annotation so now you can include tagged classes and tagged methods, in the testing scope. Select the Tags (JUnit 5) option in the test kind field in the Run/Debug Configuration dialog. Use the <strong>Uniqueld</strong> field to filter tests according to their id.</p><h1 id="JVM-Debugger"><a href="#JVM-Debugger" class="headerlink" title="JVM Debugger"></a>JVM Debugger</h1><h2 id="Throw-Exception"><a href="#Throw-Exception" class="headerlink" title="Throw Exception"></a>Throw Exception</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DebuggerRaiseException.gif" alt=""><br>IntelliJ IDEA 2018.1 has a new <strong>Throw Exception</strong> action that allows you to throw an exception from a certain location in your program without changing the code. It is available from the <strong>Run | Throw Exception</strong> menu, or from the frame context menu during a debugging session.</p><h2 id="Logging-stacktrace-to-console"><a href="#Logging-stacktrace-to-console" class="headerlink" title="Logging stacktrace to console"></a>Logging stacktrace to console</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DebuggerLogConsole.gif" alt=""><br>The IDE now allows you to print breakpoints stack traces to the console. You can enable the stack trace option in the <strong>Breakpoints</strong> dialog box. In IntelliJ IDEA, you can now observe multiple breakpoints stack traces at the same time in the <strong>Console</strong> log.</p><h2 id="Copy-current-thread-stacktrace"><a href="#Copy-current-thread-stacktrace" class="headerlink" title="Copy current thread stacktrace"></a>Copy current thread stacktrace</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DebuggerCopyStack.png" alt=""><br>You can now copy the current thread stack trace via a new <strong>Copy Stack</strong> action which is available from the frame context menu.</p><h2 id="Annotations-for-Async-stack-traces"><a href="#Annotations-for-Async-stack-traces" class="headerlink" title="Annotations for Async stack traces"></a>Annotations for Async stack traces</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DebuggerAnnotations1.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DebuggerAnnotations2.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DebuggerAnnotations3.png" alt=""><br>With IntelliJ IDEA 2018.1 we’ve extended the Async stack traces feature so that you can now use the <a href="mailto:**@Async.Schedule" target="_blank" rel="noopener">**@Async.Schedule</a><strong> and </strong>@Async.Execute** annotations to set up capture points that are not included in the default configuration. You just need to add <a href="https://mvnrepository.com/artifact/org.jetbrains/annotations/16.0.1" target="_blank" rel="noopener">Maven artifact</a>  as a dependency.</p><h1 id="Java-Compiler"><a href="#Java-Compiler" class="headerlink" title="Java Compiler"></a>Java Compiler</h1><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/JavaCompiler.png" alt=""><br>There is a new <strong>Use –release option for cross-compilation (Java 9 and later)</strong> checkbox on the <strong>Java Compiler</strong> page at <strong>Preferences | Build, Execution, Deployment | Compiler | Java Compiler</strong> that is enabled by default. When you need to use the <strong>–source</strong> and <strong>–target</strong> options with Java 9 and link against Java 9 classes at the same time, you can disable this checkbox.</p><p>You can also use a specific version of the <strong>ECJ compiler</strong>. Select Eclipse from the <strong>Use Compiler</strong> drop-down menu, and specify the path to jar with the chosen compiler.</p><h1 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h1><h2 id="Folded-code-highlighting"><a href="#Folded-code-highlighting" class="headerlink" title="Folded code highlighting"></a>Folded code highlighting</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/EditorHighlightsFoldedCode.gif" alt=""><br>If any issues have been detected in your code, now you can find them quicker than before. The IDE now highlights the folded code regions that contain errors or warnings, and colors such blocks according to their validation status.</p><h2 id="Highlights-the-folded-code-regions-with-the-search-results"><a href="#Highlights-the-folded-code-regions-with-the-search-results" class="headerlink" title="Highlights the folded code regions with the search results"></a>Highlights the folded code regions with the search results</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/EditorHighlightsSearch.gif" alt=""><br>The IDE also highlights folded code regions if they contain any matches when you search through the current file.</p><h2 id="Inline-external-annotations"><a href="#Inline-external-annotations" class="headerlink" title="Inline external annotations"></a>Inline external annotations</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/EditorExternalAnnotation.png" alt=""><br>In IntelliJ IDEA you can annotate your code with external annotations even when direct annotation of the source code is not possible (library classes). You can configure your annotations in the <strong>annotations.xml</strong> files, which are stored outside of your source code. Previously the IDE only showed the @ icon in the gutter near the externally annotated code; now the IDE shows these external annotations inline in your code.</p><h2 id="Inferred-Annotation-Hints"><a href="#Inferred-Annotation-Hints" class="headerlink" title="Inferred Annotation Hints"></a>Inferred Annotation Hints</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/EditorInferredAnnotation.png" alt=""><br>IntelliJ IDEA now lets you view the automatic inferences of <strong>@NotNull</strong> or <strong>@Nullable</strong> annotations right in your source code (not only in the gutter icon near the inferred annotation, as it was before). You can enable the <strong>Show inferred annotations inline</strong> checkbox in the <strong>Preferences | Editor | General | Appearance</strong>.</p><h1 id="Project-Configuration"><a href="#Project-Configuration" class="headerlink" title="Project Configuration"></a>Project Configuration</h1><h2 id="Add-“provided”-dependencies-to-classpath"><a href="#Add-“provided”-dependencies-to-classpath" class="headerlink" title="Add “provided” dependencies to classpath"></a>Add “provided” dependencies to classpath</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/ProjectConfiguration.png" alt=""><br>A new <strong>Include dependencies with “Provided” scope</strong> checkbox has been added in the <strong>Run/Debug Configurations</strong> for the <strong>Application</strong> and <strong>Spring Boot</strong> configurations. This new option will be useful if you have the <strong>provided</strong> dependencies for the scope in your project, but you run your application both inside a container (where <strong>provided</strong> dependencies are supplied by the container) and outside a container (where <strong>provided</strong> dependencies are not automatically supplied).</p><p>For the <strong>Spring Boot</strong> applications, the <strong>Include dependencies with “Provided” scope</strong> option is enabled by default.</p><h2 id="New-Change-Module-Names…-action"><a href="#New-Change-Module-Names…-action" class="headerlink" title="New Change Module Names… action"></a>New Change Module Names… action</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/ProjectConfigurationRename.png" alt=""><br>With IntelliJ IDEA, you can now change qualified names for multiple modules all at once. This is done via the new <strong>Change Module Names…</strong> action, from the context menu of the <strong>Project Structure</strong> dialog.</p><h1 id="Search-and-Replace"><a href="#Search-and-Replace" class="headerlink" title="Search and Replace"></a>Search and Replace</h1><h2 id="Structural-Search-enhancement"><a href="#Structural-Search-enhancement" class="headerlink" title="Structural Search enhancement"></a>Structural Search enhancement</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/StructuralSearch1.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/StructuralSearch2.png" alt=""><br>With IntelliJ IDEA 2018.1, you can find method calls to annotated methods using <strong>Structural Search</strong>. You can select them from the existing search templates or create your own.</p><h2 id="Replace-in-Path-improvements"><a href="#Replace-in-Path-improvements" class="headerlink" title="Replace in Path improvements"></a>Replace in Path improvements</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Replace.png" alt=""><br>IntelliJ IDEA 2018.1 has the ability to preview a regex replacement in the <strong>Replace in Path</strong> dialog.</p><h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><p>The Kotlin plugin bundled with the IDE has been updated to <a href="https://blog.jetbrains.com/kotlin/2018/03/kotlin-1-2-30-is-out/" target="_blank" rel="noopener">Kotlin 1.2.30</a></p><h2 id="Pasting-Kotlin-code-into-a-package"><a href="#Pasting-Kotlin-code-into-a-package" class="headerlink" title="Pasting Kotlin code into a package"></a>Pasting Kotlin code into a package</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Kotlin1.gif" alt=""><br>Now, in the <strong>Project Tool Window</strong>, you can paste a code fragment directly into a package, and the IDE will create a new Kotlin file with the pasted code.</p><h2 id="Intentions-for-converting-the-scoping-function-calls"><a href="#Intentions-for-converting-the-scoping-function-calls" class="headerlink" title="Intentions for converting the scoping function calls"></a>Intentions for converting the scoping function calls</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Kotlin2.gif" alt=""><br>The Kotlin Plugin now offers new intentions that convert the scoping function calls <strong>let</strong> and <strong>run</strong> into each other, as well as <strong>also</strong> into <strong>apply</strong> and vice versa.</p><h1 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h1><h2 id="New-Convert-to-CompileStatic-refactoring-action"><a href="#New-Convert-to-CompileStatic-refactoring-action" class="headerlink" title="New Convert to @CompileStatic refactoring action"></a>New Convert to @CompileStatic refactoring action</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/GroovyConvert-1.gif" alt=""><br>Now you have a new action that’s very useful when you want to keep your code in Groovy and at the same time benefit from static compilation. To save you a lot of time migrating from existing Groovy code, this new refactoring annotates every groovy class in the scope with the <strong>@CompileStatic</strong> annotation.</p><p>This new refactoring action is available from the context menu <strong>Refactor | Convert to @CompileStatic</strong>.</p><p><a href="https://blog.jetbrains.com/idea/2018/03/whats-groovy-about-intellij-idea-2018-1/" target="_blank" rel="noopener">learn more</a></p><h2 id="Unnecessary-import-alias"><a href="#Unnecessary-import-alias" class="headerlink" title="Unnecessary import alias"></a>Unnecessary import alias</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/GroovyAliasInspection.gif" alt=""><br>IntelliJ IDEA 2018.1 reports unnecessary import alias for Groovy files. This new warning also works on static imports.</p><h1 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h1><h2 id="Inline-hints"><a href="#Inline-hints" class="headerlink" title="Inline hints"></a>Inline hints</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/ScalaInlineHints.png" alt=""><br>The editor can now show <strong>inline hints</strong> for parameter names, method result types, and variable types. You can also easily use the settings to customize when such a hint should be shown.</p><h2 id="Structure-View-improvement"><a href="#Structure-View-improvement" class="headerlink" title="Structure View improvement"></a>Structure View improvement</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/ScalaStructureView.png" alt=""><br>The <strong>Structure View</strong> now shows much more information about code. It displays final, abstract and access modifiers, nested definitions, primary constructor types, case class parameters as members, etc. The <strong>Structure View</strong> also provides you with an option to show all inherited members with their original class.</p><h2 id="Refactoring-Inline-function-parameters"><a href="#Refactoring-Inline-function-parameters" class="headerlink" title="Refactoring: Inline function parameters"></a>Refactoring: Inline function parameters</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Scala3-1.gif" alt=""><br>The refactoring is now capable of inlining functions with parameters. It correctly substitutes them with actual values.</p><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><p>IntelliJ IDEA 2018.1 merges the changes from <a href="https://developer.android.com/studio/releases/index.html" target="_blank" rel="noopener">Android Studio 3.0</a> and includes dozens of new features, with the following major new ones</p><h2 id="Layout-Editor-improvements"><a href="#Layout-Editor-improvements" class="headerlink" title="Layout Editor improvements"></a>Layout Editor improvements</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Android1.png" alt=""><br>The <strong>Layout Editor</strong> has been improved: there is a new toolbar layout and icons, updated layouts in the component tree, a new error panel, and more.</p><p>For methods with <strong>@GetMapping</strong> annotations, you have a choice to open the mapped URLs in a browser, or open a request in the <strong>HTTP Request Editor</strong>.</p><h2 id="Brand-new-profiling-tools"><a href="#Brand-new-profiling-tools" class="headerlink" title="Brand new profiling tools"></a>Brand new profiling tools</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Android4.gif" alt=""><br>IntelliJ IDEA 2018.1 now includes Android Profiler, a brand new suite of profiling tools that provide real-time data for your app’s CPU, memory, and network activity.</p><h2 id="Device-File-Explorer-Tool-Window"><a href="#Device-File-Explorer-Tool-Window" class="headerlink" title="Device File Explorer Tool Window"></a>Device File Explorer Tool Window</h2><p>The new <strong>Device File Explorer Tool Window</strong> displays the file and directory structure of your Android device or emulator. Use this tool window to view, copy, and delete files on an Android device. You can access it through <strong>View | Tool Windows | Device File Explorer</strong>.</p><h2 id="Build-Instant-Apps"><a href="#Build-Instant-Apps" class="headerlink" title="Build Instant Apps"></a>Build Instant Apps</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/AndroidInstantApp1.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/AndroidInstantApp.png" alt=""><br>The IDE now supports the ability to build <strong>Instant Apps</strong> – lightweight Android apps that can be run without installation. To start building <strong>Instant Apps</strong>, make sure that the <strong>Instant Apps Development SDK</strong> is installed. You can check which <strong>SDK</strong> tools are installed in <strong>Preferences | Appearance &amp; Behavior | System Settings | Android SDK</strong> in the <strong>SDK</strong> tab.</p><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><h2 id="Access-HTTP-request-mappings-from-the-editor-via-the-new-REST-client"><a href="#Access-HTTP-request-mappings-from-the-editor-via-the-new-REST-client" class="headerlink" title="Access HTTP request mappings from the editor via the new REST client"></a>Access HTTP request mappings from the editor via the new REST client</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/SpringBootREST.gif" alt=""><br>Now, after you run a <strong>Spring Boot web application</strong>, a new icon is shown in the gutter for methods with <strong>@RequestMapping</strong> annotations that handle incoming <strong>HTTP requests</strong>. Click this gutter icon to open all the mappings in a scratch file with an .http extension and perform an <strong>HTTP request</strong> in the editor via the new <strong>REST client</strong>.</p><p>For methods with <strong>@GetMapping</strong> annotations, you have the choice to open the mapped URLs in a browser, or open a request in the <strong>HTTP Request Editor</strong>.</p><p>Note, that you need to add the dependency for the <strong>spring-boot-starter-actuator</strong> to your <strong>pom.xml</strong> or <strong>build.gradle</strong> file.</p><h2 id="New-gutter-icons-for-beans-registered-in-the-application-context"><a href="#New-gutter-icons-for-beans-registered-in-the-application-context" class="headerlink" title="New gutter icons for beans registered in the application context"></a>New gutter icons for beans registered in the application context</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/SpringBootBeans.png" alt=""><br>IntelliJ IDEA shows all the beans that are registered in the application context in the <strong>Beans</strong> tab in the <strong>Run Dashboard</strong> (or in the <strong>Run Tool Window</strong>). We’ve extended this functionality, and now this information is also available in the editor. The new gutter icons are shown next to the beans that are used at runtime.</p><p>Click these new gutter icons to navigate to the dependent beans.</p><h1 id="Version-Control"><a href="#Version-Control" class="headerlink" title="Version Control"></a>Version Control</h1><h2 id="Partial-Git-commits"><a href="#Partial-Git-commits" class="headerlink" title="Partial Git commits"></a>Partial Git commits</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSPartialCommit1.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSPartialCommits2.png" alt=""><br>IntelliJ IDEA 2018.1 supports <strong>partial Git commits</strong> (git add -p). The IDE lets you associate the code chunks with a changelist. Create a changelist, put all the needed code chunks there, and then commit it. The IDE will now only commit the selected changes from the file and will skip all other changes. To add the code chunks to a commit, use the checkboxes in the gutter in the <strong>Diff</strong> pane of the <strong>Commit Changes</strong> dialog.</p><p>To move the code chunks between changelists, use the <strong>Move to Another Changelist…</strong> action from the context menu of the <strong>Diff</strong> pane in the <strong>Commit Changes</strong> dialog.</p><p>Alternatively, add code chunks to a changelist from the editor by clicking on a change marker in the gutter.</p><h2 id="Toggle-grouping-of-local-changes-by-directory-module-or-repository"><a href="#Toggle-grouping-of-local-changes-by-directory-module-or-repository" class="headerlink" title="Toggle grouping of local changes by directory, module, or repository"></a>Toggle grouping of local changes by directory, module, or repository</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSGroupBy.png" alt=""><br>With IntelliJ IDEA 2018.1, you can choose how to display your local changes by grouping them according to their directory, module, or repository. Use the new <strong>Group by</strong> icon available in the <strong>Local Changes</strong> tab in the <strong>Version Control Tool Window</strong>. Note that now you can select one of the grouping options or all three at once if needed.</p><h2 id="Navigate-by-clicking-on-the-commit-hash"><a href="#Navigate-by-clicking-on-the-commit-hash" class="headerlink" title="Navigate by clicking on the commit hash"></a>Navigate by clicking on the commit hash</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSLogTab.gif" alt=""><br>In the <strong>Log</strong> tab inside the commit detail panes, the IDE now highlights hashes of the commits you are referring to. By simply clicking commit hashes you can jump to that commit in the <strong>Log</strong> tab. This works for <strong>Git</strong> and <strong>Mercurial</strong>. Also, the <strong>Commit Details</strong> pane of the <strong>Log</strong> tab has been redesigned</p><h2 id="History-for-revision-tab-enhancement"><a href="#History-for-revision-tab-enhancement" class="headerlink" title="History for revision tab enhancement"></a>History for revision tab enhancement</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSHistoryForRevision.gif" alt=""><br>IntelliJ IDEA lets you view detailed information about file changes by invoking the <strong>Show History for a Revision</strong> action on a file in the <strong>Log</strong> tab (available for <strong>Git</strong> integration). In 2018.1, we’ve updated the <strong>History for revision</strong> tab so that now it works much faster. In addition to better performance, this tab has a refreshed UI resembling the <strong>Log</strong> tab.</p><h2 id="Clone-Repository"><a href="#Clone-Repository" class="headerlink" title="Clone Repository"></a>Clone Repository</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSCloneRepository.png" alt=""><br>Moreover, the <strong>Clone Repository</strong> dialogs for <strong>Git</strong> and <strong>GitHub</strong> have been merged into one.</p><p>Autocompletion for <strong>GitHub</strong> repositories also works in the new <strong>Clone Repository</strong> dialog. You just need to log in to your <strong>GitHub</strong> account by clicking <strong>Log in to GitHub</strong>.</p><h2 id="New-shortcut-for-the-Commit-and-Push…-action"><a href="#New-shortcut-for-the-Commit-and-Push…-action" class="headerlink" title="New shortcut for the Commit and Push… action"></a>New shortcut for the Commit and Push… action</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSShortCut-1.png" alt=""><br>The IDE has a new default shortcut to perform the <strong>Commit and Push…</strong> action from the <strong>Commit Changes</strong> dialog. Please use <strong>Alt + Cmd + K (on macOS)</strong> or <strong>Alt + Ctrl + K (on Windows and Linux)</strong>.</p><h2 id="Git-Branches-pop-up"><a href="#Git-Branches-pop-up" class="headerlink" title="Git Branches pop-up"></a>Git Branches pop-up</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VCSGitBranches.png" alt=""><br>The <strong>Abort Rebase</strong>, <strong>Continue Rebase</strong>, and <strong>Skip Commit</strong> actions are now available from the <strong>Git Branches</strong> pop-up if there is an ongoing rebase process.</p><h1 id="User-Interface"><a href="#User-Interface" class="headerlink" title="User Interface"></a>User Interface</h1><h2 id="New-documentation-UI"><a href="#New-documentation-UI" class="headerlink" title="New documentation UI"></a>New documentation UI</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DocumentationUI.png" alt=""><br>We’ve updated the Quick Documentation pop-up and made it clearer and more compact. Information about the method’s parameters, type, and return type is now available for Java, JavaScript, and TypeScript in the updated Quick Documentation pop-up</p><h1 id="Better-HiDPI-support"><a href="#Better-HiDPI-support" class="headerlink" title="Better HiDPI support"></a>Better HiDPI support</h1><p>When you run the IntelliJ IDEA 2018.1 on Windows 8.1 (or higher), the IDE starts in per-monitor DPI-aware mode, with implemented support for the fractional scale factors of the monitor. Previously only integral scale factors were supported in the IDE. To switch back to the default mode, you need to set-up the VM option <strong>-Dsun.java2d.uiScale.enabled = false</strong></p><h1 id="JavaScript-amp-TypeScript"><a href="#JavaScript-amp-TypeScript" class="headerlink" title="JavaScript &amp; TypeScript"></a>JavaScript &amp; TypeScript</h1><h2 id="TypeScript-improvements"><a href="#TypeScript-improvements" class="headerlink" title="TypeScript improvements"></a>TypeScript improvements</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/typescript-surround-with-the-type-alias.png" alt=""><br>IntelliJ IDEA now supports the latest <strong>TypeScript 2.7</strong> features, improves the <strong>Implement Members</strong> action, and adds the new <strong>Surround with type guard</strong> quick-fix for unresolved properties.</p><h2 id="Create-a-new-Vue-project"><a href="#Create-a-new-Vue-project" class="headerlink" title="Create a new Vue project"></a>Create a new Vue project</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/VueCrop.png" alt=""><br>With the <a href="https://plugins.jetbrains.com/plugin/9442-vue-js" target="_blank" rel="noopener">Vue.js</a> plugin installed in IntelliJ IDEA, you can use Vue CLI, an official tool for scaffolding Vue apps, to create new Vue projects. To install Vue CLI, run <strong>npm install –g vue-cli</strong> in the terminal.</p><h2 id="Reformat-with-Prettier"><a href="#Reformat-with-Prettier" class="headerlink" title="Reformat with Prettier"></a>Reformat with Prettier</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/PrettierReformat.png" alt=""><br>IntelliJ IDEA supports <a href="https://prettier.io/" target="_blank" rel="noopener">Prettier</a>, an opinionated code formatter via <a href="https://plugins.jetbrains.com/plugin/10456-prettier" target="_blank" rel="noopener">Prettier</a> plugin. After you have the prettier package installed, the new <strong>Reformat with Prettier</strong> action will become available in IntelliJ IDEA. You can format the selected code, a file, or a whole directory using Prettier.</p><h1 id="Hunspell"><a href="#Hunspell" class="headerlink" title="Hunspell"></a>Hunspell</h1><h2 id="Hunspell-dictionary-support"><a href="#Hunspell-dictionary-support" class="headerlink" title="Hunspell dictionary support"></a>Hunspell dictionary support</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Hunspell.png" alt=""><br>The Hunspell plugin that provides Hunspell dictionary support is now compatible with IntelliJ IDEA. Compared to a plain list of words, Hunspell provides significantly faster and much more accurate misprint detection, with far fewer false positives.</p><p><a href="https://blog.jetbrains.com/phpstorm/2018/01/hunspell-dictionaries-support/" target="_blank" rel="noopener">learn more</a></p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="Enhancement-in-Docker-compose"><a href="#Enhancement-in-Docker-compose" class="headerlink" title="Enhancement in Docker compose"></a>Enhancement in Docker compose</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/Docker1.png" alt=""><br>The <strong>Docker</strong> plugin now supports <strong>Multiple Docker Compose</strong> files and respects not only a <strong>docker-compose.yml</strong> but also an optional <strong>docker-compose.override.yml</strong> file. You can add <strong>docker-compose.override.yml</strong> as you would any other override file, right after the base configuration file.</p><h2 id="Docker-compose-services"><a href="#Docker-compose-services" class="headerlink" title="Docker compose services"></a>Docker compose services</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/DockerCompose.png" alt=""><br>The <strong>Docker</strong> plugin allows you to choose the services to run just after choosing the configuration files in the <strong>Docker-compose</strong> run configuration.</p><p>The plugin shows all the existing <strong>Compose projects</strong>, not only the ones deployed via the <strong>Docker-Compose</strong> run configuration.</p><h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="Support-for-YAML-Kubernetes-resource-files"><a href="#Support-for-YAML-Kubernetes-resource-files" class="headerlink" title="Support for YAML Kubernetes resource files"></a>Support for YAML Kubernetes resource files</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesLiveTemplate.gif" alt=""><br>The brand new <strong>Kubernetes</strong> plugin supports the <strong>Kubernetes resource</strong> files from v1.5 up to the recently released v1.9. The new plugin will look for the presence of <strong>apiVersion</strong> and other fields of this kind in the files, and if these are present, it will consider such files as <strong>Kubernetes resource</strong> files.</p><p><a href="https://blog.jetbrains.com/idea/2018/03/intellij-idea-2018-1-kubernetes-support/" target="_blank" rel="noopener">learn more</a></p><h2 id="Completion-in-YAML-Kubernetes-resource-files"><a href="#Completion-in-YAML-Kubernetes-resource-files" class="headerlink" title="Completion in YAML Kubernetes resource files"></a>Completion in YAML Kubernetes resource files</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesCompletion.gif" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesSmartCompletion.gif" alt=""><br>To help you really quickly create the required <strong>YAML</strong> definition file for <strong>Kubernetes</strong>, start typing the required key and invoke <strong>Smart Completion</strong>. The new plugin will auto-complete all the required keys from all the levels below.</p><p>Code completion now works for <strong>YAML Kubernetes resource</strong> files. The <strong>Kubernetes</strong> plugin offers the correct values you can use within the resources.</p><h2 id="Kubernetes-Live-Template"><a href="#Kubernetes-Live-Template" class="headerlink" title="Kubernetes Live Template"></a>Kubernetes Live Template</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesLiveTemplate.gif" alt=""><br>The <strong>Kubernetes</strong> plugin has a built-in <strong>Live Template</strong> that allows you to quickly create the type of <strong>YAML Kubernetes resource</strong> file that you need. The new plugin now contains several predefined <strong>Kubernetes</strong> templates, and you can invoke the necessary <strong>Live Template</strong> by typing its abbreviation.</p><h2 id="Navigation-in-YAML-Kubernetes-files"><a href="#Navigation-in-YAML-Kubernetes-files" class="headerlink" title="Navigation in YAML Kubernetes files"></a>Navigation in YAML Kubernetes files</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesNavigation.gif" alt=""><br>Use gutter icons to quickly navigate between a label definition and a label selector.</p><p>Jump from a label selector to a label definition inside the editor if there is a direct match for a label, both for the key and for the value.</p><h2 id="Inspections-for-YAML-Kubernetes-files"><a href="#Inspections-for-YAML-Kubernetes-files" class="headerlink" title="Inspections for YAML Kubernetes files"></a>Inspections for YAML Kubernetes files</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesInspection1.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesInspection2.png" alt=""><br>The Kubernetes plugin will alert you whenever you select deprecated Kubernetes properties.</p><p>Also, you’ll get a warning for YAML files if you try to use properties that are not applicable for the specified elements with the applied apiVersion and kind of field.</p><h2 id="Quick-fixes-for-YAML-Kubernetes-files"><a href="#Quick-fixes-for-YAML-Kubernetes-files" class="headerlink" title="Quick-fixes for YAML Kubernetes files"></a>Quick-fixes for YAML Kubernetes files</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesQuickFix1.gif" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesQuickFix2.gif" alt=""><br>The plugin highlights elements with missing keys in YAML Kubernetes resource definition files and provides a quick-fix to add the required keys.</p><p>Also, you’ll get a warning about redundant keys. Use the provided quick-fix to remove redundant keys in YAML Kubernetes resource files.</p><p>The new plugin also detects non-editable keys in YAML Kubernetes resource files and highlights them in the editor. Note that there’s an easy way to remove all such read-only keys from the current YAML file – with a handy quick-fix.</p><h2 id="Support-for-JSON-Kubernetes-resource-files"><a href="#Support-for-JSON-Kubernetes-resource-files" class="headerlink" title="Support for JSON Kubernetes resource files"></a>Support for JSON Kubernetes resource files</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesJSONCodeCompletion.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesQuickDocumentation.png" alt=""><br>The new plugin provides some support for JSON Kubernetes resource files based on the JSON schema functionality.</p><p>Code completion and the Quick Documentation Popup are also available for JSON Kubernetes resource files.</p><h2 id="Inspections-for-JSON-Kubernetes-resource-files"><a href="#Inspections-for-JSON-Kubernetes-resource-files" class="headerlink" title="Inspections for JSON Kubernetes resource files"></a>Inspections for JSON Kubernetes resource files</h2><p><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesJSONInspection1.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesJSONInspection2.png" alt=""><br><img src="https://www.jetbrains.com/idea/whatsnew/img/2018.1/KubernetesJSONInspection3.png" alt=""><br>The new Kubernetes plugin validates the current keys according to the JSON schema and alerts you when incorrect properties or values are used.</p><p>Also, the plugin highlights elements with any missing required properties and then advises you about the appropriate properties that should be added.</p><p>Duplicated properties are also detected in JSON Kubernetes files.</p>]]></content>
    
    <summary type="html">
    
      IDEA 2018.1 更新内容 更新时间2018.1 Mar 27
    
    </summary>
    
      <category term="软件" scheme="http://localhost/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="IDE" scheme="http://localhost/tags/IDE/"/>
    
      <category term="IDEA" scheme="http://localhost/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>学习清单</title>
    <link href="http://localhost/2018/03/28/%E5%AD%A6%E4%B9%A0%E6%B8%85%E5%8D%95/"/>
    <id>http://localhost/2018/03/28/学习清单/</id>
    <published>2018-03-28T12:06:38.203Z</published>
    <updated>2018-03-28T12:09:19.415Z</updated>
    
    <content type="html"><![CDATA[<ol><li>JDK9</li><li>JDK10</li><li>Google AutoValue</li><li>Weex</li><li>Kotlin</li></ol>]]></content>
    
    <summary type="html">
    
      小米自己的学习清单
    
    </summary>
    
      <category term="学习" scheme="http://localhost/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://localhost/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JDK各个版本的新特性</title>
    <link href="http://localhost/2018/03/27/Java/JDK%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://localhost/2018/03/27/Java/JDK各个版本的新特性/</id>
    <published>2018-03-27T06:11:56.376Z</published>
    <updated>2018-03-31T01:43:25.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK1-5新特性："><a href="#JDK1-5新特性：" class="headerlink" title="JDK1.5新特性："></a>JDK1.5新特性：</h1><ol><li><p>自动装箱与拆箱：</p><blockquote><p><strong>自动装箱的过程</strong>：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中。</p><p><strong>自动拆箱的过程</strong>：每当需要一个值时，被装箱对象中的值就被自动地提取出来，没必要再去调用<code>intValue()</code>和<code>doubleValue()</code>方法。</p><p><strong>自动装箱</strong>，只需将该值赋给一个类型包装器引用，java会自动创建一个对象。</p><p><strong>自动拆箱</strong>，只需将该对象值赋给一个基本类型即可。</p><p>java——类的包装器</p><p>类型包装器有：<code>Double</code>,<code>Float</code>,<code>Long</code>,<code>Integer</code>,<code>Short</code>,<code>Character</code>和<code>Boolean</code></p></blockquote></li><li><p>枚举</p><blockquote><p>把集合里的对象元素一个一个提取出来。枚举类型使代码更具可读性，理解清晰，易于维护。枚举类型是强类型的，从而保证了系统安全性。而以类的静态字段实现的类似替代模型，不具有枚举的简单性和类型安全性。</p><p><strong>简单的用法</strong>：JavaEnum简单的用法一般用于代表一组常用常量，可用来代表一类相同类型的常量值。</p><p><strong>复杂用法</strong>：Java为枚举类型提供了一些内置的方法，同事枚举常量还可以有自己的方法。可以很方便的遍历枚举对象。</p></blockquote></li><li><p>静态导入</p><blockquote><p>通过使用 <code>import static</code>，就可以不用指定 <code>Constants</code> 类名而直接使用静态成员，包括静态方法。</p><p><code>import xxxx</code> 和 <code>import static xxxx</code>的区别是前者一般导入的是类文件如<code>import java.util.Scanner;</code>后者一般是导入静态的方法，<code>import static java.lang.System.out</code>。</p></blockquote></li><li><p>可变参数（Varargs）</p><blockquote><p>可变参数的简单语法格式为：<br><code>methodName([argumentList], dataType...argumentName);</code></p></blockquote></li><li><p>内省（Introspector）</p><blockquote><p>是 Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性<code>name</code>,那我们可以通过<code>getName,setName</code>来得到其值或者设置新 的值。通过<code>getName/setName</code>来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的<code>getter /setter</code>方法，通过这些API可以使你不需要了解这个规则（但你最好还是要搞清楚），这些API存放于包<code>java.beans</code>中。</p><p>一般的做法是通过类<code>Introspector</code>来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器 （PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来 调用这些方法。</p></blockquote></li><li><p>泛型(Generic)</p><blockquote><p>C++ 通过模板技术可以指定集合的元素类型，而Java在1.5之前一直没有相对应的功能。一个集合可以放任何类型的对象，相应地从集合里面拿对象的时候我们也 不得不对他们进行强制得类型转换。猛虎引入了泛型，它允许指定集合里元素的类型，这样你可以得到强类型在编译时刻进行类型检查的好处。</p></blockquote></li><li><p>For-Each循环</p><blockquote><p>For-Each循环得加入简化了集合的遍历。假设我们要遍历一个集合对其中的元素进行一些处理。</p></blockquote></li></ol><h1 id="JDK-1-6新特性（转）"><a href="#JDK-1-6新特性（转）" class="headerlink" title="JDK 1.6新特性（转）"></a>JDK 1.6新特性（转）</h1><p>有关JDK1.6的新特性reamerit的博客文章已经说的很详细了。</p><ol><li><p><code>Desktop</code>类和<code>SystemTray</code>类</p><blockquote><p>在JDK6中 ,AWT新增加了两个类:<code>Desktop</code>和<code>SystemTray</code>。</p><p>前者可以用来打开系统默认浏览器浏览指定的URL,打开系统默认邮件客户端给指定的邮箱发邮件,用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件),用系统默认的打印机打印文档;</p><p>后者可以用来在系统托盘区创建一个托盘程序.</p></blockquote></li><li><p>使用JAXB2来实现对象与XML之间的映射</p><blockquote><p>JAXB是Java Architecture for XML Binding的缩写，可以将一个Java对象转变成为XML格式，反之亦然。</p><p>我们把对象与关系数据库之间的映射称为ORM, 其实也可以把对象与XML之间的映射称为OXM(Object XML Mapping). 原来JAXB是Java EE的一部分，在JDK6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。JDK6中自带的这个JAXB版本是2.0, 比起1.0(JSR 31)来，JAXB2(JSR 222)用JDK5的新特性Annotation来标识要作绑定的类和属性等，这就极大简化了开发的工作量。</p><p>实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外,JAXB2在底层是用StAX(JSR 173)来处理XML文档。除了JAXB之外，我们还可以通过XMLBeans和Castor等来实现同样的功能。</p></blockquote></li><li><p>理解StAX</p><blockquote><p>StAX(JSR 173)是JDK6.0中除了DOM和SAX之外的又一种处理XML文档的API。</p><p>StAX 的来历 ：在JAXP1.3(JSR 206)有两种处理XML文档的方法:DOM(Document Object Model)和SAX(Simple API for XML).</p><p>由于JDK6.0中的JAXB2(JSR 222)和JAX-WS 2.0(JSR 224)都会用到StAX所以Sun决定把StAX加入到JAXP家族当中来，并将JAXP的版本升级到1.4(JAXP1.4是JAXP1.3的维护版 本). JDK6里面JAXP的版本就是1.4. 。</p><p>StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API.StAX通过提供一种基于事件迭代器(Iterator)的API让 程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件 然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；</p><p>SAX也是基于事件处理xml文档，但却 是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM 采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。</p></blockquote></li><li><p>使用Compiler API</p><blockquote><p>现在我 们可以用JDK6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。</p><p>这个特性对于某些需要用到动态编译的应用程序相当有用， 比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件，当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去 做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译,而且是跨平台的。</p></blockquote></li><li><p>轻量级Http Server API</p><blockquote><p>JDK6 提供了一个简单的Http Server API,据此我们可以构建自己的嵌入式Http Server,它支持Http和Https协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现,程序员必须自己实现<code>HttpHandler</code>接口,HttpServer会调用<code>HttpHandler</code>实现类的回调方法来处理客户端请求,在 这里,我们把一个Http请求和它的响应称为一个交换,包装成<code>HttpExchange</code>类,HttpServer负责将<code>HttpExchange</code>传给 <code>HttpHandler</code>实现类的回调方法.</p></blockquote></li><li><p>插入式注解处理API(Pluggable Annotation Processing API)</p><blockquote><p>插入式注解处理API(JSR 269)提供一套标准API来处理Annotations(JSR 175)</p><p>实 际上JSR 269不仅仅用来处理Annotation,我觉得更强大的功能是它建立了Java 语言本身的一个模型,它把method, package, constructor, type, variable, enum, annotation等Java语言元素映射为Types和Elements(两者有什么区别?), 从而将Java语言的语义映射成为对象, 我们可以在javax.lang.model包下面可以看到这些类. 所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境.</p><p>JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器的一个插件,所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码,编译器会再调用一次Annotation Processor,如果第二次处理还有新代码产生,就会接着调用Annotation Processor,直到没有新代码产生为止.每执行一次process()方法被称为一个”round”,这样整个Annotation processing过程可以看作是一个round的序列.</p><p>JSR 269主要被设计成为针对Tools或者容器的API. 举个例子,我们想建立一套基于Annotation的单元测试框架(如TestNG),在测试类里面用Annotation来标识测试期间需要执行的测试方法。</p></blockquote></li><li><p>用Console开发控制台程序</p><blockquote><p>JDK6 中提供了java.io.Console 类专用来访问基于字符的控制台设备. 你的程序如果要与Windows下的cmd或者Linux下的Terminal交互,就可以用Console类代劳. 但我们不总是能得到可用的Console, 一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用. 如果JVM是在交互式命令行(比如Windows的cmd)中启动的,并且输入输出没有重定向到另外的地方,那么就可以得到一个可用的Console实 例.</p></blockquote></li><li><p>对脚本语言的支持如: ruby, groovy, javascript.</p></li><li><p>Common Annotations</p></li></ol><p>Common annotations原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中.<br>随 着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB,Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务）, 如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性.</p><p>下面列举出Common Annotations 1.0里面的10个Annotations Common Annotations<br>Annotation Retention Target Description<br>Generated Source <code>ANNOTATION_TYPE</code>, <code>CONSTRUCTOR</code>, <code>FIELD</code>, <code>LOCAL_VARIABLE</code>, <code>METHOD</code>, <code>PACKAGE</code>, <code>PARAMETER</code>, <code>TYPE</code> 用于标注生成的源代码<br>Resource Runtime <code>TYPE</code>, <code>METHOD</code>, <code>FIELD</code> 用于标注所依赖的资源,容器据此注入外部资源依赖，有基于字段的注入和基于setter方法的注入两种方式<br>Resources Runtime TYPE 同时标注多个外部依赖，容器会把所有这些外部依赖注入<br>PostConstruct Runtime METHOD 标注当容器注入所有依赖之后运行的方法，用来进行依赖注入后的初始化工作，只有一个方法可以标注为PostConstruct<br>PreDestroy Runtime METHOD 当对象实例将要被从容器当中删掉之前，要执行的回调方法要标注为PreDestroy RunAs Runtime TYPE 用于标注用什么安全角色来执行被标注类的方法，这个安全角色必须和Container 的Security角色一致的。RolesAllowed Runtime TYPE, METHOD 用于标注允许执行被标注类或方法的安全角色，这个安全角色必须和Container 的Security角色一致的<br>PermitAll Runtime TYPE, METHOD 允许所有角色执行被标注的类或方法<br>DenyAll Runtime TYPE, METHOD 不允许任何角色执行被标注的类或方法，表明该类或方法不能在Java EE容器里面运行<br>DeclareRoles Runtime TYPE 用来定义可以被应用程序检验的安全角色，通常用isUserInRole来检验安全角色</p><p>注意:</p><ol><li><p>RolesAllowed,PermitAll,DenyAll不能同时应用到一个类或方法上</p></li><li><p>标注在方法上的RolesAllowed,PermitAll,DenyAll会覆盖标注在类上的RolesAllowed,PermitAll,DenyAll</p></li><li><p>RunAs,RolesAllowed,PermitAll,DenyAll和DeclareRoles还没有加到Java SE 6.0上来</p></li><li><p>处理以上Annotations的工作是由Java EE容器来做, Java SE 6.0只是包含了上面表格的前五种Annotations的定义类,并没有包含处理这些Annotations的引擎,这个工作可以由Pluggable Annotation Processing API(JSR 269)来做</p></li></ol><p>改动的地方最大的就是java GUI界面的显示了，JDK6.0（也就是JDK1.6）支持最新的windows vista系统的Windows Aero视窗效果，而JDK1.5不支持！！！<br>你要在vista环境下编程的话最好装jdk6.0，否则它总是换到windows basic视窗效果.</p><h1 id="JDK-1-7-新特性-（转）"><a href="#JDK-1-7-新特性-（转）" class="headerlink" title="JDK 1.7 新特性 （转）"></a>JDK 1.7 新特性 （转）</h1><ol><li><p>switch中可以使用字串了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"test"</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"test"</span> :</span><br><span class="line">        System.out.println(<span class="string">"test"</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"test1"</span> :</span><br><span class="line">        System.out.println(<span class="string">"test1"</span>);</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        System.out.println(<span class="string">"break"</span>);</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>“<code>&lt;&gt;</code>“这个玩意儿的运用<code>List tempList = new ArrayList&lt;&gt;();</code> 即泛型实例化类型自动推断。 </p></li><li><p>语法上支持集合，而不一定是数组 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List piDigits = [ <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span> ];</span><br></pre></td></tr></table></figure></li><li><p>新增一些取环境信息的工具方法 </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File System.getJavaIoTempDir() <span class="comment">// IO临时文件夹 </span></span><br><span class="line"></span><br><span class="line">File System.getJavaHomeDir() <span class="comment">// JRE的安装目录 </span></span><br><span class="line"></span><br><span class="line">File System.getUserHomeDir() <span class="comment">// 当前用户目录 </span></span><br><span class="line"></span><br><span class="line">File System.getUserDir() <span class="comment">// 启动java进程时所在的目录 </span></span><br><span class="line"></span><br><span class="line">.......</span><br></pre></td></tr></table></figure><ol><li><p>Boolean类型反转，空指针安全,参与位运算 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Boolean Booleans.negate(Boolean booleanObj) </span><br><span class="line"></span><br><span class="line">True =&gt; False , False =&gt; True, Null =&gt; Null </span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> Booleans.and(<span class="keyword">boolean</span>[] array) </span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> Booleans.or(<span class="keyword">boolean</span>[] array) </span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> Booleans.xor(<span class="keyword">boolean</span>[] array) </span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> Booleans.and(Boolean[] array) </span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> Booleans.or(Boolean[] array) </span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> Booleans.xor(Boolean[] array)</span><br></pre></td></tr></table></figure></li><li><p>两个char间的equals </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> Character.equalsIgnoreCase(<span class="keyword">char</span> ch1, <span class="keyword">char</span> ch2)</span><br></pre></td></tr></table></figure></li></ol><p>7，安全的加减乘除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Math.safeToInt(<span class="keyword">long</span> value) </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Math.safeNegate(<span class="keyword">int</span> value) </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> Math.safeSubtract(<span class="keyword">long</span> value1, <span class="keyword">int</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> Math.safeSubtract(<span class="keyword">long</span> value1, <span class="keyword">long</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Math.safeMultiply(<span class="keyword">int</span> value1, <span class="keyword">int</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> Math.safeMultiply(<span class="keyword">long</span> value1, <span class="keyword">int</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> Math.safeMultiply(<span class="keyword">long</span> value1, <span class="keyword">long</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> Math.safeNegate(<span class="keyword">long</span> value) </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Math.safeAdd(<span class="keyword">int</span> value1, <span class="keyword">int</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> Math.safeAdd(<span class="keyword">long</span> value1, <span class="keyword">int</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> Math.safeAdd(<span class="keyword">long</span> value1, <span class="keyword">long</span> value2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Math.safeSubtract(<span class="keyword">int</span> value1, <span class="keyword">int</span> value2)</span><br></pre></td></tr></table></figure></p><p>1.对Java集合（Collections）的增强支持<br>在JDK1.7之前的版本中，Java集合容器中存取元素的形式如下：<br>以List、Set、Map集合容器为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建List接口对象</span></span><br><span class="line">List list=<span class="keyword">new</span> ArrayList (); </span><br><span class="line">list.add(<span class="string">"item"</span>); <span class="comment">//用add()方法获取对象 </span></span><br><span class="line">String Item=list.get(<span class="number">0</span>); <span class="comment">//用get()方法获取对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Set接口对象</span></span><br><span class="line">Set set=<span class="keyword">new</span> HashSet (); </span><br><span class="line">set.add(<span class="string">"item"</span>); <span class="comment">//用add()方法添加对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Map接口对象</span></span><br><span class="line">Map map=<span class="keyword">new</span> HashMap (); </span><br><span class="line">map.put(<span class="string">"key"</span>,<span class="number">1</span>); <span class="comment">//用put()方法添加对象 </span></span><br><span class="line"><span class="keyword">int</span> value=map.get(<span class="string">"key"</span>);</span><br></pre></td></tr></table></figure></p><p>在JDK1.7中，摒弃了Java集合接口的实现类，如：<code>ArrayList</code>、<code>HashSet</code>和<code>HashMap</code>。而是直接采用[]、{}的形式存入对象，采用[]的形式按照索引、键值来获取集合中的对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List list=[<span class="string">"item"</span>]; <span class="comment">//向List集合中添加元素 </span></span><br><span class="line">String item=list[<span class="number">0</span>]; <span class="comment">//从List集合中获取元素</span></span><br><span class="line">Set set=&#123;<span class="string">"item"</span>&#125;; <span class="comment">//向Set集合对象中添加元素</span></span><br><span class="line">Map map=&#123;<span class="string">"key"</span>:<span class="number">1</span>&#125;; <span class="comment">//向Map集合中添加对象 </span></span><br><span class="line"><span class="keyword">int</span> value=map[<span class="string">"key"</span>]; <span class="comment">//从Map集合中获取对象</span></span><br></pre></td></tr></table></figure><p>2.在Switch中可用String<br>在之前的版本中是不支持在Switch语句块中用String类型的数据的，这个功能在C#语言中早已被支持，好在JDK1.7中加入了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"test"</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"test"</span> :</span><br><span class="line">        System.out.println(<span class="string">"test"</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"test1"</span> :</span><br><span class="line">        System.out.println(<span class="string">"test1"</span>);</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        System.out.println(<span class="string">"break"</span>);</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><p>数值可加下划线<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> one_million = <span class="number">1_000_000</span>;</span><br></pre></td></tr></table></figure></li><li><p>支持二进制文字<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> binary = <span class="number">0b1001_1001</span>;</span><br></pre></td></tr></table></figure></li><li><p>简化了可变参数方法的调用<br>当程序员试图使用一个不可具体化的可变参数并调用一个varargs（可变）方法时，编辑器会生成一个“非安全操作”的警告。<br>原文：<a href="http://iteye.blog.163.com/blog/static/18630809620127136516641/?suggestedreading&amp;wumii" target="_blank" rel="noopener">http://iteye.blog.163.com/blog/static/18630809620127136516641/?suggestedreading&amp;wumii</a></p></li></ol><h1 id="Java8-十大新特性"><a href="#Java8-十大新特性" class="headerlink" title="Java8 十大新特性"></a>Java8 十大新特性</h1><p>本教程将Java8的新特新逐一列出，并将使用简单的代码示例来指导你如何使用默认接口方法，<strong>lambda</strong>表达式，方法引用以及多重Annotation，之后你将会学到最新的API上的改进，比如流，函数式接口，Map以及全新的日期API</p><p>“Java is still not dead—and people are starting to figure that out.”<br>本教程将用带注释的简单代码来描述新特性，你将看不到大片吓人的文字。</p><p>一、接口的默认方法<br>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下：<br> 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。<br>代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">formula.calculate(<span class="number">100</span>); <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);  <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure></p><p>文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。<br>译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。<br>二、Lambda 表达式<br>首先看看在老版本的Java中是如何排列字符串的：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator () &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。<br>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123; </span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure></p><p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure></p><p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来： </p><p>三、函数式接口<br>Lambda 表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。<br>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。<br>示例如下：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span> </span>&#123; </span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>; </span><br><span class="line">&#125; </span><br><span class="line">Converter converter = (from) -&gt; Integer.valueOf(from); </span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>); </span><br><span class="line">System.out.println(converted); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></p><p>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。<br>译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。<br>四、方法与构造函数引用<br>前一节中的代码还可以通过静态方法引用来表示：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter converter = Integer::valueOf; </span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>); </span><br><span class="line">System.out.println(converted); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></p><p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">converter = something::startsWith; </span><br><span class="line">String converted = converter.convert(<span class="string">"Java"</span>); </span><br><span class="line">System.out.println(converted); <span class="comment">// "J"</span></span><br></pre></td></tr></table></figure></p><p>接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    String firstName; </span><br><span class="line">    String lastName;</span><br><span class="line">    Person() &#123;&#125;</span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们指定一个用来创建Person对象的对象工厂接口：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PersonFactory personFactory = Person::<span class="keyword">new</span>; </span><br><span class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</span><br></pre></td></tr></table></figure></p><p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。<br>五、Lambda 作用域<br>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。<br>六、访问局部变量<br>我们可以直接在lambda表达式中访问外层的局部变量：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>; </span><br><span class="line">Converter stringConverter = (from) -&gt; String.valueOf(from + num);</span><br><span class="line">stringConverter.convert(<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>; </span><br><span class="line">Converter stringConverter = (from) -&gt; String.valueOf(from + num);</span><br><span class="line">stringConverter.convert(<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>; </span><br><span class="line">Converter stringConverter = (from) -&gt; String.valueOf(from + num); </span><br><span class="line">num = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><p>在lambda表达式中试图修改num同样是不允许的。<br>七、访问对象字段与静态变量<br>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum; </span><br><span class="line">    <span class="keyword">int</span> outerNum;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Converter stringConverter1 = (from) -&gt; &#123; </span><br><span class="line">            outerNum = <span class="number">23</span>; </span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from); </span><br><span class="line">        &#125;;</span><br><span class="line">        Converter stringConverter2 = (from) -&gt; &#123; </span><br><span class="line">            outerStaticNum = <span class="number">72</span>; </span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from); </span><br><span class="line">        &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>八、访问接口的默认方法<br>还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。<br>Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt( a * <span class="number">100</span>); </span><br><span class="line">Built-in Functional Interfaces</span><br></pre></td></tr></table></figure></p><p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。<br>Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。<br>Predicate接口<br>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Predicate predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line">predicate.test(<span class="string">"foo"</span>); <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">"foo"</span>); <span class="comment">// false</span></span><br><span class="line">Predicate nonNull = Objects::nonNull; </span><br><span class="line">Predicate isNull = Objects::isNull;</span><br><span class="line">Predicate isEmpty = String::isEmpty; </span><br><span class="line">Predicate isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure></p><p>Function 接口<br>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：<br>复制代码 代码如下:</p><p>Function toInteger = Integer::valueOf;<br>Function backToString = toInteger.andThen(String::valueOf);<br>backToString.apply(“123”);     // “123”</p><p>Supplier 接口<br>Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数<br>复制代码 代码如下:</p><p>Supplier personSupplier = Person::new;<br>personSupplier.get();   // new Person</p><p>Consumer 接口<br>Consumer 接口表示执行在单个参数上的操作。<br>复制代码 代码如下:</p><p>Consumer greeter = (p) -&gt; System.out.println(“Hello, “ + p.firstName);<br>greeter.accept(new Person(“Luke”, “Skywalker”));</p><p>Comparator 接口<br>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：<br>复制代码 代码如下:</p><p>Comparator comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);<br>Person p1 = new Person(“John”, “Doe”);<br>Person p2 = new Person(“Alice”, “Wonderland”);<br>comparator.compare(p1, p2);             // &gt; 0<br>comparator.reversed().compare(p1, p2);  // &lt; 0</p><p>Optional 接口<br>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：<br>Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。<br>复制代码 代码如下:</p><p>Optional optional = Optional.of(“bam”);<br>optional.isPresent();           // true<br>optional.get();                 // “bam”<br>optional.orElse(“fallback”);    // “bam”<br>optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // “b”</p><p>Stream 接口<br>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。 Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。<br>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">stringCollection.add(<span class="string">"ddd2"</span>); </span><br><span class="line">stringCollection.add(<span class="string">"aaa2"</span>); </span><br><span class="line">stringCollection.add(<span class="string">"bbb1"</span>); </span><br><span class="line">stringCollection.add(<span class="string">"aaa1"</span>); </span><br><span class="line">stringCollection.add(<span class="string">"bbb3"</span>); </span><br><span class="line">stringCollection.add(<span class="string">"ccc"</span>); </span><br><span class="line">stringCollection.add(<span class="string">"bbb2"</span>); </span><br><span class="line">stringCollection.add(<span class="string">"ddd1"</span>);</span><br></pre></td></tr></table></figure></p><p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：<br>Filter 过滤<br>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stringCollection.stream().filter((s) -&gt; s.startsWith(<span class="string">"a"</span>)).forEach(System.out::println); </span><br><span class="line"><span class="comment">// "aaa2", "aaa1"</span></span><br></pre></td></tr></table></figure></p><p>Sort 排序<br>排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stringCollection.stream().sorted().filter((s) -&gt; s.startsWith(<span class="string">"a"</span>)).forEach(System.out::println);</span><br><span class="line"><span class="comment">// "aaa1", "aaa2"</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(stringCollection); </span><br><span class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></span><br></pre></td></tr></table></figure></p><p>Map 映射<br>中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stringCollection.stream().map(String::toUpperCase).sorted((a, b) -&gt; b.compareTo(a)).forEach(System.out::println);</span><br><span class="line"><span class="comment">// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"</span></span><br></pre></td></tr></table></figure></p><p>Match 匹配<br>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> anyStartsWithA = stringCollection.stream().anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line">System.out.println(anyStartsWithA); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> allStartsWithA = stringCollection.stream().allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line">System.out.println(allStartsWithA); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> noneStartsWithZ = stringCollection.stream().noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</span><br><span class="line">System.out.println(noneStartsWithZ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>Count 计数<br>计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> startsWithB = stringCollection.stream().filter((s) -&gt; s.startsWith(<span class="string">"b"</span>)).count();</span><br><span class="line">System.out.println(startsWithB); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>Reduce 规约<br>这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional reduced = stringCollection.stream() .sorted().reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></span><br></pre></td></tr></table></figure></p><p>并行Streams<br>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。<br>下面的例子展示了是如何通过并行Stream来提升性能：<br>首先我们创建一个没有重复元素的大表：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">1000000</span>; </span><br><span class="line">List values = <span class="keyword">new</span> ArrayList&lt;&gt;(max); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123; </span><br><span class="line">    UUID uuid = UUID.randomUUID(); </span><br><span class="line">    values.add(uuid.toString()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们计算一下排序这个Stream要耗时多久，<br>串行排序：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"sequential sort took: %d ms"</span>, millis));</span><br><span class="line"><span class="comment">// 串行耗时: 899 ms</span></span><br></pre></td></tr></table></figure></p><p>并行排序：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"parallel sort took: %d ms"</span>, millis));</span><br><span class="line"><span class="comment">// 并行排序耗时: 472 ms</span></span><br></pre></td></tr></table></figure></p><p>上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。<br>Map<br>前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。<br>复制代码 代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map map = new HashMap&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    map.putIfAbsent(i, &quot;val&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">map.forEach((id, val) -&gt; System.out.println(val));</span><br></pre></td></tr></table></figure></p><p>以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。<br>下面的例子展示了map上的其他有用的函数：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num); </span><br><span class="line">map.get(<span class="number">3</span>); <span class="comment">// val33</span></span><br><span class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</span><br><span class="line">map.containsKey(<span class="number">9</span>); <span class="comment">// false</span></span><br><span class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">"val"</span> + num);</span><br><span class="line">map.containsKey(<span class="number">23</span>); <span class="comment">// true</span></span><br><span class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">"bam"</span>);</span><br><span class="line">map.get(<span class="number">3</span>); <span class="comment">// val33</span></span><br></pre></td></tr></table></figure></p><p>接下来展示如何在Map里删除一个键值全都匹配的项：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.remove(<span class="number">3</span>, <span class="string">"val3"</span>); </span><br><span class="line">map.get(<span class="number">3</span>); <span class="comment">// val33</span></span><br><span class="line">map.remove(<span class="number">3</span>, <span class="string">"val33"</span>);</span><br><span class="line">map.get(<span class="number">3</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><p>另外一个有用的方法：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">"not found"</span>); <span class="comment">// not found</span></span><br></pre></td></tr></table></figure></p><p>对Map的元素做合并也变得很容易了：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.merge(<span class="number">9</span>, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue)); </span><br><span class="line">map.get(<span class="number">9</span>); <span class="comment">// val9</span></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>); <span class="comment">// val9concat</span></span><br></pre></td></tr></table></figure></p><p>Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。<br>九、Date API<br>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：<br>Clock 时钟<br>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone(); </span><br><span class="line"><span class="keyword">long</span> millis = clock.millis();</span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);<span class="comment">// legacy java.util.Date</span></span><br></pre></td></tr></table></figure></p><p>Timezones 时区<br>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ZoneId.getAvailableZoneIds()); </span><br><span class="line"><span class="comment">// prints all available timezone ids</span></span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></span><br></pre></td></tr></table></figure></p><p>LocalTime 本地时间<br>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1); </span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line">System.out.println(now1.isBefore(now2)); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line">System.out.println(hoursBetween); <span class="comment">// -3</span></span><br><span class="line">System.out.println(minutesBetween);  <span class="comment">// -239</span></span><br></pre></td></tr></table></figure></p><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>); </span><br><span class="line">System.out.println(late);  <span class="comment">// 23:59:59</span></span><br><span class="line">DateTimeFormatter germanFormatter = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).withLocale(Locale.GERMAN);</span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime); <span class="comment">// 13:37</span></span><br></pre></td></tr></table></figure></p><p>LocalDate 本地日期<br>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now(); </span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS); </span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</span><br><span class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek); <span class="comment">// FRIDAY</span></span><br></pre></td></tr></table></figure></p><p>从字符串解析一个LocalDate类型和解析LocalTime一样简单：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM).withLocale(Locale.GERMAN);</span><br><span class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</span><br><span class="line">System.out.println(xmas);  <span class="comment">// 2014-12-24</span></span><br></pre></td></tr></table></figure></p><p>LocalDateTime 本地日期时间<br>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);  <span class="comment">// WEDNESDAY</span></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month); <span class="comment">// DECEMBER</span></span><br><span class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay); <span class="comment">// 1439</span></span><br></pre></td></tr></table></figure></p><p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = sylvester.atZone(ZoneId.systemDefault()).toInstant();</span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);  <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br></pre></td></tr></table></figure></p><p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>);</span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);  <span class="comment">// Nov 03, 2014 - 07:13</span></span><br></pre></td></tr></table></figure></p><p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。<br>关于时间日期格式的详细信息：<a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener">http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html</a><br>十、Annotation 注解<br>在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。<br>首先定义一个包装类Hints注解用来放置一组具体的Hint注解：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Hints &#123; </span><br><span class="line">    Hint[] value(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repeatable</span>(Hints.class)</span><br><span class="line"><span class="meta">@interface</span> Hint &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。<br>例 1: 使用包装类当容器来存多个注解（老方法）<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hints</span>(&#123;<span class="meta">@Hint</span>(<span class="string">"hint1"</span>), <span class="meta">@Hint</span>(<span class="string">"hint2"</span>)&#125;) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>例 2：使用多重注解（新方法）<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint1"</span>) </span><br><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint2"</span>) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hint hint = Person.class.getAnnotation(Hint.class); </span><br><span class="line">System.out.println(hint); <span class="comment">// null</span></span><br><span class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</span><br><span class="line">System.out.println(hints1.value().length); <span class="comment">// 2</span></span><br><span class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</span><br><span class="line">System.out.println(hints2.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。<br>另外Java 8的注解还增加到两种新的target上了：<br>复制代码 代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;) </span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      对于很多刚接触java语言的初学者来说，要了解一门语言，最好的方式就是要能从基础的版本进行了解，升级的过程，以及升级的新特性，这样才能循序渐进的学好一门语言。今天先为大家介绍一下 JDK5 版本到 JDK10 版本的特性。希望能给予帮助。
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
      <category term="Base64" scheme="http://localhost/tags/Base64/"/>
    
  </entry>
  
  <entry>
    <title>JSP九大内置对象及四个作用域</title>
    <link href="http://localhost/2018/03/27/Java/JSP%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%9B%9B%E4%B8%AA%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://localhost/2018/03/27/Java/JSP九大内置对象及四个作用域/</id>
    <published>2018-03-27T05:26:47.373Z</published>
    <updated>2018-03-27T05:40:46.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="九大对象"><a href="#九大对象" class="headerlink" title="九大对象"></a>九大对象</h2><p>　　内置对象（又叫隐含对象，有9个内置对象）:不需要预先声明就可以在脚本代码和表达式中随意使用　　</p><ol><li><p>out:</p><blockquote><p>javax.servlet.jsp.JspWriter类型，代表输出流的对象。作用域为page（页面执行期）</p></blockquote></li><li><p>request：</p><blockquote><p>javax.servlet.ServletRequest的子类型，此对象封装了由WEB浏览器或其它客户端生成地HTTP请求的细节（参数，属性，头标和数据）。作用域为request(用户请求期）。方法由可查看API</p></blockquote></li><li><p>response：</p><blockquote><p>javax.servlet.ServletResponse的子类型，此对象封装了返回到HTTP客户端的输出，向页面作者提供设置响应头标和状态码的方式。经常用来设置HTTP标题，添加cookie，设置响应内容的类型和状态，发送HTTP重定向和编码URL。作用域为page（页面执行期）。</p></blockquote></li><li><p>pageContext：</p><blockquote><p>javax.servlet.jsp.PageContext（抽象类）类型，作用域为page（页面执行期）。此对象提供所有四个作用域层次的属性查询和修改能力，它也提供了转发请求到其它资源和包含其他资源的方法：<br>　　该对象的方法都是抽象方法</p></blockquote></li><li><p>session：javax.servlet.http.HttpSession类型，主要用于跟踪对话。作用域session(会话期—）。<br>　　HttpSession是一个类似哈希表的与单一WEB浏览器会话相关的对象，它存在于HTTP请求之间，可以存储任<br>　　何类型的命名对象。<br>　　如果不需要在请求之间跟踪会话对象，可以通过在page指令中指定session=”false”<br>　　需要记住的是pageContext对象也可以与session.getAttribute(),session.setAttribute()一样的方式取得并设置会话属性。</p></li><li>application：javax.servlet.ServletContext类型，servlet的环境通过调用getServletConfig<br>　　().getContext()方法获得。作用域是application(整个程序运行期）。它提供了关于服务器版本，应用级初始化参数和应用内资源绝对路径，注册信息的方式</li><li>config：javax.servlet.ServletConfig,作用域为page（页面执行期）</li><li>exception:java.lang.Throwable,通过JSP错误页面中一个catch块已经益出但没有捕获的<br>　　java.lang.Throwable的任意实例，传向了errorPage的URI。作用域为page（页面执行期）。注意<br>　　exception只有在page指令中具有属性isErrorPage=”true”时才有效。</li><li>page:java.lang.Object类型，指向页面自身的方式。作用域为page（页面执行期）</li></ol><p>JSP中九大内置对象为：</p><table><thead><tr><th>名称</th><th>中文</th><th>类型</th><th>作用域</th></tr></thead><tbody><tr><td>request</td><td>请求对象</td><td>javax.servlet.ServletRequest</td><td>Request</td></tr><tr><td>response</td><td>响应对象</td><td>javax.servlet.SrvletResponse</td><td>Page</td></tr><tr><td>pageContext</td><td>页面上下文对象</td><td>javax.servlet.jsp.PageContext</td><td>Page</td></tr><tr><td>session</td><td>会话对象</td><td>javax.servlet.http.HttpSession</td><td>Session</td></tr><tr><td>application</td><td>应用程序对象</td><td>javax.servlet.ServletContext</td><td>Application</td></tr><tr><td>out</td><td>输出对象</td><td>javax.servlet.jsp.JspWriter</td><td>Page</td></tr><tr><td>config</td><td>配置对象</td><td>javax.servlet.ServletConfig</td><td>Page</td></tr><tr><td>page</td><td>页面对象</td><td>javax.lang.Object</td><td>Page</td></tr><tr><td>exception</td><td>例外对象</td><td>javax.lang.Throwable</td><td>page</td></tr></tbody></table><p>　　request 对象代表的是来自客户端的请求，例如我们在FORM表单中填写的信息等，是最常用的对象常用的方法有：getParameter、getParameterNames 和getParameterValues 通过调用这几个方法来获取请求对象中所包含的参数的值。<br>　　response 对象代表的是对客户端的响应，也就是说可以通过response 对象来组织发送到客户端的数据。但是由于组织方式比较底层，所以不建议普通读者使用，需要向客户端发送文字时直接使用<br>　　pageContext 对象直译时可以称作“页面上下文”对象，代表的是当前页面运行的一些属性<br>　　常用的方法有 ：findAttribute、getAttribute、getAttributesScope 和getAttributeNamesInScope<br>　　一般情况下pageContext对象用到得也不是很多，只有在项目所面临的情况比较复杂的情况下，才会利用到页面属性来辅助处理。<br>　　session    对象代表服务器与客户端所建立的会话，当需要在不同的JSP页面中保留客户信息的情况下使用，比如在线购物、客户轨迹跟踪等。“session” 对象建立在cookie的基础上，所以使用时应注意判断一下客户端是否打开了cookie。常用的方法包括getId、 getValue、 getValueNames和putValue等。<br>　　概要<br>　　HTTP是无状态（stateless）协议；<br>　　Web Server 对每一个客户端请求都没有历史记忆；<br>　　Session用来保存客户端状态信息；<br>　　由Web Server 写入；<br>　　存于客户端；<br>　　客户端的每次访问都把上次的session记录传递给Web Server；<br>　　Web Server读取客户端提交的session来获取客户端的状态信息<br>　　application 对象负责提供应用程序在服务器中运行时的一些全局信息，常用的方法有getMimeType和getRealPath等。<br>　　out 对象代表了向客户端发送数据的对象，与“response” 对象不同，通过“out” 对象发送的内容将是浏览器需要显示的内容，是文本一级的，可以通过“out” 对象直接向客户端写一个由程序动态生成HTML文件。常用的方法除了pirnt和println之外，还包括clear、clearBuffer、 flush、getBufferSize和getRemaining，这是因为“out” 对象内部包含了一个缓冲区，所以需要一些对缓冲区进行操作的方法<br>　　“config” 对象提供一些配置信息，常用的方法有getInitParameter和getInitParameterNames，以获得Servlet初始化时的参数。<br>　　“page” 对象代表了正在运行的由JSP文件产生的类对象，不建议一般读者使用。<br>　　“exception” 对象则代表了JSP文件运行时所产生的例外对象，此对象不能在一般JSP文件中直接使用，而只能在使用了“&lt; page isErrorPage=”true “ &gt;”的JSP文件中使用四个作用域：　　</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>   何为作用域<br>　　先让我们看看效果：<br>　　大概流程是这样的，我们访问04-01/index.jsp的时候，分别对pageContext, request, session,<br>　　application四个作用域中的变量进行累加。（当然先判断这个变量是不是存在，如果变量不存在，则要把变量初始化成1。）计算完成后就从index.jsp执行forward跳转到test.jsp。在test.jsp里再进行一次累加，然后显示出这四个整数来。<br>　　从显示的结果来看，我们可以直观的得出结论：<br>　　page里的变量没法从index.jsp传递到test.jsp。只要页面跳转了，它们就不见了。<br>　　request里的变量可以跨越forward前后的两页。但是只要刷新页面，它们就重新计算了。<br>　　session和application里的变量一直在累加，开始还看不出区别，只要关闭浏览器，再次重启浏览器访问这页，session里的变量就重新计算了。 来源:考试大-Java认证<br>       application里的变量一直在累加，除非你重启tomcat，否则它会一直变大。<br>　　而作用域规定的是变量的有效期限。<br>　　如果把变量放到pageContext里，就说明它的作用域是page，它的有效范围只在当前jsp页面里。<br>　　从把变量放到pageContext开始，到jsp页面结束，你都可以使用这个变量。<br>　　如果把变量放到request里，就说明它的作用域是request，它的有效范围是当前请求周期。<br>　　所谓请求周期，就是指从http请求发起，到服务器处理结束，返回响应的整个过程。在这个过程中可能使用forward的方式跳转了多个jsp页面，在这些页面里你都可以使用这个变量。<br>　　如果把变量放到session里，就说明它的作用域是session，它的有效范围是当前会话。<br>　　所谓当前会话，就是指从用户打开浏览器开始，到用户关闭浏览器这中间的过程。这个过程可能包含多个请求响应。也就是说，只要用户不关浏览器，服务器就有办法知道这些请求是一个人发起的，整个过程被称为一个会话（session），而放到会话中的变量，就可以在当前会话的所有请求里使用。<br>　　如果把变量放到application里，就说明它的作用域是application，它的有效范围是整个应用。<br>　　整个应用是指从应用启动，到应用结束。我们没有说“从服务器启动，到服务器关闭”，是因为一个服务器可能部署多个应用，当然你关闭了服务器，就会把上面所有的应用都关闭了。<br>　　application作用域里的变量，它们的存活时间是最长的，如果不进行手工删除，它们就一直可以使用。<br>　　与上述三个不同的是，application里的变量可以被所有用户共用。如果用户甲的操作修改了application中的变量，用户乙访问时得到的是修改后的值。这在其他scope中都是不会发生的，page, request,session都是完全隔离的，无论如何修改都不会影响其他人的数据。<br>　　我们使用public Object getAttribute(String name)获得变量值，使用public void setAttribute(String name, Object value)将变量值保存到对应作用域中。举个pageContext的例子就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page</span></span><br><span class="line">Integer countPage = (Integer) pageContext.getAttribute(<span class="string">"countPage"</span>);</span><br><span class="line"><span class="keyword">if</span> (countPage == <span class="keyword">null</span>) &#123;</span><br><span class="line">    pageContext.setAttribute(<span class="string">"countPage"</span>, <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pageContext.setAttribute(<span class="string">"countPage"</span>, countPage + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　<br>　　这里先从pageContext中取出名为countPage的整数，因为返回的都是java.lang.Object类型，所以需要强制转换成我们需要的整形。这里取得的变量如果不存在就会返回null，通过判断countPage == null来辨别变量是否存在，如果不存在就设置为1，如果存在就进行累加，最后使用setAttribute()方法将修改后的变量值放入pageContext。<br>　　将其中的pageContext换成request, session, application就可以操作其他三个作用域中的变量。来源:</p>]]></content>
    
    <summary type="html">
    
      JSP九大内置对象及四个作用域，不需要预先声明就可以在脚本代码和表达式中随意使用
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
      <category term="Base64" scheme="http://localhost/tags/Base64/"/>
    
  </entry>
  
  <entry>
    <title>MD5</title>
    <link href="http://localhost/2018/03/27/Java/MD5/"/>
    <id>http://localhost/2018/03/27/Java/MD5/</id>
    <published>2018-03-27T03:11:37.844Z</published>
    <updated>2018-03-27T03:12:12.440Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Util</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*** </span></span><br><span class="line"><span class="comment">     * MD5加密 生成32位md5码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 待加密字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回32位md5码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5Encode</span><span class="params">(String inStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MessageDigest md5 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] byteArray = inStr.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] md5Bytes = md5.digest(byteArray);</span><br><span class="line">        StringBuffer hexValue = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; md5Bytes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = ((<span class="keyword">int</span>) md5Bytes[i]) &amp; <span class="number">0xff</span>;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; <span class="number">16</span>) &#123;</span><br><span class="line">                hexValue.append(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            hexValue.append(Integer.toHexString(val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hexValue.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      MD5
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
      <category term="MD5" scheme="http://localhost/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>图片上传BASE64转换</title>
    <link href="http://localhost/2018/03/27/Java/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0BASE64%E8%BD%AC%E6%8D%A2/"/>
    <id>http://localhost/2018/03/27/Java/图片上传BASE64转换/</id>
    <published>2018-03-27T02:31:06.416Z</published>
    <updated>2018-03-27T03:09:30.347Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        File imgFile = requse.getFile();</span><br><span class="line">        Long size = imgFile.length();</span><br><span class="line">        String contentType=img.getContentType();</span><br><span class="line">        System.out.println(<span class="string">"size:"</span>+size);</span><br><span class="line">        System.out.println(<span class="string">"contentType:"</span>+contentType);</span><br><span class="line">        <span class="comment">//将图片文件转化为字节数组字符串，并对其进行Base64编码处理</span></span><br><span class="line">       <span class="comment">// String imgFileUrl = img.getUploadPath()+"/"+img.getOriginalFileName();//待处理的图片</span></span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//读取图片字节数组</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(imgFile);        </span><br><span class="line">            data = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">            in.read(data);</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        img.getFile().delete();</span><br><span class="line">        <span class="comment">//对字节数组Base64编码</span></span><br><span class="line">        BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">        <span class="comment">//返回Base64编码过的字节数组字符串</span></span><br><span class="line">        String relt = encoder.encode(data);</span><br><span class="line">        renderText(relt);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      图片上传BASE64转换
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
      <category term="Base64" scheme="http://localhost/tags/Base64/"/>
    
  </entry>
  
  <entry>
    <title>图片验证码</title>
    <link href="http://localhost/2018/03/27/Java/%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://localhost/2018/03/27/Java/图片验证码/</id>
    <published>2018-03-27T02:31:06.416Z</published>
    <updated>2018-03-27T03:08:04.579Z</updated>
    
    <content type="html"><![CDATA[<p>导包如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Font;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics2D;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机验证图片发生器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BufferedImage <span class="title">drawVerifyCodeImage</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, String code)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建存放在内存中的图像并获取图像工具</span></span><br><span class="line">        BufferedImage image = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        Graphics2D g = (Graphics2D) image.getGraphics();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置图像边框，但是我这里不想要边框，所以就不设置了</span></span><br><span class="line">        <span class="comment">// g.setColor(Color.RED);</span></span><br><span class="line">        <span class="comment">// g.drawRect(0, 0, width, height);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置图像填充背景色，灰色Gray</span></span><br><span class="line">        g.setColor(Color.GRAY);</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置图片填充文字，但是需要一个一个写，并且让每个字随机旋转</span></span><br><span class="line">        g.setColor(Color.WHITE);</span><br><span class="line">        g.setFont(<span class="keyword">new</span> Font(<span class="string">"Arial"</span>, Font.PLAIN, height - <span class="number">5</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; code.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 设置旋转弧度</span></span><br><span class="line">            <span class="keyword">double</span> theta = (<span class="keyword">new</span> Random()).nextInt() % <span class="number">30</span> * Math.PI / <span class="number">180</span>;</span><br><span class="line">            g.rotate(theta, height * i + <span class="number">5</span>, height - <span class="number">5</span>);</span><br><span class="line">            g.drawString(code.substring(i, i + <span class="number">1</span>), height * i + <span class="number">5</span>, height - <span class="number">5</span>);</span><br><span class="line">            g.rotate(-theta, height * i + <span class="number">5</span>, height - <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置干扰线，条数可以自己设定，这里设置8条</span></span><br><span class="line">        g.setColor(Color.yellow);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = <span class="keyword">new</span> Random().nextInt(width);</span><br><span class="line">            <span class="keyword">int</span> y1 = <span class="keyword">new</span> Random().nextInt(height);</span><br><span class="line">            <span class="keyword">int</span> x2 = <span class="keyword">new</span> Random().nextInt(width);</span><br><span class="line">            <span class="keyword">int</span> y2 = <span class="keyword">new</span> Random().nextInt(height);</span><br><span class="line"></span><br><span class="line">            g.drawLine(x1, y1, x2, y2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回存放在内存中的图片对象</span></span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>BASE64转换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Encoder;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">VerifyCodeBase64</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, String code)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建编码对象</span></span><br><span class="line">        BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">        <span class="comment">// 创建字符流</span></span><br><span class="line">        ByteArrayOutputStream bs = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">// 写入字符流</span></span><br><span class="line">        ImageIO.write(drawVerifyCodeImage(width, height, code), <span class="string">"jpg"</span>, bs);</span><br><span class="line">        <span class="comment">// 转码成字符串</span></span><br><span class="line">        String imgsrc = encoder.encode(bs.toByteArray());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"data:image/jpg;base64,"</span> + imgsrc;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;导包如下&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.awt.Color;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.awt.Font;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.awt.Graphics2D;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.awt.image.BufferedImage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.Random;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
      <category term="Base64" scheme="http://localhost/tags/Base64/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot官方文档汉化 自主汉化--原创 彭应智</title>
    <link href="http://localhost/2018/03/24/Java/Spring%20Boot/"/>
    <id>http://localhost/2018/03/24/Java/Spring Boot/</id>
    <published>2018-03-24T02:04:55.000Z</published>
    <updated>2018-03-26T08:56:56.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>如果您开始使用Spring Boot，或“Spring”，一般先阅读本节。它回答了基本的“what？“how？”“why？”的问题。它包括一个介绍Spring Boot，以及安装说明。然后，我们将帮助您构建第一个Spring Boot应用程序，讨论一些核心原理。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Spring Boot可以轻松创建可以运行的独立的、基于生产级的基于Spring的应用程序。我们对Spring平台和第三方库有一种固定的规则，这样您就可以以最小的编码启动。大多数Spring Boot应用程序只需要很少的配置。</p><p>你可以使用Spring Boot创建java应用程序可以开始用<code>java -jar</code>或更传统的war包部署。我们还提供了一个命令行工具，它运行“spring scripts”。</p><p>主要内容：</p><ul><li>为所有 Spring 开发提供一个更快速、更全面的架构体验。</li><li>默认配置，但当需要使用非默认值时，可以快速配置。</li><li>提供大型项目常见的非业务功能。（如嵌入式服务器，安全，监控，心跳检查，和外部配置）。</li><li>绝对0代码配置，也可以不需要XML配置。</li></ul><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>Spring Boot 2.0.0.RELEASE 需要 Java 8 or 9 and Spring Framework 5.0.4.RELEASE 以上。编译需要 Maven 3.2+ and Gradle 4。</p><h2 id="Servlet-容器"><a href="#Servlet-容器" class="headerlink" title="Servlet 容器"></a>Servlet 容器</h2><p>Spring Boot 支持下列嵌入式servlet容器：</p><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Servlet Version</th></tr></thead><tbody><tr><td style="text-align:center">Tomcat 8.5</td><td style="text-align:center">3.1</td></tr><tr><td style="text-align:center">Jetty 9.4</td><td style="text-align:center">3.1</td></tr><tr><td style="text-align:center">Undertow 1.4</td><td style="text-align:center">3.1</td></tr></tbody></table><p>您还可以将Spring Boot程序部署到任何支持servlet 3+的容器中。</p><h2 id="Installing-Spring-Boot"><a href="#Installing-Spring-Boot" class="headerlink" title="Installing Spring Boot"></a>Installing Spring Boot</h2><p>Spring Boot 可以使用 Java 开发工具 或者安装 Spring 命令行工具。无论哪种方式, 你都需要 Java 1.8 及以上.。在你开始之前，你应该使用下面的命令查看当前Java版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br></pre></td></tr></table></figure><p>如果你是新的java开发或如果你想尝试Spring Boot，你可能想尝试Spring Boot CLI （命令行工具）。</p><h3 id="Installation-Instructions-for-the-Java-Developer"><a href="#Installation-Instructions-for-the-Java-Developer" class="headerlink" title="Installation Instructions for the Java Developer"></a>Installation Instructions for the Java Developer</h3><p>You can use Spring Boot in the same way as any standard Java library. To do so, include the appropriate spring-boot-*.jar files on your classpath. Spring Boot does not require any special tools integration, so you can use any IDE or text editor. Also, there is nothing special about a Spring Boot application, so you can run and debug a Spring Boot application as you would any other Java program.</p><p>Although you could copy Spring Boot jars, we generally recommend that you use a build tool that supports dependency management (such as Maven or Gradle).</p><h3 id="使用Maven"><a href="#使用Maven" class="headerlink" title="使用Maven"></a>使用Maven</h3><p>Spring Boot 编译请使用 Apache Maven 3.2 及以上。</p><p>Spring Boot dependencies use the org.springframework.boot groupId. Typically, your Maven POM file inherits from the spring-boot-starter-parent project and declares dependencies to one or more “Starters”. Spring Boot also provides an optional Maven plugin to create executable jars.</p><p>The following listing shows a typical pom.xml file:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Inherit defaults from Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Add typical dependencies for a web application --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Package as an executable jar --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>[Tip]<br>The spring-boot-starter-parent is a great way to use Spring Boot, but it might not be suitable all of the time. Sometimes you may need to inherit from a different parent POM, or you might not like our default settings. In those cases, see Section 13.2.2, “Using Spring Boot without the Parent POM” for an alternative solution that uses an import scope.</p>]]></content>
    
    <summary type="html">
    
      如果您开始使用Spring Boot，或“Spring”，一般先阅读本节。它回答了基本的“what？“how？”“why？”的问题。它包括一个介绍Spring Boot，以及安装说明。然后，我们将帮助您构建第一个Spring Boot应用程序，讨论一些核心原理。
    
    </summary>
    
      <category term="Java" scheme="http://localhost/categories/Java/"/>
    
      <category term="Spring" scheme="http://localhost/categories/Java/Spring/"/>
    
    
      <category term="Java" scheme="http://localhost/tags/Java/"/>
    
      <category term="Spring" scheme="http://localhost/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://localhost/tags/Spring-Boot/"/>
    
      <category term="原创" scheme="http://localhost/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用的Shell命令</title>
    <link href="http://localhost/2018/03/21/Linux/Linux%E5%B8%B8%E7%94%A8%E7%9A%84Shell%E5%91%BD%E4%BB%A4/"/>
    <id>http://localhost/2018/03/21/Linux/Linux常用的Shell命令/</id>
    <published>2018-03-21T08:32:06.000Z</published>
    <updated>2018-03-26T08:51:23.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍Linux系统下常用的系统级命令，包括软硬件查看、修改命令，有CPU、内存、硬盘、网络、系统管理等命令。说明，所有命令是在Centos 6.4 64位的虚拟机系统进行测试的。本文介绍的命令都会在此Centos下运行验证（也有部分命令会在suse/ubuntu系统里测试的，会做特明说明），但运行结果就不再列出了。</p></blockquote><a id="more"></a><h2 id="硬件篇"><a href="#硬件篇" class="headerlink" title="硬件篇"></a>硬件篇</h2><h3 id="CPU相关"><a href="#CPU相关" class="headerlink" title="CPU相关"></a>CPU相关</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lscpu                   #查看的是cpu的统计信息.</span><br><span class="line">cat /proc/cpuinfo       #查看CPU信息详细信息，如每个CPU的型号，主频等</span><br></pre></td></tr></table></figure><h3 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free -m                 #概要查看内存情况  这里的单位是MB</span><br><span class="line">cat /proc/meminfo       #查看内存详细信息</span><br></pre></td></tr></table></figure><h3 id="磁盘相关"><a href="#磁盘相关" class="headerlink" title="磁盘相关"></a>磁盘相关</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsblk                   <span class="comment">#查看硬盘和分区分布，显示很直观</span></span><br><span class="line">df -h                   <span class="comment">#查看各分区使用情况</span></span><br><span class="line">cat /proc/partitions    <span class="comment">#查看硬盘和分区</span></span><br><span class="line">mount | column -t       <span class="comment">#查看挂接的分区状态</span></span><br></pre></td></tr></table></figure><h3 id="网卡相关"><a href="#网卡相关" class="headerlink" title="网卡相关"></a>网卡相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep -i &apos;eth&apos;   #查看网卡硬件信息</span><br><span class="line">ifconfig -a             #查看系统的所有网络接口</span><br><span class="line">ethtool eth0            #如果要查看某个网络接口的详细信息，例如eth0的详细参数和指标</span><br></pre></td></tr></table></figure><h2 id="软件篇"><a href="#软件篇" class="headerlink" title="软件篇"></a>软件篇</h2><h3 id="内核相关"><a href="#内核相关" class="headerlink" title="内核相关"></a>内核相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uname -a                #查看版本当前操作系统内核信息）</span><br><span class="line">cat /proc/version       #查看当前操作系统版本信息</span><br><span class="line">cat /etc/issue          #查看版本当前操作系统发行版信息</span><br><span class="line">cat /etc/redhat-release #同上</span><br><span class="line">cat /etc/SuSE-release   #suse系统下才可使用</span><br><span class="line">lsb_release -a          #用来查看linux兼容性的发行版信息</span><br><span class="line">lsmod                   #列出加载的内核模块</span><br></pre></td></tr></table></figure><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ifconfig                #查看所有网络接口的属性</span><br><span class="line">iptables -L             #查看防火墙设置</span><br><span class="line">service iptables status #查看防火墙状态</span><br><span class="line">service iptables stop   #关闭防火墙</span><br><span class="line">route -n                #查看路由表</span><br><span class="line">netstat -lntp           #查看所有监听端口</span><br><span class="line">netstat -antp           #查看所有已经建立的连接</span><br><span class="line">netstat -s              #查看网络统计信息进程</span><br><span class="line">netstat -at             #列出所有tcp端口</span><br><span class="line">netstat -au             #列出所有udp端口</span><br><span class="line">netstat -lt             #只列出所有监听tcp端口</span><br></pre></td></tr></table></figure><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">top                     #查看系统所有进程的详细信息，比如CPU、内存等,信息很多！</span><br><span class="line">df -lh                  #查看硬盘大小及使用率</span><br><span class="line">mount                   #挂接远程目录、NFS、本地共享目录到linux下</span><br><span class="line">hostname                #查看/修改计算机名</span><br><span class="line">w                       #查看活动用户</span><br><span class="line">id                      #查看指定用户信息</span><br><span class="line">last                    #查看用户登录日志</span><br><span class="line">cut -d:-f1 /etc/passwd  #查看系统所有用户</span><br><span class="line">cut -d:-f1 /etc/group   #查看系统所有组</span><br><span class="line">crontab -l              #查看当前用户的计划任务服务</span><br><span class="line">chkconfig –list        #列出所有系统服务</span><br><span class="line">chkconfig –list | grep on #列出所有启动的系统服务程序</span><br><span class="line">rpm -qa                 #查看所有安装的软件包</span><br><span class="line">uptime                  #查看系统运行时间、用户数、负载    </span><br><span class="line">/sbin/chkconfig --list  #查看系统自动启动列表</span><br><span class="line">/sbin/chkconfig –addmysql #把MySQL添加到系统的启动服务组里面</span><br></pre></td></tr></table></figure><h3 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -lht                 #列出一个文件夹下所有文件及大小、访问权限</span><br><span class="line">du -sh                  #查看指定目录的大小 </span><br><span class="line">du -lh                  #查看指定目录及各文件的大小 </span><br><span class="line">ln -s                   #建立软链接</span><br></pre></td></tr></table></figure><h3 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pstree -p pid           #查看一个进程下的所有线程</span><br><span class="line">pstree  -a              #显示所有进程的所有详细信息，遇到相同的进程名可以压缩显示</span><br><span class="line">ps -ef                  #查看所有进程</span><br><span class="line">kill -9 pid             #杀死进程</span><br><span class="line">kill all test           #杀死进程</span><br><span class="line">kill -9`pgrep test`     #杀死进程</span><br><span class="line">./test.sh &amp;             #使程序在后台运行</span><br><span class="line">nohup ./test.sh &amp;       #使程序在后台运行</span><br></pre></td></tr></table></figure><h3 id="压缩解压缩"><a href="#压缩解压缩" class="headerlink" title="压缩解压缩"></a>压缩解压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zip -r dir.zip dir file         #将目录dir、文件file等压缩到zip包,</span><br><span class="line">zip -re dir.zip dir file        #创建zip包，且加密</span><br><span class="line">unzip dir.zip                   #解压</span><br><span class="line">tar -zcvf dir.tar.gz dir file   #将目录dir、文件file等压缩到tar包</span><br><span class="line">tar -xf dir.tar.gz              #解压</span><br></pre></td></tr></table></figure><h3 id="screen命令"><a href="#screen命令" class="headerlink" title="screen命令"></a>screen命令</h3><blockquote><p>screen命令组最大的好处就是当你的shell退出或关闭后，你运行的服务不会关系，也就是说，我们可以在screen里开启一组服务，且不受终端断开的影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">screen -S test          #创建一个名字为test的screen</span><br><span class="line">screen -r test          #打开名字为test的screen</span><br><span class="line">screen -r pid           #打开进程号为pid的screen</span><br><span class="line">screen -ls              #列出所有的screen</span><br><span class="line">ctrl + a,d              #当在一个screen时，退出screen</span><br><span class="line">ctrl + a,n              #当在一个screen时，切换到下一个窗口</span><br><span class="line">ctrl + a,c              #当在一个screen时，创建一个新的窗口</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_dir    #拷贝本地文件到远程机器上</span><br><span class="line">scp -r local_dir remote_username@remote_ip:remote_dir  #拷贝本地整个目录到远程机器上</span><br></pre></td></tr></table></figure><h3 id="软件包安装管理命令"><a href="#软件包安装管理命令" class="headerlink" title="软件包安装管理命令"></a>软件包安装管理命令</h3><p>假设你想要安装的软件包叫做app，注意，这里的命令通常需要sudo或者root权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//centos系统、redhat系统</span><br><span class="line">rpm -qa | grep app      #查找本机是否安装了app；</span><br><span class="line">rpm -ivh app.rpm        #假设你有app的rpm包，这样直接安装</span><br><span class="line">sudo yum install app    #否则就在线安装</span><br><span class="line">yum update app          #更新app</span><br><span class="line">rpm -e app              #删除已安装的app包</span><br><span class="line">//suse、opensuse系统</span><br><span class="line">zypper search app       #查找本机是否安装了app；</span><br><span class="line">zypper install app      #安装</span><br><span class="line">zypper update app       #更新</span><br><span class="line">zypper remove app       #删除</span><br><span class="line">zypper lr               #列出所有已定义的安装源。</span><br><span class="line">zypper    ar            #添加新安装源。</span><br><span class="line">zypper    rr            #删除指定的安装源</span><br><span class="line">zypper    mr            #修改指定的安装源</span><br><span class="line">//ubuntu系统</span><br><span class="line">apt-get install app     #安装</span><br><span class="line">apt-get update app      #更新</span><br><span class="line">apt-get remove app      #删除    </span><br><span class="line">apt-cache search app    #搜索软件包</span><br><span class="line">dpkg -i app.deb         #假设你有app的deb包，这样直接安装</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文介绍Linux系统下常用的系统级命令，包括软硬件查看、修改命令，有CPU、内存、硬盘、网络、系统管理等命令。说明，所有命令是在Centos 6.4 64位的虚拟机系统进行测试的。本文介绍的命令都会在此Centos下运行验证（也有部分命令会在suse/ubuntu系统里测试的，会做特明说明），但运行结果就不再列出了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://localhost/categories/Linux/"/>
    
      <category term="Shell" scheme="http://localhost/categories/Linux/Shell/"/>
    
    
      <category term="Linux" scheme="http://localhost/tags/Linux/"/>
    
      <category term="Shell" scheme="http://localhost/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://localhost/2018/03/20/hello-world/"/>
    <id>http://localhost/2018/03/20/hello-world/</id>
    <published>2018-03-20T08:04:26.147Z</published>
    <updated>2018-03-26T08:36:41.550Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>随笔001</title>
    <link href="http://localhost/2016/03/19/%E6%94%B6%E9%9B%86/%E9%9A%8F%E7%AC%94001/"/>
    <id>http://localhost/2016/03/19/收集/随笔001/</id>
    <published>2016-03-19T02:04:55.000Z</published>
    <updated>2018-03-27T02:30:07.391Z</updated>
    
    <content type="html"><![CDATA[<p>1、所谓铁饭碗，不是在一个地方吃一辈子饭，而是一辈子到哪里都有饭吃。<br>2、把每一件简单的事做好，就不简单；把每一件平凡的事做好，就是不平凡。<br>3、生活的最高境界是宽容，相处的最高境界是尊重。<br>4、从崇高到荒唐只有一步，从荒唐到崇高却没有路。<br>5、何谓生老病死？生的要好，老的要慢，病的要晚，死的要快。<br>6、傲不可长，欲不可纵，乐不可极，志不可移。<br>7、不与富交我不贫，不与贵交我不贱。<br>8、世上只有想不通的人，没有走不通的路。<br>9、能力就像一张支票，除非把它兑成现金，否则毫无价值。</p><p>第一课：<br>　　爹对儿子说，我想给你找个媳妇。儿子说，可我愿意自己找！爹说，可这个女孩子是比尔盖茨的女儿！儿子说，要是这样，可以。<br>　　然后他爹找到比尔盖茨，说，我给你女儿找了一个老公。比尔盖茨说，不行，我女儿还小！爹说，可是这个小伙子是世界银行的副总裁！比尔盖茨说，啊，这样，行！<br>　　最后，爹找到了世界银行的总裁，说，我给你推荐一个副总裁！总裁说，可是我有太多副总裁了，多余了！爹说，可是这个小伙子是比尔盖茨的女婿！总裁说，这样，行！<br>——生意就是这样做成的。<br>第二课：<br>　　一个销售员、一个办事员和他们的经理步行去午餐时发现了一盏古代油灯。他们摩擦油灯，一个精灵跳了出来。精灵说：“我能满足你们每人一个愿望。”“我先！我先！”办事员说，“我想去巴哈马群岛，开着快艇，与世隔绝。”倏！她飞走了。“该我了！该我了！”销售员说，“我想去夏威夷，躺在沙滩上，有私人女按摩师，免费续杯的冰镇果汁朗姆酒，还有一生中的最爱。”倏！他飞走了。“OK,该你了。”精灵对经理说。经理回答：“我要那两个蠢货午饭后马上回来工作！”<br>——永远让你的老板先开口<br>第三课：<br>　　一只小鸟飞去南方过冬。天实在太冷了。它冻僵了，掉在一片田野上。它躺在那儿时，一头母牛走过来在它身上拉了一堆屎。冻僵的小鸟躺在粪堆里，开始感觉到了温暖。牛粪确实使它暖和过来了。<br>　　它躺在温暖的牛粪中，异常高兴，并开始唱起歌来。<br>　　一只过路的猫听到鸟叫赶过来看个究竟。顺着声音，它发现了牛粪下的小鸟，并迅速把它拖出来吃掉了。<br>故事寓意：<br>　　(1)并不是每个在你身上拉屎的都是你的敌人<br>　　(2)并不是每个把你拖出粪堆的都是你的朋友<br>　　(3)当你深陷粪堆中的时候，最好闭上你的鸟嘴</p><p>第四课：<br>　　一个男人在他妻子洗完澡后准备进浴室洗澡。这时，门铃响了。妻子迅速用浴巾裹住自己冲到门口。当她打开门时，邻居鲍勃站在那儿。在她开口前，鲍勃说，“你如果把浴巾拿掉，我给你800美元。”想了一会儿，这个女人拿掉浴巾赤裸地站在鲍勃面前。<br>　　几秒钟后，鲍勃递给她800美元然后离开了。女人重新裹好浴巾回到屋里。当她踏进浴室时，丈夫问她，“是谁呀？”<br>　　“是邻居鲍勃。”她回答。<br>　　“哦，”丈夫说，“他有没有提到还欠我800美元？”<br>　　——及时与同舟共济的股东分享重要信息，将会避免不必要的曝光。</p><p>第六课：<br>　　你开着一辆车。<br>　　在一个暴风雨的晚上。<br>　　你经过一个车站。<br>　　有三个人正在焦急的等公共汽车。<br>　　一个是快要临死的老人，他需要马上去医院<br>　　一个是医生，他曾救过你的命，你做梦都想报答他。<br>　　还有一个女人/男人，她/他是你做梦都想嫁/娶的人，也许错过就没有了。<br>　　但你的车只能再坐下一个人，你会如何选择？<br>　　我不知道这是不是一个对你性格的测试,因为每一个回答都有他自己的原因。<br>　　老人快要死了，你首先应该先救他。<br>　　你也想让那个医生上车，因为他救过你，这是个好机会报答他。<br>　　还有就是你的梦中情人。错过了这个机会。你可能永远不能遇到一个让你这么心动的人了。<br>　　在200个应征者中，只有一个人被雇佣了，他并没有解释他的理由，他只是说了以下的话：’给医生车钥匙，让他带着老人去医院，而我则留下来陪我的梦中情人一起等公车!’<br>小哲理：<br>　　是否是因为我们从未想过要放弃我们手中已经拥有的优势（车钥匙）<br>　　有时，如果我们能放弃一些我们的固执，狭隘，和一些优势的话，我们可能会得到更多。</p><p>第七课：<br>　　很久很久以前，人类都还赤着双脚走路。<br>　　有一位国王到某个偏远的乡间旅行，因为路面崎岖不平，有很多碎石头，刺得他的脚又痛又麻。回到王宫后，他下了一道命令，要将国内的所有道路都铺上一层牛皮。他认为这样做，不只是为自己，还可造福他的人民，让大家走路时不再受刺痛之苦。<br>　　但即使杀尽国内所有的牛，也筹措不到足够的皮革，而所花费的金钱、动用的人力，更不知凡几。关注微信”销售总监”学习更多销售技巧。虽然根本做不到，甚至还相当愚蠢，但因为是国王的命令，大家也只能摇头叹息。<br>　　一位聪明的仆人大胆向国王提出建言：「国王啊！为什么您要劳师动众，牺牲那么多头牛，花费那么多金钱呢？您何不只用两小片牛皮包住您的脚呢？」国王听了很惊讶，但也当下领悟，于是立刻收回成命，改采这个建议。据说，这就是「皮鞋」的由来。<br>小哲理：<br>　　想改变世界，很难；要改变自己，则较为容易。与其改变全世界，不如先改变自己–「将自己的双脚包起来」。改变自己的某些观念和作法，以抵御外来的侵袭。当自己改变后，眼中的世界自然也就跟着改变了。如果你希望看到世界改变，那么第一个必须改变的就是自己。<br>　　心若改变，态度就会改变；态度改变，习惯就改变；习惯改变，人生就会改变。</p>]]></content>
    
    <summary type="html">
    
      1、所谓铁饭碗，不是在一个地方吃一辈子饭，而是一辈子到哪里都有饭吃。
    
    </summary>
    
      <category term="随笔" scheme="http://localhost/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="道理" scheme="http://localhost/tags/%E9%81%93%E7%90%86/"/>
    
      <category term="随笔" scheme="http://localhost/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
